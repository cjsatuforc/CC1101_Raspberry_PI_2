
timesync:     file format elf32-littlearm


Disassembly of section .init:

000107e4 <_init>:
   107e4:	e92d4008 	push	{r3, lr}
   107e8:	eb000053 	bl	1093c <call_weak_fn>
   107ec:	e8bd8008 	pop	{r3, pc}

Disassembly of section .plt:

000107f0 <open@plt-0x14>:
   107f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
   107f4:	e59fe004 	ldr	lr, [pc, #4]	; 10800 <_init+0x1c>
   107f8:	e08fe00e 	add	lr, pc, lr
   107fc:	e5bef008 	ldr	pc, [lr, #8]!
   10800:	00011cdc 	.word	0x00011cdc

00010804 <open@plt>:
   10804:	e28fc600 	add	ip, pc, #0, 12
   10808:	e28cca11 	add	ip, ip, #69632	; 0x11000
   1080c:	e5bcfcdc 	ldr	pc, [ip, #3292]!	; 0xcdc

00010810 <mmap@plt>:
   10810:	e28fc600 	add	ip, pc, #0, 12
   10814:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10818:	e5bcfcd4 	ldr	pc, [ip, #3284]!	; 0xcd4

0001081c <abort@plt>:
   1081c:	e28fc600 	add	ip, pc, #0, 12
   10820:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10824:	e5bcfccc 	ldr	pc, [ip, #3276]!	; 0xccc

00010828 <__libc_start_main@plt>:
   10828:	e28fc600 	add	ip, pc, #0, 12
   1082c:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10830:	e5bcfcc4 	ldr	pc, [ip, #3268]!	; 0xcc4

00010834 <clock_gettime@plt>:
   10834:	e28fc600 	add	ip, pc, #0, 12
   10838:	e28cca11 	add	ip, ip, #69632	; 0x11000
   1083c:	e5bcfcbc 	ldr	pc, [ip, #3260]!	; 0xcbc

00010840 <__gmon_start__@plt>:
   10840:	e28fc600 	add	ip, pc, #0, 12
   10844:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10848:	e5bcfcb4 	ldr	pc, [ip, #3252]!	; 0xcb4

0001084c <putchar@plt>:
   1084c:	e28fc600 	add	ip, pc, #0, 12
   10850:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10854:	e5bcfcac 	ldr	pc, [ip, #3244]!	; 0xcac

00010858 <calloc@plt>:
   10858:	e28fc600 	add	ip, pc, #0, 12
   1085c:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10860:	e5bcfca4 	ldr	pc, [ip, #3236]!	; 0xca4

00010864 <memset@plt>:
   10864:	e28fc600 	add	ip, pc, #0, 12
   10868:	e28cca11 	add	ip, ip, #69632	; 0x11000
   1086c:	e5bcfc9c 	ldr	pc, [ip, #3228]!	; 0xc9c

00010870 <perror@plt>:
   10870:	e28fc600 	add	ip, pc, #0, 12
   10874:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10878:	e5bcfc94 	ldr	pc, [ip, #3220]!	; 0xc94

0001087c <__assert_fail@plt>:
   1087c:	e28fc600 	add	ip, pc, #0, 12
   10880:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10884:	e5bcfc8c 	ldr	pc, [ip, #3212]!	; 0xc8c

00010888 <free@plt>:
   10888:	e28fc600 	add	ip, pc, #0, 12
   1088c:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10890:	e5bcfc84 	ldr	pc, [ip, #3204]!	; 0xc84

00010894 <fflush@plt>:
   10894:	e28fc600 	add	ip, pc, #0, 12
   10898:	e28cca11 	add	ip, ip, #69632	; 0x11000
   1089c:	e5bcfc7c 	ldr	pc, [ip, #3196]!	; 0xc7c

000108a0 <ioctl@plt>:
   108a0:	e28fc600 	add	ip, pc, #0, 12
   108a4:	e28cca11 	add	ip, ip, #69632	; 0x11000
   108a8:	e5bcfc74 	ldr	pc, [ip, #3188]!	; 0xc74

000108ac <__ubsan_handle_add_overflow@plt>:
   108ac:	e28fc600 	add	ip, pc, #0, 12
   108b0:	e28cca11 	add	ip, ip, #69632	; 0x11000
   108b4:	e5bcfc6c 	ldr	pc, [ip, #3180]!	; 0xc6c

000108b8 <printf@plt>:
   108b8:	e28fc600 	add	ip, pc, #0, 12
   108bc:	e28cca11 	add	ip, ip, #69632	; 0x11000
   108c0:	e5bcfc64 	ldr	pc, [ip, #3172]!	; 0xc64

000108c4 <close@plt>:
   108c4:	e28fc600 	add	ip, pc, #0, 12
   108c8:	e28cca11 	add	ip, ip, #69632	; 0x11000
   108cc:	e5bcfc5c 	ldr	pc, [ip, #3164]!	; 0xc5c

000108d0 <malloc@plt>:
   108d0:	e28fc600 	add	ip, pc, #0, 12
   108d4:	e28cca11 	add	ip, ip, #69632	; 0x11000
   108d8:	e5bcfc54 	ldr	pc, [ip, #3156]!	; 0xc54

000108dc <__ubsan_handle_type_mismatch@plt>:
   108dc:	e28fc600 	add	ip, pc, #0, 12
   108e0:	e28cca11 	add	ip, ip, #69632	; 0x11000
   108e4:	e5bcfc4c 	ldr	pc, [ip, #3148]!	; 0xc4c

000108e8 <puts@plt>:
   108e8:	e28fc600 	add	ip, pc, #0, 12
   108ec:	e28cca11 	add	ip, ip, #69632	; 0x11000
   108f0:	e5bcfc44 	ldr	pc, [ip, #3140]!	; 0xc44

000108f4 <strcmp@plt>:
   108f4:	e28fc600 	add	ip, pc, #0, 12
   108f8:	e28cca11 	add	ip, ip, #69632	; 0x11000
   108fc:	e5bcfc3c 	ldr	pc, [ip, #3132]!	; 0xc3c

00010900 <exit@plt>:
   10900:	e28fc600 	add	ip, pc, #0, 12
   10904:	e28cca11 	add	ip, ip, #69632	; 0x11000
   10908:	e5bcfc34 	ldr	pc, [ip, #3124]!	; 0xc34

Disassembly of section .text:

0001090c <_start>:
   1090c:	f04f 0b00 	mov.w	fp, #0
   10910:	f04f 0e00 	mov.w	lr, #0
   10914:	bc02      	pop	{r1}
   10916:	466a      	mov	r2, sp
   10918:	b404      	push	{r2}
   1091a:	b401      	push	{r0}
   1091c:	f8df c010 	ldr.w	ip, [pc, #16]	; 10930 <_start+0x24>
   10920:	f84d cd04 	str.w	ip, [sp, #-4]!
   10924:	4803      	ldr	r0, [pc, #12]	; (10934 <_start+0x28>)
   10926:	4b04      	ldr	r3, [pc, #16]	; (10938 <_start+0x2c>)
   10928:	f7ff ef7e 	blx	10828 <__libc_start_main@plt>
   1092c:	f7ff ef76 	blx	1081c <abort@plt>
   10930:	000120cd 	.word	0x000120cd
   10934:	00011d79 	.word	0x00011d79
   10938:	0001208d 	.word	0x0001208d

0001093c <call_weak_fn>:
   1093c:	e59f3014 	ldr	r3, [pc, #20]	; 10958 <call_weak_fn+0x1c>
   10940:	e59f2014 	ldr	r2, [pc, #20]	; 1095c <call_weak_fn+0x20>
   10944:	e08f3003 	add	r3, pc, r3
   10948:	e7932002 	ldr	r2, [r3, r2]
   1094c:	e3520000 	cmp	r2, #0
   10950:	012fff1e 	bxeq	lr
   10954:	eaffffb9 	b	10840 <__gmon_start__@plt>
   10958:	00011b90 	.word	0x00011b90
   1095c:	00000064 	.word	0x00000064

00010960 <deregister_tm_clones>:
   10960:	4b07      	ldr	r3, [pc, #28]	; (10980 <deregister_tm_clones+0x20>)
   10962:	f642 40f4 	movw	r0, #11508	; 0x2cf4
   10966:	f2c0 0002 	movt	r0, #2
   1096a:	1a1b      	subs	r3, r3, r0
   1096c:	2b06      	cmp	r3, #6
   1096e:	d905      	bls.n	1097c <deregister_tm_clones+0x1c>
   10970:	f240 0300 	movw	r3, #0
   10974:	f2c0 0300 	movt	r3, #0
   10978:	b103      	cbz	r3, 1097c <deregister_tm_clones+0x1c>
   1097a:	4718      	bx	r3
   1097c:	4770      	bx	lr
   1097e:	bf00      	nop
   10980:	00022cf7 	.word	0x00022cf7

00010984 <register_tm_clones>:
   10984:	f642 43f4 	movw	r3, #11508	; 0x2cf4
   10988:	f642 40f4 	movw	r0, #11508	; 0x2cf4
   1098c:	f2c0 0302 	movt	r3, #2
   10990:	f2c0 0002 	movt	r0, #2
   10994:	1a19      	subs	r1, r3, r0
   10996:	1089      	asrs	r1, r1, #2
   10998:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
   1099c:	1049      	asrs	r1, r1, #1
   1099e:	d005      	beq.n	109ac <register_tm_clones+0x28>
   109a0:	f240 0300 	movw	r3, #0
   109a4:	f2c0 0300 	movt	r3, #0
   109a8:	b103      	cbz	r3, 109ac <register_tm_clones+0x28>
   109aa:	4718      	bx	r3
   109ac:	4770      	bx	lr
   109ae:	bf00      	nop

000109b0 <__do_global_dtors_aux>:
   109b0:	b510      	push	{r4, lr}
   109b2:	f642 44f8 	movw	r4, #11512	; 0x2cf8
   109b6:	f2c0 0402 	movt	r4, #2
   109ba:	7823      	ldrb	r3, [r4, #0]
   109bc:	b91b      	cbnz	r3, 109c6 <__do_global_dtors_aux+0x16>
   109be:	f7ff ffcf 	bl	10960 <deregister_tm_clones>
   109c2:	2301      	movs	r3, #1
   109c4:	7023      	strb	r3, [r4, #0]
   109c6:	bd10      	pop	{r4, pc}

000109c8 <frame_dummy>:
   109c8:	f242 30d0 	movw	r0, #9168	; 0x23d0
   109cc:	b508      	push	{r3, lr}
   109ce:	f2c0 0002 	movt	r0, #2
   109d2:	6803      	ldr	r3, [r0, #0]
   109d4:	b913      	cbnz	r3, 109dc <frame_dummy+0x14>
   109d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   109da:	e7d3      	b.n	10984 <register_tm_clones>
   109dc:	f240 0300 	movw	r3, #0
   109e0:	f2c0 0300 	movt	r3, #0
   109e4:	2b00      	cmp	r3, #0
   109e6:	d0f6      	beq.n	109d6 <frame_dummy+0xe>
   109e8:	4798      	blx	r3
   109ea:	e7f4      	b.n	109d6 <frame_dummy+0xe>

000109ec <setup_io>:
void setup_io();
 
 
 
void setup_io()
{
   109ec:	b580      	push	{r7, lr}
   109ee:	b082      	sub	sp, #8
   109f0:	af02      	add	r7, sp, #8
   /* open /dev/mem */
   if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
   109f2:	f242 1028 	movw	r0, #8488	; 0x2128
   109f6:	f2c0 0001 	movt	r0, #1
   109fa:	f241 0102 	movw	r1, #4098	; 0x1002
   109fe:	f2c0 0110 	movt	r1, #16
   10a02:	f7ff ef00 	blx	10804 <open@plt>
   10a06:	4602      	mov	r2, r0
   10a08:	f642 43fc 	movw	r3, #11516	; 0x2cfc
   10a0c:	f2c0 0302 	movt	r3, #2
   10a10:	601a      	str	r2, [r3, #0]
   10a12:	f642 43fc 	movw	r3, #11516	; 0x2cfc
   10a16:	f2c0 0302 	movt	r3, #2
   10a1a:	681b      	ldr	r3, [r3, #0]
   10a1c:	2b00      	cmp	r3, #0
   10a1e:	da09      	bge.n	10a34 <setup_io+0x48>
      printf("can't open /dev/mem \n");
   10a20:	f242 1034 	movw	r0, #8500	; 0x2134
   10a24:	f2c0 0001 	movt	r0, #1
   10a28:	f7ff ef5e 	blx	108e8 <puts@plt>
      exit(-1);
   10a2c:	f04f 30ff 	mov.w	r0, #4294967295
   10a30:	f7ff ef66 	blx	10900 <exit@plt>
   }
 
   /* mmap GPIO */
   gpio_map = mmap(
   10a34:	f642 43fc 	movw	r3, #11516	; 0x2cfc
   10a38:	f2c0 0302 	movt	r3, #2
   10a3c:	681b      	ldr	r3, [r3, #0]
   10a3e:	9300      	str	r3, [sp, #0]
   10a40:	2300      	movs	r3, #0
   10a42:	f6c3 7320 	movt	r3, #16160	; 0x3f20
   10a46:	9301      	str	r3, [sp, #4]
   10a48:	2000      	movs	r0, #0
   10a4a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   10a4e:	2203      	movs	r2, #3
   10a50:	2301      	movs	r3, #1
   10a52:	f7ff eede 	blx	10810 <mmap@plt>
   10a56:	4602      	mov	r2, r0
   10a58:	f642 5300 	movw	r3, #11520	; 0x2d00
   10a5c:	f2c0 0302 	movt	r3, #2
   10a60:	601a      	str	r2, [r3, #0]
      MAP_SHARED,       //Shared with other processes
      mem_fd,           //File to map
      GPIO_BASE         //Offset to GPIO peripheral
   );
 
   close(mem_fd); //No need to keep mem_fd open after mmap
   10a62:	f642 43fc 	movw	r3, #11516	; 0x2cfc
   10a66:	f2c0 0302 	movt	r3, #2
   10a6a:	681b      	ldr	r3, [r3, #0]
   10a6c:	4618      	mov	r0, r3
   10a6e:	f7ff ef2a 	blx	108c4 <close@plt>
 
   if (gpio_map == MAP_FAILED) {
   10a72:	f642 5300 	movw	r3, #11520	; 0x2d00
   10a76:	f2c0 0302 	movt	r3, #2
   10a7a:	681b      	ldr	r3, [r3, #0]
   10a7c:	f1b3 3fff 	cmp.w	r3, #4294967295
   10a80:	d10f      	bne.n	10aa2 <setup_io+0xb6>
      printf("mmap error %d\n", (int)gpio_map);//errno also set!
   10a82:	f642 5300 	movw	r3, #11520	; 0x2d00
   10a86:	f2c0 0302 	movt	r3, #2
   10a8a:	681b      	ldr	r3, [r3, #0]
   10a8c:	f242 104c 	movw	r0, #8524	; 0x214c
   10a90:	f2c0 0001 	movt	r0, #1
   10a94:	4619      	mov	r1, r3
   10a96:	f7ff ef10 	blx	108b8 <printf@plt>
      exit(-1);
   10a9a:	f04f 30ff 	mov.w	r0, #4294967295
   10a9e:	f7ff ef30 	blx	10900 <exit@plt>
   }
 
   // Always use volatile pointer!
   gpio = (volatile unsigned *)gpio_map;
   10aa2:	f642 5300 	movw	r3, #11520	; 0x2d00
   10aa6:	f2c0 0302 	movt	r3, #2
   10aaa:	681a      	ldr	r2, [r3, #0]
   10aac:	f642 5304 	movw	r3, #11524	; 0x2d04
   10ab0:	f2c0 0302 	movt	r3, #2
   10ab4:	601a      	str	r2, [r3, #0]
 
 
} // setup_io
   10ab6:	46bd      	mov	sp, r7
   10ab8:	bd80      	pop	{r7, pc}
   10aba:	bf00      	nop

00010abc <open_spi>:

const char *spi_dev_name = SPI_DEVNAME;

int open_spi(const char *devname)
{
   10abc:	b580      	push	{r7, lr}
   10abe:	b084      	sub	sp, #16
   10ac0:	af00      	add	r7, sp, #0
   10ac2:	6078      	str	r0, [r7, #4]
    int fd = open(devname, O_RDWR);
   10ac4:	6878      	ldr	r0, [r7, #4]
   10ac6:	2102      	movs	r1, #2
   10ac8:	f7ff ee9c 	blx	10804 <open@plt>
   10acc:	60f8      	str	r0, [r7, #12]
    if (fd < 0)
   10ace:	68fb      	ldr	r3, [r7, #12]
   10ad0:	2b00      	cmp	r3, #0
   10ad2:	da09      	bge.n	10ae8 <open_spi+0x2c>
    {
        perror("Open Failed\n");
   10ad4:	f242 106c 	movw	r0, #8556	; 0x216c
   10ad8:	f2c0 0001 	movt	r0, #1
   10adc:	f7ff eec8 	blx	10870 <perror@plt>
        exit(-1);
   10ae0:	f04f 30ff 	mov.w	r0, #4294967295
   10ae4:	f7ff ef0c 	blx	10900 <exit@plt>
    }
    return fd;
   10ae8:	68fb      	ldr	r3, [r7, #12]
}
   10aea:	4618      	mov	r0, r3
   10aec:	3710      	adds	r7, #16
   10aee:	46bd      	mov	sp, r7
   10af0:	bd80      	pop	{r7, pc}
   10af2:	bf00      	nop

00010af4 <close_spi>:

int close_spi(int fd)
{
   10af4:	b580      	push	{r7, lr}
   10af6:	b082      	sub	sp, #8
   10af8:	af00      	add	r7, sp, #0
   10afa:	6078      	str	r0, [r7, #4]
    if (close(fd))
   10afc:	6878      	ldr	r0, [r7, #4]
   10afe:	f7ff eee2 	blx	108c4 <close@plt>
   10b02:	4603      	mov	r3, r0
   10b04:	2b00      	cmp	r3, #0
   10b06:	d009      	beq.n	10b1c <close_spi+0x28>
    {
        perror("Close Failed\n");
   10b08:	f242 107c 	movw	r0, #8572	; 0x217c
   10b0c:	f2c0 0001 	movt	r0, #1
   10b10:	f7ff eeae 	blx	10870 <perror@plt>
        exit(-1);
   10b14:	f04f 30ff 	mov.w	r0, #4294967295
   10b18:	f7ff eef2 	blx	10900 <exit@plt>
    }
    return 0;
   10b1c:	2300      	movs	r3, #0
}
   10b1e:	4618      	mov	r0, r3
   10b20:	3708      	adds	r7, #8
   10b22:	46bd      	mov	sp, r7
   10b24:	bd80      	pop	{r7, pc}
   10b26:	bf00      	nop

00010b28 <default_spi_config>:

void default_spi_config(int fd)
{
   10b28:	b580      	push	{r7, lr}
   10b2a:	b084      	sub	sp, #16
   10b2c:	af00      	add	r7, sp, #0
   10b2e:	6078      	str	r0, [r7, #4]
    int x; 
    x = SPI_MODE_0;
   10b30:	2300      	movs	r3, #0
   10b32:	60fb      	str	r3, [r7, #12]
    if(ioctl(fd, SPI_IOC_WR_MODE, &x))
   10b34:	f107 030c 	add.w	r3, r7, #12
   10b38:	6878      	ldr	r0, [r7, #4]
   10b3a:	f646 3101 	movw	r1, #27393	; 0x6b01
   10b3e:	f2c4 0101 	movt	r1, #16385	; 0x4001
   10b42:	461a      	mov	r2, r3
   10b44:	f7ff eeac 	blx	108a0 <ioctl@plt>
   10b48:	4603      	mov	r3, r0
   10b4a:	2b00      	cmp	r3, #0
   10b4c:	d005      	beq.n	10b5a <default_spi_config+0x32>
    {
        perror("Failed to set mode to SPI_MODE_0");
   10b4e:	f242 108c 	movw	r0, #8588	; 0x218c
   10b52:	f2c0 0001 	movt	r0, #1
   10b56:	f7ff ee8c 	blx	10870 <perror@plt>
    }
    x = SPI_SPEED;
   10b5a:	f644 3340 	movw	r3, #19264	; 0x4b40
   10b5e:	f2c0 034c 	movt	r3, #76	; 0x4c
   10b62:	60fb      	str	r3, [r7, #12]
    if(ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &x))
   10b64:	f107 030c 	add.w	r3, r7, #12
   10b68:	6878      	ldr	r0, [r7, #4]
   10b6a:	f646 3104 	movw	r1, #27396	; 0x6b04
   10b6e:	f2c4 0104 	movt	r1, #16388	; 0x4004
   10b72:	461a      	mov	r2, r3
   10b74:	f7ff ee94 	blx	108a0 <ioctl@plt>
   10b78:	4603      	mov	r3, r0
   10b7a:	2b00      	cmp	r3, #0
   10b7c:	d005      	beq.n	10b8a <default_spi_config+0x62>
    {
        perror("Failed to set speed");
   10b7e:	f242 10b0 	movw	r0, #8624	; 0x21b0
   10b82:	f2c0 0001 	movt	r0, #1
   10b86:	f7ff ee74 	blx	10870 <perror@plt>
    }
    x = 8;  
   10b8a:	2308      	movs	r3, #8
   10b8c:	60fb      	str	r3, [r7, #12]
    if(ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &x))
   10b8e:	f107 030c 	add.w	r3, r7, #12
   10b92:	6878      	ldr	r0, [r7, #4]
   10b94:	f646 3103 	movw	r1, #27395	; 0x6b03
   10b98:	f2c4 0101 	movt	r1, #16385	; 0x4001
   10b9c:	461a      	mov	r2, r3
   10b9e:	f7ff ee80 	blx	108a0 <ioctl@plt>
   10ba2:	4603      	mov	r3, r0
   10ba4:	2b00      	cmp	r3, #0
   10ba6:	d006      	beq.n	10bb6 <default_spi_config+0x8e>
    {
        perror("Failed to set bpw");
   10ba8:	f242 10c4 	movw	r0, #8644	; 0x21c4
   10bac:	f2c0 0001 	movt	r0, #1
   10bb0:	f7ff ee5e 	blx	10870 <perror@plt>
   10bb4:	e01b      	b.n	10bee <default_spi_config+0xc6>
    }
    else if(ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &x))
   10bb6:	f107 030c 	add.w	r3, r7, #12
   10bba:	6878      	ldr	r0, [r7, #4]
   10bbc:	f646 3103 	movw	r1, #27395	; 0x6b03
   10bc0:	f2c8 0101 	movt	r1, #32769	; 0x8001
   10bc4:	461a      	mov	r2, r3
   10bc6:	f7ff ee6c 	blx	108a0 <ioctl@plt>
   10bca:	4603      	mov	r3, r0
   10bcc:	2b00      	cmp	r3, #0
   10bce:	d006      	beq.n	10bde <default_spi_config+0xb6>
    {
        perror("Failed to get bwp");
   10bd0:	f242 10d8 	movw	r0, #8664	; 0x21d8
   10bd4:	f2c0 0001 	movt	r0, #1
   10bd8:	f7ff ee4a 	blx	10870 <perror@plt>
   10bdc:	e007      	b.n	10bee <default_spi_config+0xc6>
    }
    else
    {
        printf("BPW: %d\n", x);
   10bde:	68fb      	ldr	r3, [r7, #12]
   10be0:	f242 10ec 	movw	r0, #8684	; 0x21ec
   10be4:	f2c0 0001 	movt	r0, #1
   10be8:	4619      	mov	r1, r3
   10bea:	f7ff ee66 	blx	108b8 <printf@plt>
    }
}
   10bee:	3710      	adds	r7, #16
   10bf0:	46bd      	mov	sp, r7
   10bf2:	bd80      	pop	{r7, pc}

00010bf4 <write_reg>:
#define READ_CMD_BIT (1<<7)
#define BURST_CMD_BIT (1<<6)


void write_reg(int fd, uint8_t addr, uint8_t value, uint8_t *response)
{
   10bf4:	b5b0      	push	{r4, r5, r7, lr}
   10bf6:	b090      	sub	sp, #64	; 0x40
   10bf8:	af00      	add	r7, sp, #0
   10bfa:	60f8      	str	r0, [r7, #12]
   10bfc:	607b      	str	r3, [r7, #4]
   10bfe:	460b      	mov	r3, r1
   10c00:	72fb      	strb	r3, [r7, #11]
   10c02:	4613      	mov	r3, r2
   10c04:	72bb      	strb	r3, [r7, #10]
    int ret;
    struct spi_ioc_transfer tr;
    #define N_RESP_BYTES (2) 
    uint8_t *wr, *rd;
    wr = malloc(N_RESP_BYTES);
   10c06:	2002      	movs	r0, #2
   10c08:	f7ff ee62 	blx	108d0 <malloc@plt>
   10c0c:	4603      	mov	r3, r0
   10c0e:	63fb      	str	r3, [r7, #60]	; 0x3c
    rd = malloc(N_RESP_BYTES);
   10c10:	2002      	movs	r0, #2
   10c12:	f7ff ee5e 	blx	108d0 <malloc@plt>
   10c16:	4603      	mov	r3, r0
   10c18:	63bb      	str	r3, [r7, #56]	; 0x38
    memset(&tr, 0, sizeof(tr));
   10c1a:	f107 0310 	add.w	r3, r7, #16
   10c1e:	4618      	mov	r0, r3
   10c20:	2100      	movs	r1, #0
   10c22:	2220      	movs	r2, #32
   10c24:	f7ff ee1e 	blx	10864 <memset@plt>
    memset(wr, 0, 10);
   10c28:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   10c2a:	2100      	movs	r1, #0
   10c2c:	220a      	movs	r2, #10
   10c2e:	f7ff ee1a 	blx	10864 <memset@plt>
    memset(rd, 0, 10);
   10c32:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   10c34:	2100      	movs	r1, #0
   10c36:	220a      	movs	r2, #10
   10c38:	f7ff ee14 	blx	10864 <memset@plt>

    wr[0] = (addr);
   10c3c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10c3e:	2b00      	cmp	r3, #0
   10c40:	d106      	bne.n	10c50 <write_reg+0x5c>
   10c42:	f242 5084 	movw	r0, #9604	; 0x2584
   10c46:	f2c0 0002 	movt	r0, #2
   10c4a:	2100      	movs	r1, #0
   10c4c:	f7ff ee46 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10c50:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10c52:	7afa      	ldrb	r2, [r7, #11]
   10c54:	701a      	strb	r2, [r3, #0]
    wr[1] = value;
   10c56:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10c58:	1c5c      	adds	r4, r3, #1
   10c5a:	2c00      	cmp	r4, #0
   10c5c:	d106      	bne.n	10c6c <write_reg+0x78>
   10c5e:	f242 509c 	movw	r0, #9628	; 0x259c
   10c62:	f2c0 0002 	movt	r0, #2
   10c66:	2100      	movs	r1, #0
   10c68:	f7ff ee38 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10c6c:	7abb      	ldrb	r3, [r7, #10]
   10c6e:	7023      	strb	r3, [r4, #0]

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   10c70:	f642 5304 	movw	r3, #11524	; 0x2d04
   10c74:	f2c0 0302 	movt	r3, #2
   10c78:	681b      	ldr	r3, [r3, #0]
   10c7a:	f103 0428 	add.w	r4, r3, #40	; 0x28
   10c7e:	2c00      	cmp	r4, #0
   10c80:	d106      	bne.n	10c90 <write_reg+0x9c>
   10c82:	f242 50d0 	movw	r0, #9680	; 0x25d0
   10c86:	f2c0 0002 	movt	r0, #2
   10c8a:	2100      	movs	r1, #0
   10c8c:	f7ff ee26 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10c90:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   10c94:	6023      	str	r3, [r4, #0]
    while(GET_GPIO(GPIO_RDY))
   10c96:	e01b      	b.n	10cd0 <write_reg+0xdc>
    {
        int i = 0;
   10c98:	2300      	movs	r3, #0
   10c9a:	637b      	str	r3, [r7, #52]	; 0x34
        printf("Waiting for Chiprdy ....%d\n", i++);
   10c9c:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   10c9e:	1c65      	adds	r5, r4, #1
   10ca0:	2301      	movs	r3, #1
   10ca2:	2b00      	cmp	r3, #0
   10ca4:	db02      	blt.n	10cac <write_reg+0xb8>
   10ca6:	42a5      	cmp	r5, r4
   10ca8:	da0a      	bge.n	10cc0 <write_reg+0xcc>
   10caa:	e001      	b.n	10cb0 <write_reg+0xbc>
   10cac:	42a5      	cmp	r5, r4
   10cae:	dd07      	ble.n	10cc0 <write_reg+0xcc>
   10cb0:	f242 6054 	movw	r0, #9812	; 0x2654
   10cb4:	f2c0 0002 	movt	r0, #2
   10cb8:	4621      	mov	r1, r4
   10cba:	2201      	movs	r2, #1
   10cbc:	f7ff edf6 	blx	108ac <__ubsan_handle_add_overflow@plt>
   10cc0:	637d      	str	r5, [r7, #52]	; 0x34
   10cc2:	f242 2004 	movw	r0, #8708	; 0x2204
   10cc6:	f2c0 0001 	movt	r0, #1
   10cca:	4621      	mov	r1, r4
   10ccc:	f7ff edf4 	blx	108b8 <printf@plt>

    wr[0] = (addr);
    wr[1] = value;

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
    while(GET_GPIO(GPIO_RDY))
   10cd0:	f642 5304 	movw	r3, #11524	; 0x2d04
   10cd4:	f2c0 0302 	movt	r3, #2
   10cd8:	681b      	ldr	r3, [r3, #0]
   10cda:	f103 0434 	add.w	r4, r3, #52	; 0x34
   10cde:	2c00      	cmp	r4, #0
   10ce0:	d106      	bne.n	10cf0 <write_reg+0xfc>
   10ce2:	f242 50e8 	movw	r0, #9704	; 0x25e8
   10ce6:	f2c0 0002 	movt	r0, #2
   10cea:	2100      	movs	r1, #0
   10cec:	f7ff edf6 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10cf0:	6823      	ldr	r3, [r4, #0]
   10cf2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   10cf6:	2b00      	cmp	r3, #0
   10cf8:	d1ce      	bne.n	10c98 <write_reg+0xa4>
        printf("Waiting for Chiprdy ....%d\n", i++);
    }
#if 0
    printf("Writing %02x val %02x\n", addr, value);
#endif
    tr.tx_buf = (unsigned long) wr;
   10cfa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10cfc:	461a      	mov	r2, r3
   10cfe:	f04f 0300 	mov.w	r3, #0
   10d02:	e9c7 2304 	strd	r2, r3, [r7, #16]
    tr.rx_buf = (unsigned long) rd;
   10d06:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10d08:	461a      	mov	r2, r3
   10d0a:	f04f 0300 	mov.w	r3, #0
   10d0e:	e9c7 2306 	strd	r2, r3, [r7, #24]
    tr.len = N_RESP_BYTES;
   10d12:	2302      	movs	r3, #2
   10d14:	623b      	str	r3, [r7, #32]
    tr.delay_usecs = 90;
   10d16:	235a      	movs	r3, #90	; 0x5a
   10d18:	853b      	strh	r3, [r7, #40]	; 0x28
    tr.speed_hz = SPI_SPEED;
   10d1a:	f644 3340 	movw	r3, #19264	; 0x4b40
   10d1e:	f2c0 034c 	movt	r3, #76	; 0x4c
   10d22:	627b      	str	r3, [r7, #36]	; 0x24
    tr.bits_per_word = 8;
   10d24:	2308      	movs	r3, #8
   10d26:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    tr.cs_change = 0;
   10d2a:	2300      	movs	r3, #0
   10d2c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
   10d30:	f107 0310 	add.w	r3, r7, #16
   10d34:	68f8      	ldr	r0, [r7, #12]
   10d36:	f44f 41d6 	mov.w	r1, #27392	; 0x6b00
   10d3a:	f2c4 0120 	movt	r1, #16416	; 0x4020
   10d3e:	461a      	mov	r2, r3
   10d40:	f7ff edae 	blx	108a0 <ioctl@plt>
   10d44:	6338      	str	r0, [r7, #48]	; 0x30
    if (ret < 1)
   10d46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10d48:	2b00      	cmp	r3, #0
   10d4a:	dc05      	bgt.n	10d58 <write_reg+0x164>
        perror("can't send spi message");
   10d4c:	f242 2020 	movw	r0, #8736	; 0x2220
   10d50:	f2c0 0001 	movt	r0, #1
   10d54:	f7ff ed8c 	blx	10870 <perror@plt>
#if 0
    for (ret = 0; ret < tr.len; ret++) {
        printf("..%02X.. ", rd[ret]);
    }
#endif
    if (response)
   10d58:	687b      	ldr	r3, [r7, #4]
   10d5a:	2b00      	cmp	r3, #0
   10d5c:	d018      	beq.n	10d90 <write_reg+0x19c>
        response[0] = rd[1];
   10d5e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10d60:	2b00      	cmp	r3, #0
   10d62:	d106      	bne.n	10d72 <write_reg+0x17e>
   10d64:	f242 6000 	movw	r0, #9728	; 0x2600
   10d68:	f2c0 0002 	movt	r0, #2
   10d6c:	2100      	movs	r1, #0
   10d6e:	f7ff edb6 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10d72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10d74:	785c      	ldrb	r4, [r3, #1]
   10d76:	687b      	ldr	r3, [r7, #4]
   10d78:	2b00      	cmp	r3, #0
   10d7a:	d106      	bne.n	10d8a <write_reg+0x196>
   10d7c:	f242 6018 	movw	r0, #9752	; 0x2618
   10d80:	f2c0 0002 	movt	r0, #2
   10d84:	2100      	movs	r1, #0
   10d86:	f7ff edaa 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10d8a:	687b      	ldr	r3, [r7, #4]
   10d8c:	4622      	mov	r2, r4
   10d8e:	701a      	strb	r2, [r3, #0]
    GPIO_SET = 1 << (GPIO_CHIP_SEL);
   10d90:	f642 5304 	movw	r3, #11524	; 0x2d04
   10d94:	f2c0 0302 	movt	r3, #2
   10d98:	681b      	ldr	r3, [r3, #0]
   10d9a:	f103 041c 	add.w	r4, r3, #28
   10d9e:	2c00      	cmp	r4, #0
   10da0:	d106      	bne.n	10db0 <write_reg+0x1bc>
   10da2:	f242 6030 	movw	r0, #9776	; 0x2630
   10da6:	f2c0 0002 	movt	r0, #2
   10daa:	2100      	movs	r1, #0
   10dac:	f7ff ed96 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10db0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   10db4:	6023      	str	r3, [r4, #0]
    free(wr);
   10db6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   10db8:	f7ff ed66 	blx	10888 <free@plt>
    free(rd);
   10dbc:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   10dbe:	f7ff ed64 	blx	10888 <free@plt>
}
   10dc2:	3740      	adds	r7, #64	; 0x40
   10dc4:	46bd      	mov	sp, r7
   10dc6:	bdb0      	pop	{r4, r5, r7, pc}

00010dc8 <read_reg_burst>:

void read_reg_burst(int fd, uint8_t addr, uint8_t len, uint8_t *dest)
{
   10dc8:	b5b0      	push	{r4, r5, r7, lr}
   10dca:	b092      	sub	sp, #72	; 0x48
   10dcc:	af00      	add	r7, sp, #0
   10dce:	60f8      	str	r0, [r7, #12]
   10dd0:	607b      	str	r3, [r7, #4]
   10dd2:	460b      	mov	r3, r1
   10dd4:	72fb      	strb	r3, [r7, #11]
   10dd6:	4613      	mov	r3, r2
   10dd8:	72bb      	strb	r3, [r7, #10]
    int ret;
    uint32_t i;
    struct spi_ioc_transfer tr;
    #define N_RESP_BYTES (2) 
    uint8_t *wr, *rd;
    wr = malloc(len + 1);
   10dda:	7abb      	ldrb	r3, [r7, #10]
   10ddc:	1c5c      	adds	r4, r3, #1
   10dde:	2201      	movs	r2, #1
   10de0:	2a00      	cmp	r2, #0
   10de2:	db02      	blt.n	10dea <read_reg_burst+0x22>
   10de4:	429c      	cmp	r4, r3
   10de6:	da0a      	bge.n	10dfe <read_reg_burst+0x36>
   10de8:	e001      	b.n	10dee <read_reg_burst+0x26>
   10dea:	429c      	cmp	r4, r3
   10dec:	dd07      	ble.n	10dfe <read_reg_burst+0x36>
   10dee:	f242 60f4 	movw	r0, #9972	; 0x26f4
   10df2:	f2c0 0002 	movt	r0, #2
   10df6:	4619      	mov	r1, r3
   10df8:	2201      	movs	r2, #1
   10dfa:	f7ff ed58 	blx	108ac <__ubsan_handle_add_overflow@plt>
   10dfe:	4623      	mov	r3, r4
   10e00:	4618      	mov	r0, r3
   10e02:	f7ff ed66 	blx	108d0 <malloc@plt>
   10e06:	4603      	mov	r3, r0
   10e08:	63fb      	str	r3, [r7, #60]	; 0x3c
    rd = malloc(len + 1);
   10e0a:	7abb      	ldrb	r3, [r7, #10]
   10e0c:	1c5c      	adds	r4, r3, #1
   10e0e:	2201      	movs	r2, #1
   10e10:	2a00      	cmp	r2, #0
   10e12:	db02      	blt.n	10e1a <read_reg_burst+0x52>
   10e14:	429c      	cmp	r4, r3
   10e16:	da0a      	bge.n	10e2e <read_reg_burst+0x66>
   10e18:	e001      	b.n	10e1e <read_reg_burst+0x56>
   10e1a:	429c      	cmp	r4, r3
   10e1c:	dd07      	ble.n	10e2e <read_reg_burst+0x66>
   10e1e:	f242 7004 	movw	r0, #9988	; 0x2704
   10e22:	f2c0 0002 	movt	r0, #2
   10e26:	4619      	mov	r1, r3
   10e28:	2201      	movs	r2, #1
   10e2a:	f7ff ed40 	blx	108ac <__ubsan_handle_add_overflow@plt>
   10e2e:	4623      	mov	r3, r4
   10e30:	4618      	mov	r0, r3
   10e32:	f7ff ed4e 	blx	108d0 <malloc@plt>
   10e36:	4603      	mov	r3, r0
   10e38:	63bb      	str	r3, [r7, #56]	; 0x38
    memset(&tr, 0, sizeof(tr));
   10e3a:	f107 0310 	add.w	r3, r7, #16
   10e3e:	4618      	mov	r0, r3
   10e40:	2100      	movs	r1, #0
   10e42:	2220      	movs	r2, #32
   10e44:	f7ff ed0e 	blx	10864 <memset@plt>
    memset(wr, 0, 10);
   10e48:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   10e4a:	2100      	movs	r1, #0
   10e4c:	220a      	movs	r2, #10
   10e4e:	f7ff ed0a 	blx	10864 <memset@plt>
    memset(rd, 0, 10);
   10e52:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   10e54:	2100      	movs	r1, #0
   10e56:	220a      	movs	r2, #10
   10e58:	f7ff ed04 	blx	10864 <memset@plt>
    memset(wr, 0xde, sizeof(wr[0])*len);
   10e5c:	7abb      	ldrb	r3, [r7, #10]
   10e5e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   10e60:	21de      	movs	r1, #222	; 0xde
   10e62:	461a      	mov	r2, r3
   10e64:	f7ff ecfe 	blx	10864 <memset@plt>
    wr[0] = (addr) | BURST_CMD_BIT | READ_CMD_BIT;
   10e68:	7afb      	ldrb	r3, [r7, #11]
   10e6a:	f063 033f 	orn	r3, r3, #63	; 0x3f
   10e6e:	b2dc      	uxtb	r4, r3
   10e70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10e72:	2b00      	cmp	r3, #0
   10e74:	d106      	bne.n	10e84 <read_reg_burst+0xbc>
   10e76:	f242 6064 	movw	r0, #9828	; 0x2664
   10e7a:	f2c0 0002 	movt	r0, #2
   10e7e:	2100      	movs	r1, #0
   10e80:	f7ff ed2c 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10e84:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10e86:	4622      	mov	r2, r4
   10e88:	701a      	strb	r2, [r3, #0]

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   10e8a:	f642 5304 	movw	r3, #11524	; 0x2d04
   10e8e:	f2c0 0302 	movt	r3, #2
   10e92:	681b      	ldr	r3, [r3, #0]
   10e94:	f103 0428 	add.w	r4, r3, #40	; 0x28
   10e98:	2c00      	cmp	r4, #0
   10e9a:	d106      	bne.n	10eaa <read_reg_burst+0xe2>
   10e9c:	f242 607c 	movw	r0, #9852	; 0x267c
   10ea0:	f2c0 0002 	movt	r0, #2
   10ea4:	2100      	movs	r1, #0
   10ea6:	f7ff ed1a 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10eaa:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   10eae:	6023      	str	r3, [r4, #0]

    while(GET_GPIO(GPIO_RDY))
   10eb0:	e009      	b.n	10ec6 <read_reg_burst+0xfe>
    {
        printf("Waiting for Chiprdy ....%d\n", i++);
   10eb2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   10eb4:	1c5a      	adds	r2, r3, #1
   10eb6:	647a      	str	r2, [r7, #68]	; 0x44
   10eb8:	f242 2004 	movw	r0, #8708	; 0x2204
   10ebc:	f2c0 0001 	movt	r0, #1
   10ec0:	4619      	mov	r1, r3
   10ec2:	f7ff ecfa 	blx	108b8 <printf@plt>
    memset(wr, 0xde, sizeof(wr[0])*len);
    wr[0] = (addr) | BURST_CMD_BIT | READ_CMD_BIT;

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);

    while(GET_GPIO(GPIO_RDY))
   10ec6:	f642 5304 	movw	r3, #11524	; 0x2d04
   10eca:	f2c0 0302 	movt	r3, #2
   10ece:	681b      	ldr	r3, [r3, #0]
   10ed0:	f103 0434 	add.w	r4, r3, #52	; 0x34
   10ed4:	2c00      	cmp	r4, #0
   10ed6:	d106      	bne.n	10ee6 <read_reg_burst+0x11e>
   10ed8:	f242 6094 	movw	r0, #9876	; 0x2694
   10edc:	f2c0 0002 	movt	r0, #2
   10ee0:	2100      	movs	r1, #0
   10ee2:	f7ff ecfc 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10ee6:	6823      	ldr	r3, [r4, #0]
   10ee8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   10eec:	2b00      	cmp	r3, #0
   10eee:	d1e0      	bne.n	10eb2 <read_reg_burst+0xea>
        printf("Waiting for Chiprdy ....%d\n", i++);
    }
#if 0
    printf("Burst Reading %02x\n", addr);
#endif
    tr.tx_buf = (unsigned long) wr;
   10ef0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10ef2:	461a      	mov	r2, r3
   10ef4:	f04f 0300 	mov.w	r3, #0
   10ef8:	e9c7 2304 	strd	r2, r3, [r7, #16]
    tr.rx_buf = (unsigned long) rd;
   10efc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10efe:	461a      	mov	r2, r3
   10f00:	f04f 0300 	mov.w	r3, #0
   10f04:	e9c7 2306 	strd	r2, r3, [r7, #24]
    tr.len = len + 1;
   10f08:	7abb      	ldrb	r3, [r7, #10]
   10f0a:	1c5c      	adds	r4, r3, #1
   10f0c:	2201      	movs	r2, #1
   10f0e:	2a00      	cmp	r2, #0
   10f10:	db02      	blt.n	10f18 <read_reg_burst+0x150>
   10f12:	429c      	cmp	r4, r3
   10f14:	da0a      	bge.n	10f2c <read_reg_burst+0x164>
   10f16:	e001      	b.n	10f1c <read_reg_burst+0x154>
   10f18:	429c      	cmp	r4, r3
   10f1a:	dd07      	ble.n	10f2c <read_reg_burst+0x164>
   10f1c:	f242 7014 	movw	r0, #10004	; 0x2714
   10f20:	f2c0 0002 	movt	r0, #2
   10f24:	4619      	mov	r1, r3
   10f26:	2201      	movs	r2, #1
   10f28:	f7ff ecc0 	blx	108ac <__ubsan_handle_add_overflow@plt>
   10f2c:	4623      	mov	r3, r4
   10f2e:	623b      	str	r3, [r7, #32]
    tr.delay_usecs = 90;
   10f30:	235a      	movs	r3, #90	; 0x5a
   10f32:	853b      	strh	r3, [r7, #40]	; 0x28
    tr.speed_hz = SPI_SPEED;
   10f34:	f644 3340 	movw	r3, #19264	; 0x4b40
   10f38:	f2c0 034c 	movt	r3, #76	; 0x4c
   10f3c:	627b      	str	r3, [r7, #36]	; 0x24
    tr.bits_per_word = 8;
   10f3e:	2308      	movs	r3, #8
   10f40:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    tr.cs_change = 0;
   10f44:	2300      	movs	r3, #0
   10f46:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
   10f4a:	f107 0310 	add.w	r3, r7, #16
   10f4e:	68f8      	ldr	r0, [r7, #12]
   10f50:	f44f 41d6 	mov.w	r1, #27392	; 0x6b00
   10f54:	f2c4 0120 	movt	r1, #16416	; 0x4020
   10f58:	461a      	mov	r2, r3
   10f5a:	f7ff eca2 	blx	108a0 <ioctl@plt>
   10f5e:	6378      	str	r0, [r7, #52]	; 0x34
    if (ret < 1)
   10f60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   10f62:	2b00      	cmp	r3, #0
   10f64:	dc05      	bgt.n	10f72 <read_reg_burst+0x1aa>
        perror("can't send spi message");
   10f66:	f242 2020 	movw	r0, #8736	; 0x2220
   10f6a:	f2c0 0001 	movt	r0, #1
   10f6e:	f7ff ec80 	blx	10870 <perror@plt>
#if 0
    for (i = 0; i < tr.len; i++) {
        printf("..%02X.. ", rd[ret]);
    }
#endif
    if (dest)
   10f72:	687b      	ldr	r3, [r7, #4]
   10f74:	2b00      	cmp	r3, #0
   10f76:	d037      	beq.n	10fe8 <read_reg_burst+0x220>
    {
        int i;
        for (i = 0; i < len; i++)
   10f78:	2300      	movs	r3, #0
   10f7a:	643b      	str	r3, [r7, #64]	; 0x40
   10f7c:	e030      	b.n	10fe0 <read_reg_burst+0x218>
            dest[i] = rd[i + 1];
   10f7e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10f80:	687a      	ldr	r2, [r7, #4]
   10f82:	18d4      	adds	r4, r2, r3
   10f84:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10f86:	3301      	adds	r3, #1
   10f88:	6bba      	ldr	r2, [r7, #56]	; 0x38
   10f8a:	18d5      	adds	r5, r2, r3
   10f8c:	2d00      	cmp	r5, #0
   10f8e:	d106      	bne.n	10f9e <read_reg_burst+0x1d6>
   10f90:	f242 60ac 	movw	r0, #9900	; 0x26ac
   10f94:	f2c0 0002 	movt	r0, #2
   10f98:	2100      	movs	r1, #0
   10f9a:	f7ff eca0 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10f9e:	782d      	ldrb	r5, [r5, #0]
   10fa0:	2c00      	cmp	r4, #0
   10fa2:	d106      	bne.n	10fb2 <read_reg_burst+0x1ea>
   10fa4:	f242 60c4 	movw	r0, #9924	; 0x26c4
   10fa8:	f2c0 0002 	movt	r0, #2
   10fac:	2100      	movs	r1, #0
   10fae:	f7ff ec96 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   10fb2:	462b      	mov	r3, r5
   10fb4:	7023      	strb	r3, [r4, #0]
    }
#endif
    if (dest)
    {
        int i;
        for (i = 0; i < len; i++)
   10fb6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10fb8:	1c5c      	adds	r4, r3, #1
   10fba:	2301      	movs	r3, #1
   10fbc:	2b00      	cmp	r3, #0
   10fbe:	db03      	blt.n	10fc8 <read_reg_burst+0x200>
   10fc0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10fc2:	429c      	cmp	r4, r3
   10fc4:	da0b      	bge.n	10fde <read_reg_burst+0x216>
   10fc6:	e002      	b.n	10fce <read_reg_burst+0x206>
   10fc8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10fca:	429c      	cmp	r4, r3
   10fcc:	dd07      	ble.n	10fde <read_reg_burst+0x216>
   10fce:	f242 7024 	movw	r0, #10020	; 0x2724
   10fd2:	f2c0 0002 	movt	r0, #2
   10fd6:	6c39      	ldr	r1, [r7, #64]	; 0x40
   10fd8:	2201      	movs	r2, #1
   10fda:	f7ff ec68 	blx	108ac <__ubsan_handle_add_overflow@plt>
   10fde:	643c      	str	r4, [r7, #64]	; 0x40
   10fe0:	7aba      	ldrb	r2, [r7, #10]
   10fe2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   10fe4:	429a      	cmp	r2, r3
   10fe6:	dcca      	bgt.n	10f7e <read_reg_burst+0x1b6>
            dest[i] = rd[i + 1];
    }
    GPIO_SET = 1 << (GPIO_CHIP_SEL);
   10fe8:	f642 5304 	movw	r3, #11524	; 0x2d04
   10fec:	f2c0 0302 	movt	r3, #2
   10ff0:	681b      	ldr	r3, [r3, #0]
   10ff2:	f103 041c 	add.w	r4, r3, #28
   10ff6:	2c00      	cmp	r4, #0
   10ff8:	d106      	bne.n	11008 <read_reg_burst+0x240>
   10ffa:	f242 60dc 	movw	r0, #9948	; 0x26dc
   10ffe:	f2c0 0002 	movt	r0, #2
   11002:	2100      	movs	r1, #0
   11004:	f7ff ec6a 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11008:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   1100c:	6023      	str	r3, [r4, #0]
    free(wr);
   1100e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   11010:	f7ff ec3a 	blx	10888 <free@plt>
    free(rd);
   11014:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   11016:	f7ff ec38 	blx	10888 <free@plt>
    return;
   1101a:	bf00      	nop
}
   1101c:	3748      	adds	r7, #72	; 0x48
   1101e:	46bd      	mov	sp, r7
   11020:	bdb0      	pop	{r4, r5, r7, pc}
   11022:	bf00      	nop

00011024 <write_reg_burst>:

uint8_t write_reg_burst(int fd, uint8_t addr, uint8_t *value, uint8_t len)
{
   11024:	b5b0      	push	{r4, r5, r7, lr}
   11026:	b092      	sub	sp, #72	; 0x48
   11028:	af00      	add	r7, sp, #0
   1102a:	60f8      	str	r0, [r7, #12]
   1102c:	607a      	str	r2, [r7, #4]
   1102e:	461a      	mov	r2, r3
   11030:	460b      	mov	r3, r1
   11032:	72fb      	strb	r3, [r7, #11]
   11034:	4613      	mov	r3, r2
   11036:	72bb      	strb	r3, [r7, #10]
    int ret;
    uint8_t *ptr;
    struct spi_ioc_transfer tr;
    #define N_RESP_BYTES (2) 
    uint8_t *wr, *rd;
    wr = malloc(len + 1);
   11038:	7abb      	ldrb	r3, [r7, #10]
   1103a:	1c5c      	adds	r4, r3, #1
   1103c:	2201      	movs	r2, #1
   1103e:	2a00      	cmp	r2, #0
   11040:	db02      	blt.n	11048 <write_reg_burst+0x24>
   11042:	429c      	cmp	r4, r3
   11044:	da0a      	bge.n	1105c <write_reg_burst+0x38>
   11046:	e001      	b.n	1104c <write_reg_burst+0x28>
   11048:	429c      	cmp	r4, r3
   1104a:	dd07      	ble.n	1105c <write_reg_burst+0x38>
   1104c:	f242 70dc 	movw	r0, #10204	; 0x27dc
   11050:	f2c0 0002 	movt	r0, #2
   11054:	4619      	mov	r1, r3
   11056:	2201      	movs	r2, #1
   11058:	f7ff ec28 	blx	108ac <__ubsan_handle_add_overflow@plt>
   1105c:	4623      	mov	r3, r4
   1105e:	4618      	mov	r0, r3
   11060:	f7ff ec36 	blx	108d0 <malloc@plt>
   11064:	4603      	mov	r3, r0
   11066:	63fb      	str	r3, [r7, #60]	; 0x3c
    rd = malloc(len + 1);
   11068:	7abb      	ldrb	r3, [r7, #10]
   1106a:	1c5c      	adds	r4, r3, #1
   1106c:	2201      	movs	r2, #1
   1106e:	2a00      	cmp	r2, #0
   11070:	db02      	blt.n	11078 <write_reg_burst+0x54>
   11072:	429c      	cmp	r4, r3
   11074:	da0a      	bge.n	1108c <write_reg_burst+0x68>
   11076:	e001      	b.n	1107c <write_reg_burst+0x58>
   11078:	429c      	cmp	r4, r3
   1107a:	dd07      	ble.n	1108c <write_reg_burst+0x68>
   1107c:	f242 70ec 	movw	r0, #10220	; 0x27ec
   11080:	f2c0 0002 	movt	r0, #2
   11084:	4619      	mov	r1, r3
   11086:	2201      	movs	r2, #1
   11088:	f7ff ec10 	blx	108ac <__ubsan_handle_add_overflow@plt>
   1108c:	4623      	mov	r3, r4
   1108e:	4618      	mov	r0, r3
   11090:	f7ff ec1e 	blx	108d0 <malloc@plt>
   11094:	4603      	mov	r3, r0
   11096:	63bb      	str	r3, [r7, #56]	; 0x38
    memset(&tr, 0, sizeof(tr));
   11098:	f107 0310 	add.w	r3, r7, #16
   1109c:	4618      	mov	r0, r3
   1109e:	2100      	movs	r1, #0
   110a0:	2220      	movs	r2, #32
   110a2:	f7ff ebe0 	blx	10864 <memset@plt>
    memset(wr, 0, 10);
   110a6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   110a8:	2100      	movs	r1, #0
   110aa:	220a      	movs	r2, #10
   110ac:	f7ff ebda 	blx	10864 <memset@plt>
    memset(rd, 0, 10);
   110b0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   110b2:	2100      	movs	r1, #0
   110b4:	220a      	movs	r2, #10
   110b6:	f7ff ebd6 	blx	10864 <memset@plt>

    wr[0] = (addr) | BURST_CMD_BIT;
   110ba:	7afb      	ldrb	r3, [r7, #11]
   110bc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   110c0:	b2dc      	uxtb	r4, r3
   110c2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   110c4:	2b00      	cmp	r3, #0
   110c6:	d106      	bne.n	110d6 <write_reg_burst+0xb2>
   110c8:	f242 7034 	movw	r0, #10036	; 0x2734
   110cc:	f2c0 0002 	movt	r0, #2
   110d0:	2100      	movs	r1, #0
   110d2:	f7ff ec04 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   110d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   110d8:	4622      	mov	r2, r4
   110da:	701a      	strb	r2, [r3, #0]
    ptr = &wr[1];
   110dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   110de:	3301      	adds	r3, #1
   110e0:	647b      	str	r3, [r7, #68]	; 0x44
    for (int i = 0; i < len; i++)
   110e2:	2300      	movs	r3, #0
   110e4:	643b      	str	r3, [r7, #64]	; 0x40
   110e6:	e02f      	b.n	11148 <write_reg_burst+0x124>
        *ptr++ = *value++;
   110e8:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   110ea:	1c63      	adds	r3, r4, #1
   110ec:	647b      	str	r3, [r7, #68]	; 0x44
   110ee:	687d      	ldr	r5, [r7, #4]
   110f0:	1c6b      	adds	r3, r5, #1
   110f2:	607b      	str	r3, [r7, #4]
   110f4:	2d00      	cmp	r5, #0
   110f6:	d106      	bne.n	11106 <write_reg_burst+0xe2>
   110f8:	f242 704c 	movw	r0, #10060	; 0x274c
   110fc:	f2c0 0002 	movt	r0, #2
   11100:	2100      	movs	r1, #0
   11102:	f7ff ebec 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11106:	782d      	ldrb	r5, [r5, #0]
   11108:	2c00      	cmp	r4, #0
   1110a:	d106      	bne.n	1111a <write_reg_burst+0xf6>
   1110c:	f242 7064 	movw	r0, #10084	; 0x2764
   11110:	f2c0 0002 	movt	r0, #2
   11114:	2100      	movs	r1, #0
   11116:	f7ff ebe2 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1111a:	462b      	mov	r3, r5
   1111c:	7023      	strb	r3, [r4, #0]
    memset(wr, 0, 10);
    memset(rd, 0, 10);

    wr[0] = (addr) | BURST_CMD_BIT;
    ptr = &wr[1];
    for (int i = 0; i < len; i++)
   1111e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   11120:	1c5c      	adds	r4, r3, #1
   11122:	2301      	movs	r3, #1
   11124:	2b00      	cmp	r3, #0
   11126:	db03      	blt.n	11130 <write_reg_burst+0x10c>
   11128:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1112a:	429c      	cmp	r4, r3
   1112c:	da0b      	bge.n	11146 <write_reg_burst+0x122>
   1112e:	e002      	b.n	11136 <write_reg_burst+0x112>
   11130:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   11132:	429c      	cmp	r4, r3
   11134:	dd07      	ble.n	11146 <write_reg_burst+0x122>
   11136:	f242 70fc 	movw	r0, #10236	; 0x27fc
   1113a:	f2c0 0002 	movt	r0, #2
   1113e:	6c39      	ldr	r1, [r7, #64]	; 0x40
   11140:	2201      	movs	r2, #1
   11142:	f7ff ebb4 	blx	108ac <__ubsan_handle_add_overflow@plt>
   11146:	643c      	str	r4, [r7, #64]	; 0x40
   11148:	7aba      	ldrb	r2, [r7, #10]
   1114a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1114c:	429a      	cmp	r2, r3
   1114e:	dccb      	bgt.n	110e8 <write_reg_burst+0xc4>
        *ptr++ = *value++;
    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   11150:	f642 5304 	movw	r3, #11524	; 0x2d04
   11154:	f2c0 0302 	movt	r3, #2
   11158:	681b      	ldr	r3, [r3, #0]
   1115a:	f103 0428 	add.w	r4, r3, #40	; 0x28
   1115e:	2c00      	cmp	r4, #0
   11160:	d106      	bne.n	11170 <write_reg_burst+0x14c>
   11162:	f242 707c 	movw	r0, #10108	; 0x277c
   11166:	f2c0 0002 	movt	r0, #2
   1116a:	2100      	movs	r1, #0
   1116c:	f7ff ebb6 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11170:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11174:	6023      	str	r3, [r4, #0]
    while(GET_GPIO(GPIO_RDY))
   11176:	e01b      	b.n	111b0 <write_reg_burst+0x18c>
    {
        int i = 0;
   11178:	2300      	movs	r3, #0
   1117a:	637b      	str	r3, [r7, #52]	; 0x34
        printf("Waiting for Chiprdy ....%d\n", i++);
   1117c:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   1117e:	1c65      	adds	r5, r4, #1
   11180:	2301      	movs	r3, #1
   11182:	2b00      	cmp	r3, #0
   11184:	db02      	blt.n	1118c <write_reg_burst+0x168>
   11186:	42a5      	cmp	r5, r4
   11188:	da0a      	bge.n	111a0 <write_reg_burst+0x17c>
   1118a:	e001      	b.n	11190 <write_reg_burst+0x16c>
   1118c:	42a5      	cmp	r5, r4
   1118e:	dd07      	ble.n	111a0 <write_reg_burst+0x17c>
   11190:	f642 000c 	movw	r0, #10252	; 0x280c
   11194:	f2c0 0002 	movt	r0, #2
   11198:	4621      	mov	r1, r4
   1119a:	2201      	movs	r2, #1
   1119c:	f7ff eb86 	blx	108ac <__ubsan_handle_add_overflow@plt>
   111a0:	637d      	str	r5, [r7, #52]	; 0x34
   111a2:	f242 2004 	movw	r0, #8708	; 0x2204
   111a6:	f2c0 0001 	movt	r0, #1
   111aa:	4621      	mov	r1, r4
   111ac:	f7ff eb84 	blx	108b8 <printf@plt>
    wr[0] = (addr) | BURST_CMD_BIT;
    ptr = &wr[1];
    for (int i = 0; i < len; i++)
        *ptr++ = *value++;
    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
    while(GET_GPIO(GPIO_RDY))
   111b0:	f642 5304 	movw	r3, #11524	; 0x2d04
   111b4:	f2c0 0302 	movt	r3, #2
   111b8:	681b      	ldr	r3, [r3, #0]
   111ba:	f103 0434 	add.w	r4, r3, #52	; 0x34
   111be:	2c00      	cmp	r4, #0
   111c0:	d106      	bne.n	111d0 <write_reg_burst+0x1ac>
   111c2:	f242 7094 	movw	r0, #10132	; 0x2794
   111c6:	f2c0 0002 	movt	r0, #2
   111ca:	2100      	movs	r1, #0
   111cc:	f7ff eb86 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   111d0:	6823      	ldr	r3, [r4, #0]
   111d2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   111d6:	2b00      	cmp	r3, #0
   111d8:	d1ce      	bne.n	11178 <write_reg_burst+0x154>
    {
        int i = 0;
        printf("Waiting for Chiprdy ....%d\n", i++);
    }
    printf("Writing %02x \n", addr);
   111da:	7afb      	ldrb	r3, [r7, #11]
   111dc:	f242 2038 	movw	r0, #8760	; 0x2238
   111e0:	f2c0 0001 	movt	r0, #1
   111e4:	4619      	mov	r1, r3
   111e6:	f7ff eb68 	blx	108b8 <printf@plt>
    tr.tx_buf = (unsigned long) wr;
   111ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   111ec:	461a      	mov	r2, r3
   111ee:	f04f 0300 	mov.w	r3, #0
   111f2:	e9c7 2304 	strd	r2, r3, [r7, #16]
    tr.rx_buf = (unsigned long) rd;
   111f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   111f8:	461a      	mov	r2, r3
   111fa:	f04f 0300 	mov.w	r3, #0
   111fe:	e9c7 2306 	strd	r2, r3, [r7, #24]
    tr.len = len + 1;
   11202:	7abb      	ldrb	r3, [r7, #10]
   11204:	1c5c      	adds	r4, r3, #1
   11206:	2201      	movs	r2, #1
   11208:	2a00      	cmp	r2, #0
   1120a:	db02      	blt.n	11212 <write_reg_burst+0x1ee>
   1120c:	429c      	cmp	r4, r3
   1120e:	da0a      	bge.n	11226 <write_reg_burst+0x202>
   11210:	e001      	b.n	11216 <write_reg_burst+0x1f2>
   11212:	429c      	cmp	r4, r3
   11214:	dd07      	ble.n	11226 <write_reg_burst+0x202>
   11216:	f642 001c 	movw	r0, #10268	; 0x281c
   1121a:	f2c0 0002 	movt	r0, #2
   1121e:	4619      	mov	r1, r3
   11220:	2201      	movs	r2, #1
   11222:	f7ff eb44 	blx	108ac <__ubsan_handle_add_overflow@plt>
   11226:	4623      	mov	r3, r4
   11228:	623b      	str	r3, [r7, #32]
    tr.delay_usecs = 90;
   1122a:	235a      	movs	r3, #90	; 0x5a
   1122c:	853b      	strh	r3, [r7, #40]	; 0x28
    tr.speed_hz = SPI_SPEED;
   1122e:	f644 3340 	movw	r3, #19264	; 0x4b40
   11232:	f2c0 034c 	movt	r3, #76	; 0x4c
   11236:	627b      	str	r3, [r7, #36]	; 0x24
    tr.bits_per_word = 8;
   11238:	2308      	movs	r3, #8
   1123a:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    tr.cs_change = 0;
   1123e:	2300      	movs	r3, #0
   11240:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
   11244:	f107 0310 	add.w	r3, r7, #16
   11248:	68f8      	ldr	r0, [r7, #12]
   1124a:	f44f 41d6 	mov.w	r1, #27392	; 0x6b00
   1124e:	f2c4 0120 	movt	r1, #16416	; 0x4020
   11252:	461a      	mov	r2, r3
   11254:	f7ff eb24 	blx	108a0 <ioctl@plt>
   11258:	6338      	str	r0, [r7, #48]	; 0x30
    if (ret < 1)
   1125a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1125c:	2b00      	cmp	r3, #0
   1125e:	dc05      	bgt.n	1126c <write_reg_burst+0x248>
        perror("can't send spi message");
   11260:	f242 2020 	movw	r0, #8736	; 0x2220
   11264:	f2c0 0001 	movt	r0, #1
   11268:	f7ff eb02 	blx	10870 <perror@plt>
#if 0
    for (ret = 0; ret < tr.len; ret++) {
        printf("..%02X.. ", rd[ret]);
    }
#endif
    GPIO_SET = 1 << (GPIO_CHIP_SEL);
   1126c:	f642 5304 	movw	r3, #11524	; 0x2d04
   11270:	f2c0 0302 	movt	r3, #2
   11274:	681b      	ldr	r3, [r3, #0]
   11276:	f103 041c 	add.w	r4, r3, #28
   1127a:	2c00      	cmp	r4, #0
   1127c:	d106      	bne.n	1128c <write_reg_burst+0x268>
   1127e:	f242 70ac 	movw	r0, #10156	; 0x27ac
   11282:	f2c0 0002 	movt	r0, #2
   11286:	2100      	movs	r1, #0
   11288:	f7ff eb28 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1128c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11290:	6023      	str	r3, [r4, #0]
    free(wr);
   11292:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   11294:	f7ff eaf8 	blx	10888 <free@plt>
    free(rd);
   11298:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   1129a:	f7ff eaf6 	blx	10888 <free@plt>
    return rd[1];
   1129e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   112a0:	2b00      	cmp	r3, #0
   112a2:	d106      	bne.n	112b2 <write_reg_burst+0x28e>
   112a4:	f242 70c4 	movw	r0, #10180	; 0x27c4
   112a8:	f2c0 0002 	movt	r0, #2
   112ac:	2100      	movs	r1, #0
   112ae:	f7ff eb16 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   112b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   112b4:	785b      	ldrb	r3, [r3, #1]
}
   112b6:	4618      	mov	r0, r3
   112b8:	3748      	adds	r7, #72	; 0x48
   112ba:	46bd      	mov	sp, r7
   112bc:	bdb0      	pop	{r4, r5, r7, pc}
   112be:	bf00      	nop

000112c0 <read_reg>:

uint8_t read_reg(int fd, uint8_t addr, uint8_t *status)
{
   112c0:	b5b0      	push	{r4, r5, r7, lr}
   112c2:	b090      	sub	sp, #64	; 0x40
   112c4:	af00      	add	r7, sp, #0
   112c6:	60f8      	str	r0, [r7, #12]
   112c8:	460b      	mov	r3, r1
   112ca:	607a      	str	r2, [r7, #4]
   112cc:	72fb      	strb	r3, [r7, #11]
    int ret;
    struct spi_ioc_transfer tr;
    #define N_RESP_BYTES (2) 
    uint8_t *wr, *rd;
    wr = calloc(N_RESP_BYTES , sizeof(uint8_t));
   112ce:	2002      	movs	r0, #2
   112d0:	2101      	movs	r1, #1
   112d2:	f7ff eac2 	blx	10858 <calloc@plt>
   112d6:	4603      	mov	r3, r0
   112d8:	63fb      	str	r3, [r7, #60]	; 0x3c
    rd = calloc(N_RESP_BYTES , sizeof(uint8_t));
   112da:	2002      	movs	r0, #2
   112dc:	2101      	movs	r1, #1
   112de:	f7ff eabc 	blx	10858 <calloc@plt>
   112e2:	4603      	mov	r3, r0
   112e4:	63bb      	str	r3, [r7, #56]	; 0x38
    memset(&tr, 0, sizeof(tr));
   112e6:	f107 0310 	add.w	r3, r7, #16
   112ea:	4618      	mov	r0, r3
   112ec:	2100      	movs	r1, #0
   112ee:	2220      	movs	r2, #32
   112f0:	f7ff eab8 	blx	10864 <memset@plt>

    wr[0] = (addr & 0x3f) | READ_CMD_BIT;
   112f4:	7afb      	ldrb	r3, [r7, #11]
   112f6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   112fa:	b2db      	uxtb	r3, r3
   112fc:	f063 037f 	orn	r3, r3, #127	; 0x7f
   11300:	b2db      	uxtb	r3, r3
   11302:	b2dc      	uxtb	r4, r3
   11304:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11306:	2b00      	cmp	r3, #0
   11308:	d106      	bne.n	11318 <read_reg+0x58>
   1130a:	f642 002c 	movw	r0, #10284	; 0x282c
   1130e:	f2c0 0002 	movt	r0, #2
   11312:	2100      	movs	r1, #0
   11314:	f7ff eae2 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11318:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1131a:	4622      	mov	r2, r4
   1131c:	701a      	strb	r2, [r3, #0]
    wr[1] = 0x3e;
   1131e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11320:	1c5c      	adds	r4, r3, #1
   11322:	2c00      	cmp	r4, #0
   11324:	d106      	bne.n	11334 <read_reg+0x74>
   11326:	f642 0044 	movw	r0, #10308	; 0x2844
   1132a:	f2c0 0002 	movt	r0, #2
   1132e:	2100      	movs	r1, #0
   11330:	f7ff ead4 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11334:	233e      	movs	r3, #62	; 0x3e
   11336:	7023      	strb	r3, [r4, #0]
    if (addr >= 0x30)
   11338:	7afb      	ldrb	r3, [r7, #11]
   1133a:	2b2f      	cmp	r3, #47	; 0x2f
   1133c:	d91b      	bls.n	11376 <read_reg+0xb6>
    {
        wr[0] |= BURST_CMD_BIT;
   1133e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11340:	2b00      	cmp	r3, #0
   11342:	d106      	bne.n	11352 <read_reg+0x92>
   11344:	f642 005c 	movw	r0, #10332	; 0x285c
   11348:	f2c0 0002 	movt	r0, #2
   1134c:	2100      	movs	r1, #0
   1134e:	f7ff eac6 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11352:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11354:	781b      	ldrb	r3, [r3, #0]
   11356:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1135a:	b2dc      	uxtb	r4, r3
   1135c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1135e:	2b00      	cmp	r3, #0
   11360:	d106      	bne.n	11370 <read_reg+0xb0>
   11362:	f642 0074 	movw	r0, #10356	; 0x2874
   11366:	f2c0 0002 	movt	r0, #2
   1136a:	2100      	movs	r1, #0
   1136c:	f7ff eab6 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11370:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11372:	4622      	mov	r2, r4
   11374:	701a      	strb	r2, [r3, #0]
    }

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   11376:	f642 5304 	movw	r3, #11524	; 0x2d04
   1137a:	f2c0 0302 	movt	r3, #2
   1137e:	681b      	ldr	r3, [r3, #0]
   11380:	f103 0428 	add.w	r4, r3, #40	; 0x28
   11384:	2c00      	cmp	r4, #0
   11386:	d106      	bne.n	11396 <read_reg+0xd6>
   11388:	f642 008c 	movw	r0, #10380	; 0x288c
   1138c:	f2c0 0002 	movt	r0, #2
   11390:	2100      	movs	r1, #0
   11392:	f7ff eaa4 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11396:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   1139a:	6023      	str	r3, [r4, #0]
    while(GET_GPIO(GPIO_RDY))
   1139c:	e01b      	b.n	113d6 <read_reg+0x116>
    {
        int i = 0;
   1139e:	2300      	movs	r3, #0
   113a0:	637b      	str	r3, [r7, #52]	; 0x34
        printf("Waiting for Chiprdy ....%d\n", i++);
   113a2:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   113a4:	1c65      	adds	r5, r4, #1
   113a6:	2301      	movs	r3, #1
   113a8:	2b00      	cmp	r3, #0
   113aa:	db02      	blt.n	113b2 <read_reg+0xf2>
   113ac:	42a5      	cmp	r5, r4
   113ae:	da0a      	bge.n	113c6 <read_reg+0x106>
   113b0:	e001      	b.n	113b6 <read_reg+0xf6>
   113b2:	42a5      	cmp	r5, r4
   113b4:	dd07      	ble.n	113c6 <read_reg+0x106>
   113b6:	f642 101c 	movw	r0, #10524	; 0x291c
   113ba:	f2c0 0002 	movt	r0, #2
   113be:	4621      	mov	r1, r4
   113c0:	2201      	movs	r2, #1
   113c2:	f7ff ea74 	blx	108ac <__ubsan_handle_add_overflow@plt>
   113c6:	637d      	str	r5, [r7, #52]	; 0x34
   113c8:	f242 2004 	movw	r0, #8708	; 0x2204
   113cc:	f2c0 0001 	movt	r0, #1
   113d0:	4621      	mov	r1, r4
   113d2:	f7ff ea72 	blx	108b8 <printf@plt>
    {
        wr[0] |= BURST_CMD_BIT;
    }

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
    while(GET_GPIO(GPIO_RDY))
   113d6:	f642 5304 	movw	r3, #11524	; 0x2d04
   113da:	f2c0 0302 	movt	r3, #2
   113de:	681b      	ldr	r3, [r3, #0]
   113e0:	f103 0434 	add.w	r4, r3, #52	; 0x34
   113e4:	2c00      	cmp	r4, #0
   113e6:	d106      	bne.n	113f6 <read_reg+0x136>
   113e8:	f642 00a4 	movw	r0, #10404	; 0x28a4
   113ec:	f2c0 0002 	movt	r0, #2
   113f0:	2100      	movs	r1, #0
   113f2:	f7ff ea74 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   113f6:	6823      	ldr	r3, [r4, #0]
   113f8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   113fc:	2b00      	cmp	r3, #0
   113fe:	d1ce      	bne.n	1139e <read_reg+0xde>
    {
        int i = 0;
        printf("Waiting for Chiprdy ....%d\n", i++);
    }

    tr.tx_buf = (unsigned long)wr;
   11400:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11402:	461a      	mov	r2, r3
   11404:	f04f 0300 	mov.w	r3, #0
   11408:	e9c7 2304 	strd	r2, r3, [r7, #16]
    tr.rx_buf = (unsigned long)rd;
   1140c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1140e:	461a      	mov	r2, r3
   11410:	f04f 0300 	mov.w	r3, #0
   11414:	e9c7 2306 	strd	r2, r3, [r7, #24]
    tr.len = N_RESP_BYTES;
   11418:	2302      	movs	r3, #2
   1141a:	623b      	str	r3, [r7, #32]
    tr.delay_usecs = 90;
   1141c:	235a      	movs	r3, #90	; 0x5a
   1141e:	853b      	strh	r3, [r7, #40]	; 0x28
    tr.speed_hz = SPI_SPEED;
   11420:	f644 3340 	movw	r3, #19264	; 0x4b40
   11424:	f2c0 034c 	movt	r3, #76	; 0x4c
   11428:	627b      	str	r3, [r7, #36]	; 0x24
    tr.bits_per_word = 8;
   1142a:	2308      	movs	r3, #8
   1142c:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    tr.cs_change = 0;
   11430:	2300      	movs	r3, #0
   11432:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
   11436:	f107 0310 	add.w	r3, r7, #16
   1143a:	68f8      	ldr	r0, [r7, #12]
   1143c:	f44f 41d6 	mov.w	r1, #27392	; 0x6b00
   11440:	f2c4 0120 	movt	r1, #16416	; 0x4020
   11444:	461a      	mov	r2, r3
   11446:	f7ff ea2c 	blx	108a0 <ioctl@plt>
   1144a:	6338      	str	r0, [r7, #48]	; 0x30
    if (ret < 1)
   1144c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1144e:	2b00      	cmp	r3, #0
   11450:	dc05      	bgt.n	1145e <read_reg+0x19e>
        perror("can't send spi message");
   11452:	f242 2020 	movw	r0, #8736	; 0x2220
   11456:	f2c0 0001 	movt	r0, #1
   1145a:	f7ff ea0a 	blx	10870 <perror@plt>
#if 0
    for (ret = 0; ret < tr.len; ret++) {
        printf("%02X ", rd[ret]);
    }
#endif
    GPIO_SET = 1 << (GPIO_CHIP_SEL);
   1145e:	f642 5304 	movw	r3, #11524	; 0x2d04
   11462:	f2c0 0302 	movt	r3, #2
   11466:	681b      	ldr	r3, [r3, #0]
   11468:	f103 041c 	add.w	r4, r3, #28
   1146c:	2c00      	cmp	r4, #0
   1146e:	d106      	bne.n	1147e <read_reg+0x1be>
   11470:	f642 00bc 	movw	r0, #10428	; 0x28bc
   11474:	f2c0 0002 	movt	r0, #2
   11478:	2100      	movs	r1, #0
   1147a:	f7ff ea30 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1147e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11482:	6023      	str	r3, [r4, #0]
    if (status)
   11484:	687b      	ldr	r3, [r7, #4]
   11486:	2b00      	cmp	r3, #0
   11488:	d018      	beq.n	114bc <read_reg+0x1fc>
        status[0] = rd[0];
   1148a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1148c:	2b00      	cmp	r3, #0
   1148e:	d106      	bne.n	1149e <read_reg+0x1de>
   11490:	f642 00d4 	movw	r0, #10452	; 0x28d4
   11494:	f2c0 0002 	movt	r0, #2
   11498:	2100      	movs	r1, #0
   1149a:	f7ff ea20 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1149e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   114a0:	781c      	ldrb	r4, [r3, #0]
   114a2:	687b      	ldr	r3, [r7, #4]
   114a4:	2b00      	cmp	r3, #0
   114a6:	d106      	bne.n	114b6 <read_reg+0x1f6>
   114a8:	f642 00ec 	movw	r0, #10476	; 0x28ec
   114ac:	f2c0 0002 	movt	r0, #2
   114b0:	2100      	movs	r1, #0
   114b2:	f7ff ea14 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   114b6:	687b      	ldr	r3, [r7, #4]
   114b8:	4622      	mov	r2, r4
   114ba:	701a      	strb	r2, [r3, #0]
    return rd[1];
   114bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   114be:	2b00      	cmp	r3, #0
   114c0:	d106      	bne.n	114d0 <read_reg+0x210>
   114c2:	f642 1004 	movw	r0, #10500	; 0x2904
   114c6:	f2c0 0002 	movt	r0, #2
   114ca:	2100      	movs	r1, #0
   114cc:	f7ff ea06 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   114d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   114d2:	785b      	ldrb	r3, [r3, #1]
}
   114d4:	4618      	mov	r0, r3
   114d6:	3740      	adds	r7, #64	; 0x40
   114d8:	46bd      	mov	sp, r7
   114da:	bdb0      	pop	{r4, r5, r7, pc}

000114dc <strobe_cmd>:

void strobe_cmd(int fd, uint8_t cmd, uint8_t *response)
{
   114dc:	b580      	push	{r7, lr}
   114de:	b084      	sub	sp, #16
   114e0:	af00      	add	r7, sp, #0
   114e2:	60f8      	str	r0, [r7, #12]
   114e4:	460b      	mov	r3, r1
   114e6:	607a      	str	r2, [r7, #4]
   114e8:	72fb      	strb	r3, [r7, #11]
    assert(cmd <= 0x3d && cmd >= 0x30);        
   114ea:	7afb      	ldrb	r3, [r7, #11]
   114ec:	2b3d      	cmp	r3, #61	; 0x3d
   114ee:	d802      	bhi.n	114f6 <strobe_cmd+0x1a>
   114f0:	7afb      	ldrb	r3, [r7, #11]
   114f2:	2b2f      	cmp	r3, #47	; 0x2f
   114f4:	d80f      	bhi.n	11516 <strobe_cmd+0x3a>
   114f6:	f242 2048 	movw	r0, #8776	; 0x2248
   114fa:	f2c0 0001 	movt	r0, #1
   114fe:	f242 11f8 	movw	r1, #8696	; 0x21f8
   11502:	f2c0 0101 	movt	r1, #1
   11506:	f240 2275 	movw	r2, #629	; 0x275
   1150a:	f242 33a0 	movw	r3, #9120	; 0x23a0
   1150e:	f2c0 0301 	movt	r3, #1
   11512:	f7ff e9b4 	blx	1087c <__assert_fail@plt>
    write_reg(fd, cmd, 0, response); 
   11516:	7afb      	ldrb	r3, [r7, #11]
   11518:	68f8      	ldr	r0, [r7, #12]
   1151a:	4619      	mov	r1, r3
   1151c:	2200      	movs	r2, #0
   1151e:	687b      	ldr	r3, [r7, #4]
   11520:	f7ff fb68 	bl	10bf4 <write_reg>
     
}
   11524:	3710      	adds	r7, #16
   11526:	46bd      	mov	sp, r7
   11528:	bd80      	pop	{r7, pc}
   1152a:	bf00      	nop

0001152c <cfg_gpio>:


void cfg_gpio()
{
   1152c:	b5b0      	push	{r4, r5, r7, lr}
   1152e:	af00      	add	r7, sp, #0
    INP_GPIO(GPIO_CHIP_SEL); // must use INP_GPIO before we can use OUT_GPIO
   11530:	f642 5304 	movw	r3, #11524	; 0x2d04
   11534:	f2c0 0302 	movt	r3, #2
   11538:	681b      	ldr	r3, [r3, #0]
   1153a:	f103 0408 	add.w	r4, r3, #8
   1153e:	f642 5304 	movw	r3, #11524	; 0x2d04
   11542:	f2c0 0302 	movt	r3, #2
   11546:	681b      	ldr	r3, [r3, #0]
   11548:	f103 0508 	add.w	r5, r3, #8
   1154c:	2d00      	cmp	r5, #0
   1154e:	d106      	bne.n	1155e <cfg_gpio+0x32>
   11550:	f642 102c 	movw	r0, #10540	; 0x292c
   11554:	f2c0 0002 	movt	r0, #2
   11558:	2100      	movs	r1, #0
   1155a:	f7ff e9c0 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1155e:	682b      	ldr	r3, [r5, #0]
   11560:	f423 75e0 	bic.w	r5, r3, #448	; 0x1c0
   11564:	2c00      	cmp	r4, #0
   11566:	d106      	bne.n	11576 <cfg_gpio+0x4a>
   11568:	f642 1044 	movw	r0, #10564	; 0x2944
   1156c:	f2c0 0002 	movt	r0, #2
   11570:	2100      	movs	r1, #0
   11572:	f7ff e9b4 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11576:	6025      	str	r5, [r4, #0]
    OUT_GPIO(GPIO_CHIP_SEL);
   11578:	f642 5304 	movw	r3, #11524	; 0x2d04
   1157c:	f2c0 0302 	movt	r3, #2
   11580:	681b      	ldr	r3, [r3, #0]
   11582:	f103 0408 	add.w	r4, r3, #8
   11586:	f642 5304 	movw	r3, #11524	; 0x2d04
   1158a:	f2c0 0302 	movt	r3, #2
   1158e:	681b      	ldr	r3, [r3, #0]
   11590:	f103 0508 	add.w	r5, r3, #8
   11594:	2d00      	cmp	r5, #0
   11596:	d106      	bne.n	115a6 <cfg_gpio+0x7a>
   11598:	f642 105c 	movw	r0, #10588	; 0x295c
   1159c:	f2c0 0002 	movt	r0, #2
   115a0:	2100      	movs	r1, #0
   115a2:	f7ff e99c 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   115a6:	682b      	ldr	r3, [r5, #0]
   115a8:	f043 0540 	orr.w	r5, r3, #64	; 0x40
   115ac:	2c00      	cmp	r4, #0
   115ae:	d106      	bne.n	115be <cfg_gpio+0x92>
   115b0:	f642 1074 	movw	r0, #10612	; 0x2974
   115b4:	f2c0 0002 	movt	r0, #2
   115b8:	2100      	movs	r1, #0
   115ba:	f7ff e990 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   115be:	6025      	str	r5, [r4, #0]
    GPIO_SET = 1<<GPIO_CHIP_SEL;
   115c0:	f642 5304 	movw	r3, #11524	; 0x2d04
   115c4:	f2c0 0302 	movt	r3, #2
   115c8:	681b      	ldr	r3, [r3, #0]
   115ca:	f103 041c 	add.w	r4, r3, #28
   115ce:	2c00      	cmp	r4, #0
   115d0:	d106      	bne.n	115e0 <cfg_gpio+0xb4>
   115d2:	f642 108c 	movw	r0, #10636	; 0x298c
   115d6:	f2c0 0002 	movt	r0, #2
   115da:	2100      	movs	r1, #0
   115dc:	f7ff e97e 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   115e0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   115e4:	6023      	str	r3, [r4, #0]

    INP_GPIO(GPIO_RDY); // must use INP_GPIO before we can use OUT_GPIO
   115e6:	f642 5304 	movw	r3, #11524	; 0x2d04
   115ea:	f2c0 0302 	movt	r3, #2
   115ee:	681b      	ldr	r3, [r3, #0]
   115f0:	f103 0408 	add.w	r4, r3, #8
   115f4:	f642 5304 	movw	r3, #11524	; 0x2d04
   115f8:	f2c0 0302 	movt	r3, #2
   115fc:	681b      	ldr	r3, [r3, #0]
   115fe:	f103 0508 	add.w	r5, r3, #8
   11602:	2d00      	cmp	r5, #0
   11604:	d106      	bne.n	11614 <cfg_gpio+0xe8>
   11606:	f642 10a4 	movw	r0, #10660	; 0x29a4
   1160a:	f2c0 0002 	movt	r0, #2
   1160e:	2100      	movs	r1, #0
   11610:	f7ff e964 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11614:	682b      	ldr	r3, [r5, #0]
   11616:	f423 3560 	bic.w	r5, r3, #229376	; 0x38000
   1161a:	2c00      	cmp	r4, #0
   1161c:	d106      	bne.n	1162c <cfg_gpio+0x100>
   1161e:	f642 10bc 	movw	r0, #10684	; 0x29bc
   11622:	f2c0 0002 	movt	r0, #2
   11626:	2100      	movs	r1, #0
   11628:	f7ff e958 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1162c:	6025      	str	r5, [r4, #0]

    INP_GPIO(GPIO_GD0);
   1162e:	f642 5304 	movw	r3, #11524	; 0x2d04
   11632:	f2c0 0302 	movt	r3, #2
   11636:	681b      	ldr	r3, [r3, #0]
   11638:	f103 0408 	add.w	r4, r3, #8
   1163c:	f642 5304 	movw	r3, #11524	; 0x2d04
   11640:	f2c0 0302 	movt	r3, #2
   11644:	681b      	ldr	r3, [r3, #0]
   11646:	f103 0508 	add.w	r5, r3, #8
   1164a:	2d00      	cmp	r5, #0
   1164c:	d106      	bne.n	1165c <cfg_gpio+0x130>
   1164e:	f642 10d4 	movw	r0, #10708	; 0x29d4
   11652:	f2c0 0002 	movt	r0, #2
   11656:	2100      	movs	r1, #0
   11658:	f7ff e940 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1165c:	682b      	ldr	r3, [r5, #0]
   1165e:	f423 45e0 	bic.w	r5, r3, #28672	; 0x7000
   11662:	2c00      	cmp	r4, #0
   11664:	d106      	bne.n	11674 <cfg_gpio+0x148>
   11666:	f642 10ec 	movw	r0, #10732	; 0x29ec
   1166a:	f2c0 0002 	movt	r0, #2
   1166e:	2100      	movs	r1, #0
   11670:	f7ff e934 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11674:	6025      	str	r5, [r4, #0]
    INP_GPIO(GPIO_GD2);
   11676:	f642 5304 	movw	r3, #11524	; 0x2d04
   1167a:	f2c0 0302 	movt	r3, #2
   1167e:	681b      	ldr	r3, [r3, #0]
   11680:	f103 0408 	add.w	r4, r3, #8
   11684:	f642 5304 	movw	r3, #11524	; 0x2d04
   11688:	f2c0 0302 	movt	r3, #2
   1168c:	681b      	ldr	r3, [r3, #0]
   1168e:	f103 0508 	add.w	r5, r3, #8
   11692:	2d00      	cmp	r5, #0
   11694:	d106      	bne.n	116a4 <cfg_gpio+0x178>
   11696:	f642 2004 	movw	r0, #10756	; 0x2a04
   1169a:	f2c0 0002 	movt	r0, #2
   1169e:	2100      	movs	r1, #0
   116a0:	f7ff e91c 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   116a4:	682b      	ldr	r3, [r5, #0]
   116a6:	f423 6560 	bic.w	r5, r3, #3584	; 0xe00
   116aa:	2c00      	cmp	r4, #0
   116ac:	d106      	bne.n	116bc <cfg_gpio+0x190>
   116ae:	f642 201c 	movw	r0, #10780	; 0x2a1c
   116b2:	f2c0 0002 	movt	r0, #2
   116b6:	2100      	movs	r1, #0
   116b8:	f7ff e910 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   116bc:	6025      	str	r5, [r4, #0]
}
   116be:	bdb0      	pop	{r4, r5, r7, pc}

000116c0 <delay_loop>:

void delay_loop(int count)
{
   116c0:	b5b0      	push	{r4, r5, r7, lr}
   116c2:	b084      	sub	sp, #16
   116c4:	af00      	add	r7, sp, #0
   116c6:	6078      	str	r0, [r7, #4]
    volatile int x = count;
   116c8:	687b      	ldr	r3, [r7, #4]
   116ca:	60fb      	str	r3, [r7, #12]
    while(x--)
   116cc:	bf00      	nop
   116ce:	68fc      	ldr	r4, [r7, #12]
   116d0:	1e65      	subs	r5, r4, #1
   116d2:	f04f 33ff 	mov.w	r3, #4294967295
   116d6:	2b00      	cmp	r3, #0
   116d8:	db02      	blt.n	116e0 <delay_loop+0x20>
   116da:	42a5      	cmp	r5, r4
   116dc:	da0b      	bge.n	116f6 <delay_loop+0x36>
   116de:	e001      	b.n	116e4 <delay_loop+0x24>
   116e0:	42a5      	cmp	r5, r4
   116e2:	dd08      	ble.n	116f6 <delay_loop+0x36>
   116e4:	f642 2034 	movw	r0, #10804	; 0x2a34
   116e8:	f2c0 0002 	movt	r0, #2
   116ec:	4621      	mov	r1, r4
   116ee:	f04f 32ff 	mov.w	r2, #4294967295
   116f2:	f7ff e8dc 	blx	108ac <__ubsan_handle_add_overflow@plt>
   116f6:	462b      	mov	r3, r5
   116f8:	60fb      	str	r3, [r7, #12]
   116fa:	2c00      	cmp	r4, #0
   116fc:	d1e7      	bne.n	116ce <delay_loop+0xe>
    ;

}
   116fe:	3710      	adds	r7, #16
   11700:	46bd      	mov	sp, r7
   11702:	bdb0      	pop	{r4, r5, r7, pc}

00011704 <cc1101_reset>:

void cc1101_reset()
{
   11704:	b5b0      	push	{r4, r5, r7, lr}
   11706:	af00      	add	r7, sp, #0
    /*SCK HIGH*/
    INP_GPIO(GPIO_SCK); // must use INP_GPIO before we can use OUT_GPIO
   11708:	f642 5304 	movw	r3, #11524	; 0x2d04
   1170c:	f2c0 0302 	movt	r3, #2
   11710:	681b      	ldr	r3, [r3, #0]
   11712:	1d1c      	adds	r4, r3, #4
   11714:	f642 5304 	movw	r3, #11524	; 0x2d04
   11718:	f2c0 0302 	movt	r3, #2
   1171c:	681b      	ldr	r3, [r3, #0]
   1171e:	1d1d      	adds	r5, r3, #4
   11720:	2d00      	cmp	r5, #0
   11722:	d106      	bne.n	11732 <cc1101_reset+0x2e>
   11724:	f642 2044 	movw	r0, #10820	; 0x2a44
   11728:	f2c0 0002 	movt	r0, #2
   1172c:	2100      	movs	r1, #0
   1172e:	f7ff e8d6 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11732:	682b      	ldr	r3, [r5, #0]
   11734:	f023 0538 	bic.w	r5, r3, #56	; 0x38
   11738:	2c00      	cmp	r4, #0
   1173a:	d106      	bne.n	1174a <cc1101_reset+0x46>
   1173c:	f642 205c 	movw	r0, #10844	; 0x2a5c
   11740:	f2c0 0002 	movt	r0, #2
   11744:	2100      	movs	r1, #0
   11746:	f7ff e8ca 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1174a:	6025      	str	r5, [r4, #0]
    OUT_GPIO(GPIO_SCK);
   1174c:	f642 5304 	movw	r3, #11524	; 0x2d04
   11750:	f2c0 0302 	movt	r3, #2
   11754:	681b      	ldr	r3, [r3, #0]
   11756:	1d1c      	adds	r4, r3, #4
   11758:	f642 5304 	movw	r3, #11524	; 0x2d04
   1175c:	f2c0 0302 	movt	r3, #2
   11760:	681b      	ldr	r3, [r3, #0]
   11762:	1d1d      	adds	r5, r3, #4
   11764:	2d00      	cmp	r5, #0
   11766:	d106      	bne.n	11776 <cc1101_reset+0x72>
   11768:	f642 2074 	movw	r0, #10868	; 0x2a74
   1176c:	f2c0 0002 	movt	r0, #2
   11770:	2100      	movs	r1, #0
   11772:	f7ff e8b4 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11776:	682b      	ldr	r3, [r5, #0]
   11778:	f043 0508 	orr.w	r5, r3, #8
   1177c:	2c00      	cmp	r4, #0
   1177e:	d106      	bne.n	1178e <cc1101_reset+0x8a>
   11780:	f642 208c 	movw	r0, #10892	; 0x2a8c
   11784:	f2c0 0002 	movt	r0, #2
   11788:	2100      	movs	r1, #0
   1178a:	f7ff e8a8 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1178e:	6025      	str	r5, [r4, #0]
    GPIO_SET = 1<<GPIO_SCK;
   11790:	f642 5304 	movw	r3, #11524	; 0x2d04
   11794:	f2c0 0302 	movt	r3, #2
   11798:	681b      	ldr	r3, [r3, #0]
   1179a:	f103 041c 	add.w	r4, r3, #28
   1179e:	2c00      	cmp	r4, #0
   117a0:	d106      	bne.n	117b0 <cc1101_reset+0xac>
   117a2:	f642 20a4 	movw	r0, #10916	; 0x2aa4
   117a6:	f2c0 0002 	movt	r0, #2
   117aa:	2100      	movs	r1, #0
   117ac:	f7ff e896 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   117b0:	f44f 6300 	mov.w	r3, #2048	; 0x800
   117b4:	6023      	str	r3, [r4, #0]

    /*MOSI LOW */
    INP_GPIO(GPIO_MOSI); // must use INP_GPIO before we can use OUT_GPIO
   117b6:	f642 5304 	movw	r3, #11524	; 0x2d04
   117ba:	f2c0 0302 	movt	r3, #2
   117be:	681b      	ldr	r3, [r3, #0]
   117c0:	1d1c      	adds	r4, r3, #4
   117c2:	f642 5304 	movw	r3, #11524	; 0x2d04
   117c6:	f2c0 0302 	movt	r3, #2
   117ca:	681b      	ldr	r3, [r3, #0]
   117cc:	1d1d      	adds	r5, r3, #4
   117ce:	2d00      	cmp	r5, #0
   117d0:	d106      	bne.n	117e0 <cc1101_reset+0xdc>
   117d2:	f642 20bc 	movw	r0, #10940	; 0x2abc
   117d6:	f2c0 0002 	movt	r0, #2
   117da:	2100      	movs	r1, #0
   117dc:	f7ff e87e 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   117e0:	682b      	ldr	r3, [r5, #0]
   117e2:	f023 0507 	bic.w	r5, r3, #7
   117e6:	2c00      	cmp	r4, #0
   117e8:	d106      	bne.n	117f8 <cc1101_reset+0xf4>
   117ea:	f642 20d4 	movw	r0, #10964	; 0x2ad4
   117ee:	f2c0 0002 	movt	r0, #2
   117f2:	2100      	movs	r1, #0
   117f4:	f7ff e872 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   117f8:	6025      	str	r5, [r4, #0]
    OUT_GPIO(GPIO_MOSI);
   117fa:	f642 5304 	movw	r3, #11524	; 0x2d04
   117fe:	f2c0 0302 	movt	r3, #2
   11802:	681b      	ldr	r3, [r3, #0]
   11804:	1d1c      	adds	r4, r3, #4
   11806:	f642 5304 	movw	r3, #11524	; 0x2d04
   1180a:	f2c0 0302 	movt	r3, #2
   1180e:	681b      	ldr	r3, [r3, #0]
   11810:	1d1d      	adds	r5, r3, #4
   11812:	2d00      	cmp	r5, #0
   11814:	d106      	bne.n	11824 <cc1101_reset+0x120>
   11816:	f642 20ec 	movw	r0, #10988	; 0x2aec
   1181a:	f2c0 0002 	movt	r0, #2
   1181e:	2100      	movs	r1, #0
   11820:	f7ff e85c 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11824:	682b      	ldr	r3, [r5, #0]
   11826:	f043 0501 	orr.w	r5, r3, #1
   1182a:	2c00      	cmp	r4, #0
   1182c:	d106      	bne.n	1183c <cc1101_reset+0x138>
   1182e:	f642 3004 	movw	r0, #11012	; 0x2b04
   11832:	f2c0 0002 	movt	r0, #2
   11836:	2100      	movs	r1, #0
   11838:	f7ff e850 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1183c:	6025      	str	r5, [r4, #0]
    GPIO_CLR = 1<<GPIO_MOSI;
   1183e:	f642 5304 	movw	r3, #11524	; 0x2d04
   11842:	f2c0 0302 	movt	r3, #2
   11846:	681b      	ldr	r3, [r3, #0]
   11848:	f103 0428 	add.w	r4, r3, #40	; 0x28
   1184c:	2c00      	cmp	r4, #0
   1184e:	d106      	bne.n	1185e <cc1101_reset+0x15a>
   11850:	f642 301c 	movw	r0, #11036	; 0x2b1c
   11854:	f2c0 0002 	movt	r0, #2
   11858:	2100      	movs	r1, #0
   1185a:	f7ff e840 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1185e:	f44f 6380 	mov.w	r3, #1024	; 0x400
   11862:	6023      	str	r3, [r4, #0]

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   11864:	f642 5304 	movw	r3, #11524	; 0x2d04
   11868:	f2c0 0302 	movt	r3, #2
   1186c:	681b      	ldr	r3, [r3, #0]
   1186e:	f103 0428 	add.w	r4, r3, #40	; 0x28
   11872:	2c00      	cmp	r4, #0
   11874:	d106      	bne.n	11884 <cc1101_reset+0x180>
   11876:	f642 3034 	movw	r0, #11060	; 0x2b34
   1187a:	f2c0 0002 	movt	r0, #2
   1187e:	2100      	movs	r1, #0
   11880:	f7ff e82c 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11884:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11888:	6023      	str	r3, [r4, #0]
    delay_loop(100);
   1188a:	2064      	movs	r0, #100	; 0x64
   1188c:	f7ff ff18 	bl	116c0 <delay_loop>
    GPIO_SET = 1<<(GPIO_CHIP_SEL);
   11890:	f642 5304 	movw	r3, #11524	; 0x2d04
   11894:	f2c0 0302 	movt	r3, #2
   11898:	681b      	ldr	r3, [r3, #0]
   1189a:	f103 041c 	add.w	r4, r3, #28
   1189e:	2c00      	cmp	r4, #0
   118a0:	d106      	bne.n	118b0 <cc1101_reset+0x1ac>
   118a2:	f642 304c 	movw	r0, #11084	; 0x2b4c
   118a6:	f2c0 0002 	movt	r0, #2
   118aa:	2100      	movs	r1, #0
   118ac:	f7ff e816 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   118b0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   118b4:	6023      	str	r3, [r4, #0]
    delay_loop(8000);
   118b6:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
   118ba:	f7ff ff01 	bl	116c0 <delay_loop>

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   118be:	f642 5304 	movw	r3, #11524	; 0x2d04
   118c2:	f2c0 0302 	movt	r3, #2
   118c6:	681b      	ldr	r3, [r3, #0]
   118c8:	f103 0428 	add.w	r4, r3, #40	; 0x28
   118cc:	2c00      	cmp	r4, #0
   118ce:	d106      	bne.n	118de <cc1101_reset+0x1da>
   118d0:	f642 3064 	movw	r0, #11108	; 0x2b64
   118d4:	f2c0 0002 	movt	r0, #2
   118d8:	2100      	movs	r1, #0
   118da:	f7ff e800 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   118de:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   118e2:	6023      	str	r3, [r4, #0]

    while(GET_GPIO(GPIO_RDY))
   118e4:	e005      	b.n	118f2 <cc1101_reset+0x1ee>
        printf("Waiting for GPIO_RDY");
   118e6:	f242 2064 	movw	r0, #8804	; 0x2264
   118ea:	f2c0 0001 	movt	r0, #1
   118ee:	f7fe efe4 	blx	108b8 <printf@plt>
    GPIO_SET = 1<<(GPIO_CHIP_SEL);
    delay_loop(8000);

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);

    while(GET_GPIO(GPIO_RDY))
   118f2:	f642 5304 	movw	r3, #11524	; 0x2d04
   118f6:	f2c0 0302 	movt	r3, #2
   118fa:	681b      	ldr	r3, [r3, #0]
   118fc:	f103 0434 	add.w	r4, r3, #52	; 0x34
   11900:	2c00      	cmp	r4, #0
   11902:	d106      	bne.n	11912 <cc1101_reset+0x20e>
   11904:	f642 307c 	movw	r0, #11132	; 0x2b7c
   11908:	f2c0 0002 	movt	r0, #2
   1190c:	2100      	movs	r1, #0
   1190e:	f7fe efe6 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11912:	6823      	ldr	r3, [r4, #0]
   11914:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   11918:	2b00      	cmp	r3, #0
   1191a:	d1e4      	bne.n	118e6 <cc1101_reset+0x1e2>
        printf("Waiting for GPIO_RDY");

    INP_GPIO(GPIO_SCK); // must use INP_GPIO before we can use OUT_GPIO
   1191c:	f642 5304 	movw	r3, #11524	; 0x2d04
   11920:	f2c0 0302 	movt	r3, #2
   11924:	681b      	ldr	r3, [r3, #0]
   11926:	1d1c      	adds	r4, r3, #4
   11928:	f642 5304 	movw	r3, #11524	; 0x2d04
   1192c:	f2c0 0302 	movt	r3, #2
   11930:	681b      	ldr	r3, [r3, #0]
   11932:	1d1d      	adds	r5, r3, #4
   11934:	2d00      	cmp	r5, #0
   11936:	d106      	bne.n	11946 <cc1101_reset+0x242>
   11938:	f642 3094 	movw	r0, #11156	; 0x2b94
   1193c:	f2c0 0002 	movt	r0, #2
   11940:	2100      	movs	r1, #0
   11942:	f7fe efcc 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11946:	682b      	ldr	r3, [r5, #0]
   11948:	f023 0538 	bic.w	r5, r3, #56	; 0x38
   1194c:	2c00      	cmp	r4, #0
   1194e:	d106      	bne.n	1195e <cc1101_reset+0x25a>
   11950:	f642 30ac 	movw	r0, #11180	; 0x2bac
   11954:	f2c0 0002 	movt	r0, #2
   11958:	2100      	movs	r1, #0
   1195a:	f7fe efc0 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1195e:	6025      	str	r5, [r4, #0]
    SET_GPIO_ALT(GPIO_SCK,0);
   11960:	f642 5304 	movw	r3, #11524	; 0x2d04
   11964:	f2c0 0302 	movt	r3, #2
   11968:	681b      	ldr	r3, [r3, #0]
   1196a:	1d1c      	adds	r4, r3, #4
   1196c:	f642 5304 	movw	r3, #11524	; 0x2d04
   11970:	f2c0 0302 	movt	r3, #2
   11974:	681b      	ldr	r3, [r3, #0]
   11976:	1d1d      	adds	r5, r3, #4
   11978:	2d00      	cmp	r5, #0
   1197a:	d106      	bne.n	1198a <cc1101_reset+0x286>
   1197c:	f642 30c4 	movw	r0, #11204	; 0x2bc4
   11980:	f2c0 0002 	movt	r0, #2
   11984:	2100      	movs	r1, #0
   11986:	f7fe efaa 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   1198a:	682b      	ldr	r3, [r5, #0]
   1198c:	f043 0520 	orr.w	r5, r3, #32
   11990:	2c00      	cmp	r4, #0
   11992:	d106      	bne.n	119a2 <cc1101_reset+0x29e>
   11994:	f642 30dc 	movw	r0, #11228	; 0x2bdc
   11998:	f2c0 0002 	movt	r0, #2
   1199c:	2100      	movs	r1, #0
   1199e:	f7fe ef9e 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   119a2:	6025      	str	r5, [r4, #0]

    INP_GPIO(GPIO_MOSI); // must use INP_GPIO before we can use OUT_GPIO
   119a4:	f642 5304 	movw	r3, #11524	; 0x2d04
   119a8:	f2c0 0302 	movt	r3, #2
   119ac:	681b      	ldr	r3, [r3, #0]
   119ae:	1d1c      	adds	r4, r3, #4
   119b0:	f642 5304 	movw	r3, #11524	; 0x2d04
   119b4:	f2c0 0302 	movt	r3, #2
   119b8:	681b      	ldr	r3, [r3, #0]
   119ba:	1d1d      	adds	r5, r3, #4
   119bc:	2d00      	cmp	r5, #0
   119be:	d106      	bne.n	119ce <cc1101_reset+0x2ca>
   119c0:	f642 30f4 	movw	r0, #11252	; 0x2bf4
   119c4:	f2c0 0002 	movt	r0, #2
   119c8:	2100      	movs	r1, #0
   119ca:	f7fe ef88 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   119ce:	682b      	ldr	r3, [r5, #0]
   119d0:	f023 0507 	bic.w	r5, r3, #7
   119d4:	2c00      	cmp	r4, #0
   119d6:	d106      	bne.n	119e6 <cc1101_reset+0x2e2>
   119d8:	f642 400c 	movw	r0, #11276	; 0x2c0c
   119dc:	f2c0 0002 	movt	r0, #2
   119e0:	2100      	movs	r1, #0
   119e2:	f7fe ef7c 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   119e6:	6025      	str	r5, [r4, #0]
    SET_GPIO_ALT(GPIO_MOSI, 0);
   119e8:	f642 5304 	movw	r3, #11524	; 0x2d04
   119ec:	f2c0 0302 	movt	r3, #2
   119f0:	681b      	ldr	r3, [r3, #0]
   119f2:	1d1c      	adds	r4, r3, #4
   119f4:	f642 5304 	movw	r3, #11524	; 0x2d04
   119f8:	f2c0 0302 	movt	r3, #2
   119fc:	681b      	ldr	r3, [r3, #0]
   119fe:	1d1d      	adds	r5, r3, #4
   11a00:	2d00      	cmp	r5, #0
   11a02:	d106      	bne.n	11a12 <cc1101_reset+0x30e>
   11a04:	f642 4024 	movw	r0, #11300	; 0x2c24
   11a08:	f2c0 0002 	movt	r0, #2
   11a0c:	2100      	movs	r1, #0
   11a0e:	f7fe ef66 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11a12:	682b      	ldr	r3, [r5, #0]
   11a14:	f043 0504 	orr.w	r5, r3, #4
   11a18:	2c00      	cmp	r4, #0
   11a1a:	d106      	bne.n	11a2a <cc1101_reset+0x326>
   11a1c:	f642 403c 	movw	r0, #11324	; 0x2c3c
   11a20:	f2c0 0002 	movt	r0, #2
   11a24:	2100      	movs	r1, #0
   11a26:	f7fe ef5a 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11a2a:	6025      	str	r5, [r4, #0]
}
   11a2c:	bdb0      	pop	{r4, r5, r7, pc}
   11a2e:	bf00      	nop

00011a30 <cc1101_cfg_band>:

void cc1101_cfg_band(int fd, fset_t fset)
{
   11a30:	b590      	push	{r4, r7, lr}
   11a32:	b085      	sub	sp, #20
   11a34:	af00      	add	r7, sp, #0
   11a36:	6078      	str	r0, [r7, #4]
   11a38:	6039      	str	r1, [r7, #0]
    uint8_t i;
    assert(fset >= ISM_EU && fset < ISM_MAX);
   11a3a:	683b      	ldr	r3, [r7, #0]
   11a3c:	2b02      	cmp	r3, #2
   11a3e:	d90f      	bls.n	11a60 <cc1101_cfg_band+0x30>
   11a40:	f242 207c 	movw	r0, #8828	; 0x227c
   11a44:	f2c0 0001 	movt	r0, #1
   11a48:	f242 11f8 	movw	r1, #8696	; 0x21f8
   11a4c:	f2c0 0101 	movt	r1, #1
   11a50:	f240 22af 	movw	r2, #687	; 0x2af
   11a54:	f242 33ac 	movw	r3, #9132	; 0x23ac
   11a58:	f2c0 0301 	movt	r3, #1
   11a5c:	f7fe ef0e 	blx	1087c <__assert_fail@plt>
    for ( i = 0; i < sizeof(band_regs)/sizeof(band_regs[0]); i++)
   11a60:	2300      	movs	r3, #0
   11a62:	73fb      	strb	r3, [r7, #15]
   11a64:	e01a      	b.n	11a9c <cc1101_cfg_band+0x6c>
    {
        write_reg(fd, band_regs[i], freq_config[fset][i], NULL);
   11a66:	7bfa      	ldrb	r2, [r7, #15]
   11a68:	f242 5354 	movw	r3, #9556	; 0x2554
   11a6c:	f2c0 0302 	movt	r3, #2
   11a70:	5c9c      	ldrb	r4, [r3, r2]
   11a72:	7bf8      	ldrb	r0, [r7, #15]
   11a74:	f242 525c 	movw	r2, #9564	; 0x255c
   11a78:	f2c0 0202 	movt	r2, #2
   11a7c:	6839      	ldr	r1, [r7, #0]
   11a7e:	460b      	mov	r3, r1
   11a80:	009b      	lsls	r3, r3, #2
   11a82:	440b      	add	r3, r1
   11a84:	4403      	add	r3, r0
   11a86:	4413      	add	r3, r2
   11a88:	781b      	ldrb	r3, [r3, #0]
   11a8a:	6878      	ldr	r0, [r7, #4]
   11a8c:	4621      	mov	r1, r4
   11a8e:	461a      	mov	r2, r3
   11a90:	2300      	movs	r3, #0
   11a92:	f7ff f8af 	bl	10bf4 <write_reg>

void cc1101_cfg_band(int fd, fset_t fset)
{
    uint8_t i;
    assert(fset >= ISM_EU && fset < ISM_MAX);
    for ( i = 0; i < sizeof(band_regs)/sizeof(band_regs[0]); i++)
   11a96:	7bfb      	ldrb	r3, [r7, #15]
   11a98:	3301      	adds	r3, #1
   11a9a:	73fb      	strb	r3, [r7, #15]
   11a9c:	7bfb      	ldrb	r3, [r7, #15]
   11a9e:	2b04      	cmp	r3, #4
   11aa0:	d9e1      	bls.n	11a66 <cc1101_cfg_band+0x36>
    {
        write_reg(fd, band_regs[i], freq_config[fset][i], NULL);
    }
    
}
   11aa2:	3714      	adds	r7, #20
   11aa4:	46bd      	mov	sp, r7
   11aa6:	bd90      	pop	{r4, r7, pc}

00011aa8 <cc1101_cfg_regs>:

void cc1101_cfg_regs(int fd)
{
   11aa8:	b580      	push	{r7, lr}
   11aaa:	b084      	sub	sp, #16
   11aac:	af00      	add	r7, sp, #0
   11aae:	6078      	str	r0, [r7, #4]
    uint32_t i;
    for (i = 0; i < sizeof(wbslRadioCfg)/sizeof(wbslRadioCfg[0]); i++)
   11ab0:	2300      	movs	r3, #0
   11ab2:	60fb      	str	r3, [r7, #12]
   11ab4:	e01b      	b.n	11aee <cc1101_cfg_regs+0x46>
    {
        uint8_t reg = wbslRadioCfg[i][0];
   11ab6:	f242 03dc 	movw	r3, #8412	; 0x20dc
   11aba:	f2c0 0301 	movt	r3, #1
   11abe:	68fa      	ldr	r2, [r7, #12]
   11ac0:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
   11ac4:	72fb      	strb	r3, [r7, #11]
        uint8_t val = wbslRadioCfg[i][1];
   11ac6:	f242 02dc 	movw	r2, #8412	; 0x20dc
   11aca:	f2c0 0201 	movt	r2, #1
   11ace:	68fb      	ldr	r3, [r7, #12]
   11ad0:	005b      	lsls	r3, r3, #1
   11ad2:	4413      	add	r3, r2
   11ad4:	785b      	ldrb	r3, [r3, #1]
   11ad6:	72bb      	strb	r3, [r7, #10]
        write_reg(fd, reg, val, NULL); 
   11ad8:	7afa      	ldrb	r2, [r7, #11]
   11ada:	7abb      	ldrb	r3, [r7, #10]
   11adc:	6878      	ldr	r0, [r7, #4]
   11ade:	4611      	mov	r1, r2
   11ae0:	461a      	mov	r2, r3
   11ae2:	2300      	movs	r3, #0
   11ae4:	f7ff f886 	bl	10bf4 <write_reg>
}

void cc1101_cfg_regs(int fd)
{
    uint32_t i;
    for (i = 0; i < sizeof(wbslRadioCfg)/sizeof(wbslRadioCfg[0]); i++)
   11ae8:	68fb      	ldr	r3, [r7, #12]
   11aea:	3301      	adds	r3, #1
   11aec:	60fb      	str	r3, [r7, #12]
   11aee:	68fb      	ldr	r3, [r7, #12]
   11af0:	2b25      	cmp	r3, #37	; 0x25
   11af2:	d9e0      	bls.n	11ab6 <cc1101_cfg_regs+0xe>
        write_reg(fd, reg, val, NULL); 
    }
#if defined(GD0_RX_OVERFLOW_DETECT)
    write_reg(fd, IOCFG0, 4, NULL);
#else
    write_reg(fd, IOCFG0, WBSL_GDO_SYNC, NULL);
   11af4:	6878      	ldr	r0, [r7, #4]
   11af6:	2102      	movs	r1, #2
   11af8:	2206      	movs	r2, #6
   11afa:	2300      	movs	r3, #0
   11afc:	f7ff f87a 	bl	10bf4 <write_reg>
#endif
    write_reg(fd, IOCFG2, 7, NULL);
   11b00:	6878      	ldr	r0, [r7, #4]
   11b02:	2100      	movs	r1, #0
   11b04:	2207      	movs	r2, #7
   11b06:	2300      	movs	r3, #0
   11b08:	f7ff f874 	bl	10bf4 <write_reg>
#if 0
    write_reg(fd, PA_TABLE0, WBSL_SETTING_PA_TABLE0, NULL);
#endif
}
   11b0c:	3710      	adds	r7, #16
   11b0e:	46bd      	mov	sp, r7
   11b10:	bd80      	pop	{r7, pc}
   11b12:	bf00      	nop

00011b14 <cc1101_initialize>:


void cc1101_initialize(int fd, fset_t fset)
{
   11b14:	b580      	push	{r7, lr}
   11b16:	b084      	sub	sp, #16
   11b18:	af00      	add	r7, sp, #0
   11b1a:	6078      	str	r0, [r7, #4]
   11b1c:	6039      	str	r1, [r7, #0]

    cc1101_reset();
   11b1e:	f7ff fdf1 	bl	11704 <cc1101_reset>
    uint8_t response;
    strobe_cmd(fd, SRES, &response);
   11b22:	f107 030f 	add.w	r3, r7, #15
   11b26:	6878      	ldr	r0, [r7, #4]
   11b28:	2130      	movs	r1, #48	; 0x30
   11b2a:	461a      	mov	r2, r3
   11b2c:	f7ff fcd6 	bl	114dc <strobe_cmd>
    while (response & 0x70)
   11b30:	e00e      	b.n	11b50 <cc1101_initialize+0x3c>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
   11b32:	7bfb      	ldrb	r3, [r7, #15]
   11b34:	f242 20a0 	movw	r0, #8864	; 0x22a0
   11b38:	f2c0 0001 	movt	r0, #1
   11b3c:	4619      	mov	r1, r3
   11b3e:	f7fe eebc 	blx	108b8 <printf@plt>
        strobe_cmd(fd, SIDLE, &response);
   11b42:	f107 030f 	add.w	r3, r7, #15
   11b46:	6878      	ldr	r0, [r7, #4]
   11b48:	2136      	movs	r1, #54	; 0x36
   11b4a:	461a      	mov	r2, r3
   11b4c:	f7ff fcc6 	bl	114dc <strobe_cmd>
{

    cc1101_reset();
    uint8_t response;
    strobe_cmd(fd, SRES, &response);
    while (response & 0x70)
   11b50:	7bfb      	ldrb	r3, [r7, #15]
   11b52:	f003 0370 	and.w	r3, r3, #112	; 0x70
   11b56:	2b00      	cmp	r3, #0
   11b58:	d1eb      	bne.n	11b32 <cc1101_initialize+0x1e>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
        strobe_cmd(fd, SIDLE, &response);
    }

    cc1101_cfg_regs(fd);
   11b5a:	6878      	ldr	r0, [r7, #4]
   11b5c:	f7ff ffa4 	bl	11aa8 <cc1101_cfg_regs>
    cc1101_cfg_band(fd, fset);
   11b60:	6878      	ldr	r0, [r7, #4]
   11b62:	6839      	ldr	r1, [r7, #0]
   11b64:	f7ff ff64 	bl	11a30 <cc1101_cfg_band>
}
   11b68:	3710      	adds	r7, #16
   11b6a:	46bd      	mov	sp, r7
   11b6c:	bd80      	pop	{r7, pc}
   11b6e:	bf00      	nop

00011b70 <rxon>:

void rxon(int fd)
{
   11b70:	b580      	push	{r7, lr}
   11b72:	b082      	sub	sp, #8
   11b74:	af00      	add	r7, sp, #0
   11b76:	6078      	str	r0, [r7, #4]
    strobe_cmd(fd, SRX, NULL); 
   11b78:	6878      	ldr	r0, [r7, #4]
   11b7a:	2134      	movs	r1, #52	; 0x34
   11b7c:	2200      	movs	r2, #0
   11b7e:	f7ff fcad 	bl	114dc <strobe_cmd>
}
   11b82:	3708      	adds	r7, #8
   11b84:	46bd      	mov	sp, r7
   11b86:	bd80      	pop	{r7, pc}

00011b88 <rxoff>:


void rxoff(int fd)
{
   11b88:	b580      	push	{r7, lr}
   11b8a:	b084      	sub	sp, #16
   11b8c:	af00      	add	r7, sp, #0
   11b8e:	6078      	str	r0, [r7, #4]
    uint8_t response;
    strobe_cmd(fd, SFRX, &response);
   11b90:	f107 030f 	add.w	r3, r7, #15
   11b94:	6878      	ldr	r0, [r7, #4]
   11b96:	213a      	movs	r1, #58	; 0x3a
   11b98:	461a      	mov	r2, r3
   11b9a:	f7ff fc9f 	bl	114dc <strobe_cmd>
    strobe_cmd(fd, SIDLE, &response);
   11b9e:	f107 030f 	add.w	r3, r7, #15
   11ba2:	6878      	ldr	r0, [r7, #4]
   11ba4:	2136      	movs	r1, #54	; 0x36
   11ba6:	461a      	mov	r2, r3
   11ba8:	f7ff fc98 	bl	114dc <strobe_cmd>
    while (response & 0x70)
   11bac:	e00e      	b.n	11bcc <rxoff+0x44>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
   11bae:	7bfb      	ldrb	r3, [r7, #15]
   11bb0:	f242 20a0 	movw	r0, #8864	; 0x22a0
   11bb4:	f2c0 0001 	movt	r0, #1
   11bb8:	4619      	mov	r1, r3
   11bba:	f7fe ee7e 	blx	108b8 <printf@plt>
        strobe_cmd(fd, SIDLE, &response);
   11bbe:	f107 030f 	add.w	r3, r7, #15
   11bc2:	6878      	ldr	r0, [r7, #4]
   11bc4:	2136      	movs	r1, #54	; 0x36
   11bc6:	461a      	mov	r2, r3
   11bc8:	f7ff fc88 	bl	114dc <strobe_cmd>
void rxoff(int fd)
{
    uint8_t response;
    strobe_cmd(fd, SFRX, &response);
    strobe_cmd(fd, SIDLE, &response);
    while (response & 0x70)
   11bcc:	7bfb      	ldrb	r3, [r7, #15]
   11bce:	f003 0370 	and.w	r3, r3, #112	; 0x70
   11bd2:	2b00      	cmp	r3, #0
   11bd4:	d1eb      	bne.n	11bae <rxoff+0x26>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
        strobe_cmd(fd, SIDLE, &response);
    }

}
   11bd6:	3710      	adds	r7, #16
   11bd8:	46bd      	mov	sp, r7
   11bda:	bd80      	pop	{r7, pc}

00011bdc <txstart>:

void txstart(int fd)
{
   11bdc:	b580      	push	{r7, lr}
   11bde:	b082      	sub	sp, #8
   11be0:	af00      	add	r7, sp, #0
   11be2:	6078      	str	r0, [r7, #4]
    strobe_cmd(fd, STX, NULL); 
   11be4:	6878      	ldr	r0, [r7, #4]
   11be6:	2135      	movs	r1, #53	; 0x35
   11be8:	2200      	movs	r2, #0
   11bea:	f7ff fc77 	bl	114dc <strobe_cmd>
}
   11bee:	3708      	adds	r7, #8
   11bf0:	46bd      	mov	sp, r7
   11bf2:	bd80      	pop	{r7, pc}

00011bf4 <txoff>:

void txoff(int fd)
{
   11bf4:	b580      	push	{r7, lr}
   11bf6:	b084      	sub	sp, #16
   11bf8:	af00      	add	r7, sp, #0
   11bfa:	6078      	str	r0, [r7, #4]
    uint8_t response;
    strobe_cmd(fd, SFTX, &response);
   11bfc:	f107 030f 	add.w	r3, r7, #15
   11c00:	6878      	ldr	r0, [r7, #4]
   11c02:	213b      	movs	r1, #59	; 0x3b
   11c04:	461a      	mov	r2, r3
   11c06:	f7ff fc69 	bl	114dc <strobe_cmd>
    strobe_cmd(fd, SIDLE, &response);
   11c0a:	f107 030f 	add.w	r3, r7, #15
   11c0e:	6878      	ldr	r0, [r7, #4]
   11c10:	2136      	movs	r1, #54	; 0x36
   11c12:	461a      	mov	r2, r3
   11c14:	f7ff fc62 	bl	114dc <strobe_cmd>
    while (response & 0x70)
   11c18:	e00e      	b.n	11c38 <txoff+0x44>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
   11c1a:	7bfb      	ldrb	r3, [r7, #15]
   11c1c:	f242 20a0 	movw	r0, #8864	; 0x22a0
   11c20:	f2c0 0001 	movt	r0, #1
   11c24:	4619      	mov	r1, r3
   11c26:	f7fe ee48 	blx	108b8 <printf@plt>
        strobe_cmd(fd, SIDLE, &response);
   11c2a:	f107 030f 	add.w	r3, r7, #15
   11c2e:	6878      	ldr	r0, [r7, #4]
   11c30:	2136      	movs	r1, #54	; 0x36
   11c32:	461a      	mov	r2, r3
   11c34:	f7ff fc52 	bl	114dc <strobe_cmd>
void txoff(int fd)
{
    uint8_t response;
    strobe_cmd(fd, SFTX, &response);
    strobe_cmd(fd, SIDLE, &response);
    while (response & 0x70)
   11c38:	7bfb      	ldrb	r3, [r7, #15]
   11c3a:	f003 0370 	and.w	r3, r3, #112	; 0x70
   11c3e:	2b00      	cmp	r3, #0
   11c40:	d1eb      	bne.n	11c1a <txoff+0x26>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
        strobe_cmd(fd, SIDLE, &response);
    }

}
   11c42:	3710      	adds	r7, #16
   11c44:	46bd      	mov	sp, r7
   11c46:	bd80      	pop	{r7, pc}

00011c48 <CheckRx>:


uint8_t CheckRx(int fd)
{
   11c48:	b590      	push	{r4, r7, lr}
   11c4a:	b085      	sub	sp, #20
   11c4c:	af00      	add	r7, sp, #0
   11c4e:	6078      	str	r0, [r7, #4]
    uint8_t bytes = 0;
   11c50:	2300      	movs	r3, #0
   11c52:	73bb      	strb	r3, [r7, #14]
#if !defined(GD0_RX_OVERFLOW_DETECT)
    uint8_t marc_state = read_reg(fd, MARCSTATE, NULL) & 0x1f;
   11c54:	6878      	ldr	r0, [r7, #4]
   11c56:	2135      	movs	r1, #53	; 0x35
   11c58:	2200      	movs	r2, #0
   11c5a:	f7ff fb31 	bl	112c0 <read_reg>
   11c5e:	4603      	mov	r3, r0
   11c60:	f003 031f 	and.w	r3, r3, #31
   11c64:	737b      	strb	r3, [r7, #13]
    if (marc_state == 0x11)
   11c66:	7b7b      	ldrb	r3, [r7, #13]
   11c68:	2b11      	cmp	r3, #17
   11c6a:	d10b      	bne.n	11c84 <CheckRx+0x3c>
#else
    if (GET_GPIO(GPIO_GD0))
#endif
    {
        printf("RX overflow\n");
   11c6c:	f242 20c4 	movw	r0, #8900	; 0x22c4
   11c70:	f2c0 0001 	movt	r0, #1
   11c74:	f7fe ee38 	blx	108e8 <puts@plt>
        rxoff(fd);
   11c78:	6878      	ldr	r0, [r7, #4]
   11c7a:	f7ff ff85 	bl	11b88 <rxoff>
        rxon(fd);
   11c7e:	6878      	ldr	r0, [r7, #4]
   11c80:	f7ff ff76 	bl	11b70 <rxon>
    }
    if (!GET_GPIO(GPIO_GD2))
   11c84:	f642 5304 	movw	r3, #11524	; 0x2d04
   11c88:	f2c0 0302 	movt	r3, #2
   11c8c:	681b      	ldr	r3, [r3, #0]
   11c8e:	f103 0434 	add.w	r4, r3, #52	; 0x34
   11c92:	2c00      	cmp	r4, #0
   11c94:	d106      	bne.n	11ca4 <CheckRx+0x5c>
   11c96:	f642 4054 	movw	r0, #11348	; 0x2c54
   11c9a:	f2c0 0002 	movt	r0, #2
   11c9e:	2100      	movs	r1, #0
   11ca0:	f7fe ee1c 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11ca4:	6823      	ldr	r3, [r4, #0]
   11ca6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
   11caa:	2b00      	cmp	r3, #0
   11cac:	d101      	bne.n	11cb2 <CheckRx+0x6a>
    {
        return 0;
   11cae:	2300      	movs	r3, #0
   11cb0:	e037      	b.n	11d22 <CheckRx+0xda>
    }
    else 
    {
        int8_t val = bytes = read_reg(fd,RXBYTES, NULL);
   11cb2:	6878      	ldr	r0, [r7, #4]
   11cb4:	213b      	movs	r1, #59	; 0x3b
   11cb6:	2200      	movs	r2, #0
   11cb8:	f7ff fb02 	bl	112c0 <read_reg>
   11cbc:	4603      	mov	r3, r0
   11cbe:	73bb      	strb	r3, [r7, #14]
   11cc0:	7bbb      	ldrb	r3, [r7, #14]
   11cc2:	73fb      	strb	r3, [r7, #15]
        if (val)
   11cc4:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11cc8:	2b00      	cmp	r3, #0
   11cca:	d019      	beq.n	11d00 <CheckRx+0xb8>
        {
            int8_t tmpval = 0;
   11ccc:	2300      	movs	r3, #0
   11cce:	733b      	strb	r3, [r7, #12]
            while (val != (tmpval = read_reg(fd, RXBYTES, NULL)))
   11cd0:	e001      	b.n	11cd6 <CheckRx+0x8e>
                val = tmpval;
   11cd2:	7b3b      	ldrb	r3, [r7, #12]
   11cd4:	73fb      	strb	r3, [r7, #15]
    {
        int8_t val = bytes = read_reg(fd,RXBYTES, NULL);
        if (val)
        {
            int8_t tmpval = 0;
            while (val != (tmpval = read_reg(fd, RXBYTES, NULL)))
   11cd6:	6878      	ldr	r0, [r7, #4]
   11cd8:	213b      	movs	r1, #59	; 0x3b
   11cda:	2200      	movs	r2, #0
   11cdc:	f7ff faf0 	bl	112c0 <read_reg>
   11ce0:	4603      	mov	r3, r0
   11ce2:	733b      	strb	r3, [r7, #12]
   11ce4:	f997 200c 	ldrsb.w	r2, [r7, #12]
   11ce8:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11cec:	429a      	cmp	r2, r3
   11cee:	d1f0      	bne.n	11cd2 <CheckRx+0x8a>
                val = tmpval;
            val = val & 0x7f;
   11cf0:	7bfb      	ldrb	r3, [r7, #15]
   11cf2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   11cf6:	73fb      	strb	r3, [r7, #15]
            return bytes = val;
   11cf8:	7bfb      	ldrb	r3, [r7, #15]
   11cfa:	73bb      	strb	r3, [r7, #14]
   11cfc:	7bbb      	ldrb	r3, [r7, #14]
   11cfe:	e010      	b.n	11d22 <CheckRx+0xda>
        }
        else
        {
            /* False Packet Detected ? */
            rxoff(fd); 
   11d00:	6878      	ldr	r0, [r7, #4]
   11d02:	f7ff ff41 	bl	11b88 <rxoff>
            rxon(fd);
   11d06:	6878      	ldr	r0, [r7, #4]
   11d08:	f7ff ff32 	bl	11b70 <rxon>
            val = 0;
   11d0c:	2300      	movs	r3, #0
   11d0e:	73fb      	strb	r3, [r7, #15]
            bytes = 0;
   11d10:	2300      	movs	r3, #0
   11d12:	73bb      	strb	r3, [r7, #14]
            printf("Radio Reset due to false detection !!!\n");
   11d14:	f242 20d0 	movw	r0, #8912	; 0x22d0
   11d18:	f2c0 0001 	movt	r0, #1
   11d1c:	f7fe ede4 	blx	108e8 <puts@plt>
        }

      }

    return bytes;
   11d20:	7bbb      	ldrb	r3, [r7, #14]
}
   11d22:	4618      	mov	r0, r3
   11d24:	3714      	adds	r7, #20
   11d26:	46bd      	mov	sp, r7
   11d28:	bd90      	pop	{r4, r7, pc}
   11d2a:	bf00      	nop

00011d2c <ReceivePkt>:

void ReceivePkt(int fd, uint8_t *pktbuf, uint8_t bytes)
{
   11d2c:	b580      	push	{r7, lr}
   11d2e:	b084      	sub	sp, #16
   11d30:	af00      	add	r7, sp, #0
   11d32:	60f8      	str	r0, [r7, #12]
   11d34:	60b9      	str	r1, [r7, #8]
   11d36:	4613      	mov	r3, r2
   11d38:	71fb      	strb	r3, [r7, #7]
    {
        pktbuf[i] = read_reg(fd, RXFIFO, &status);
        printf("Status %x\n", status);
    }
#else
    read_reg_burst(fd, RXFIFO, bytes, pktbuf); 
   11d3a:	79fb      	ldrb	r3, [r7, #7]
   11d3c:	68f8      	ldr	r0, [r7, #12]
   11d3e:	213f      	movs	r1, #63	; 0x3f
   11d40:	461a      	mov	r2, r3
   11d42:	68bb      	ldr	r3, [r7, #8]
   11d44:	f7ff f840 	bl	10dc8 <read_reg_burst>
#endif

}
   11d48:	3710      	adds	r7, #16
   11d4a:	46bd      	mov	sp, r7
   11d4c:	bd80      	pop	{r7, pc}
   11d4e:	bf00      	nop

00011d50 <TransmitPkt>:

void TransmitPkt(int fd, uint8_t *payload, uint8_t len)
{
   11d50:	b580      	push	{r7, lr}
   11d52:	b084      	sub	sp, #16
   11d54:	af00      	add	r7, sp, #0
   11d56:	60f8      	str	r0, [r7, #12]
   11d58:	60b9      	str	r1, [r7, #8]
   11d5a:	4613      	mov	r3, r2
   11d5c:	71fb      	strb	r3, [r7, #7]
    write_reg_burst(fd, TXFIFO, payload, len);
   11d5e:	79fb      	ldrb	r3, [r7, #7]
   11d60:	68f8      	ldr	r0, [r7, #12]
   11d62:	213f      	movs	r1, #63	; 0x3f
   11d64:	68ba      	ldr	r2, [r7, #8]
   11d66:	f7ff f95d 	bl	11024 <write_reg_burst>
    txstart(fd);
   11d6a:	68f8      	ldr	r0, [r7, #12]
   11d6c:	f7ff ff36 	bl	11bdc <txstart>
}
   11d70:	3710      	adds	r7, #16
   11d72:	46bd      	mov	sp, r7
   11d74:	bd80      	pop	{r7, pc}
   11d76:	bf00      	nop

00011d78 <main>:

int main(int argc, char **argv)
{
   11d78:	b590      	push	{r4, r7, lr}
   11d7a:	b0cb      	sub	sp, #300	; 0x12c
   11d7c:	af00      	add	r7, sp, #0
   11d7e:	1d3b      	adds	r3, r7, #4
   11d80:	6018      	str	r0, [r3, #0]
   11d82:	463b      	mov	r3, r7
   11d84:	6019      	str	r1, [r3, #0]
    int fd;
    fset_t fset = ISM_US;
   11d86:	2301      	movs	r3, #1
   11d88:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    uint8_t status;
    uint8_t pktbuf[256];

    if (argc == 2)
   11d8c:	1d3b      	adds	r3, r7, #4
   11d8e:	681b      	ldr	r3, [r3, #0]
   11d90:	2b02      	cmp	r3, #2
   11d92:	d159      	bne.n	11e48 <main+0xd0>
    {
        if (!strcmp(argv[1], "US"))
   11d94:	463b      	mov	r3, r7
   11d96:	681b      	ldr	r3, [r3, #0]
   11d98:	1d1c      	adds	r4, r3, #4
   11d9a:	2c00      	cmp	r4, #0
   11d9c:	d106      	bne.n	11dac <main+0x34>
   11d9e:	f642 407c 	movw	r0, #11388	; 0x2c7c
   11da2:	f2c0 0002 	movt	r0, #2
   11da6:	2100      	movs	r1, #0
   11da8:	f7fe ed98 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11dac:	6823      	ldr	r3, [r4, #0]
   11dae:	4618      	mov	r0, r3
   11db0:	f242 21f8 	movw	r1, #8952	; 0x22f8
   11db4:	f2c0 0101 	movt	r1, #1
   11db8:	f7fe ed9c 	blx	108f4 <strcmp@plt>
   11dbc:	4603      	mov	r3, r0
   11dbe:	2b00      	cmp	r3, #0
   11dc0:	d103      	bne.n	11dca <main+0x52>
            fset = ISM_US;
   11dc2:	2301      	movs	r3, #1
   11dc4:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
   11dc8:	e03e      	b.n	11e48 <main+0xd0>
        else if (!strcmp(argv[1], "EU"))
   11dca:	463b      	mov	r3, r7
   11dcc:	681b      	ldr	r3, [r3, #0]
   11dce:	1d1c      	adds	r4, r3, #4
   11dd0:	2c00      	cmp	r4, #0
   11dd2:	d106      	bne.n	11de2 <main+0x6a>
   11dd4:	f642 4094 	movw	r0, #11412	; 0x2c94
   11dd8:	f2c0 0002 	movt	r0, #2
   11ddc:	2100      	movs	r1, #0
   11dde:	f7fe ed7e 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11de2:	6823      	ldr	r3, [r4, #0]
   11de4:	4618      	mov	r0, r3
   11de6:	f242 21fc 	movw	r1, #8956	; 0x22fc
   11dea:	f2c0 0101 	movt	r1, #1
   11dee:	f7fe ed82 	blx	108f4 <strcmp@plt>
   11df2:	4603      	mov	r3, r0
   11df4:	2b00      	cmp	r3, #0
   11df6:	d103      	bne.n	11e00 <main+0x88>
            fset = ISM_EU;
   11df8:	2300      	movs	r3, #0
   11dfa:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
   11dfe:	e023      	b.n	11e48 <main+0xd0>
        else if (!strcmp(argv[1], "LF"))
   11e00:	463b      	mov	r3, r7
   11e02:	681b      	ldr	r3, [r3, #0]
   11e04:	1d1c      	adds	r4, r3, #4
   11e06:	2c00      	cmp	r4, #0
   11e08:	d106      	bne.n	11e18 <main+0xa0>
   11e0a:	f642 40ac 	movw	r0, #11436	; 0x2cac
   11e0e:	f2c0 0002 	movt	r0, #2
   11e12:	2100      	movs	r1, #0
   11e14:	f7fe ed62 	blx	108dc <__ubsan_handle_type_mismatch@plt>
   11e18:	6823      	ldr	r3, [r4, #0]
   11e1a:	4618      	mov	r0, r3
   11e1c:	f242 3100 	movw	r1, #8960	; 0x2300
   11e20:	f2c0 0101 	movt	r1, #1
   11e24:	f7fe ed66 	blx	108f4 <strcmp@plt>
   11e28:	4603      	mov	r3, r0
   11e2a:	2b00      	cmp	r3, #0
   11e2c:	d103      	bne.n	11e36 <main+0xbe>
            fset = ISM_LF;
   11e2e:	2302      	movs	r3, #2
   11e30:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
   11e34:	e008      	b.n	11e48 <main+0xd0>
        else 
        {
            printf("Unspecified Band, defaulting to 902MHz/US band\n");
   11e36:	f242 3004 	movw	r0, #8964	; 0x2304
   11e3a:	f2c0 0001 	movt	r0, #1
   11e3e:	f7fe ed54 	blx	108e8 <puts@plt>
            fset = ISM_US;
   11e42:	2301      	movs	r3, #1
   11e44:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
        }
    }

    setup_io();
   11e48:	f7fe fdd0 	bl	109ec <setup_io>
    cfg_gpio();
   11e4c:	f7ff fb6e 	bl	1152c <cfg_gpio>
    fd = open_spi(SPI_DEVNAME);
   11e50:	f242 105c 	movw	r0, #8540	; 0x215c
   11e54:	f2c0 0001 	movt	r0, #1
   11e58:	f7fe fe30 	bl	10abc <open_spi>
   11e5c:	f8c7 0118 	str.w	r0, [r7, #280]	; 0x118
    default_spi_config(fd);
   11e60:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   11e64:	f7fe fe60 	bl	10b28 <default_spi_config>
    cc1101_initialize(fd, fset);
   11e68:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   11e6c:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
   11e70:	f7ff fe50 	bl	11b14 <cc1101_initialize>
    for( int i = 0; i < 0x3e; i++)
   11e74:	2300      	movs	r3, #0
   11e76:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
   11e7a:	e030      	b.n	11ede <main+0x166>
    printf("Reg %02x, Val %02x Status %02x\n", i, read_reg(fd, i, &status), status);
   11e7c:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   11e80:	b2da      	uxtb	r2, r3
   11e82:	f207 1311 	addw	r3, r7, #273	; 0x111
   11e86:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   11e8a:	4611      	mov	r1, r2
   11e8c:	461a      	mov	r2, r3
   11e8e:	f7ff fa17 	bl	112c0 <read_reg>
   11e92:	4603      	mov	r3, r0
   11e94:	461a      	mov	r2, r3
   11e96:	f897 3111 	ldrb.w	r3, [r7, #273]	; 0x111
   11e9a:	f242 3034 	movw	r0, #9012	; 0x2334
   11e9e:	f2c0 0001 	movt	r0, #1
   11ea2:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   11ea6:	f7fe ed08 	blx	108b8 <printf@plt>
    setup_io();
    cfg_gpio();
    fd = open_spi(SPI_DEVNAME);
    default_spi_config(fd);
    cc1101_initialize(fd, fset);
    for( int i = 0; i < 0x3e; i++)
   11eaa:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   11eae:	1c5c      	adds	r4, r3, #1
   11eb0:	2301      	movs	r3, #1
   11eb2:	2b00      	cmp	r3, #0
   11eb4:	db04      	blt.n	11ec0 <main+0x148>
   11eb6:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   11eba:	429c      	cmp	r4, r3
   11ebc:	da0d      	bge.n	11eda <main+0x162>
   11ebe:	e003      	b.n	11ec8 <main+0x150>
   11ec0:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   11ec4:	429c      	cmp	r4, r3
   11ec6:	dd08      	ble.n	11eda <main+0x162>
   11ec8:	f642 40c4 	movw	r0, #11460	; 0x2cc4
   11ecc:	f2c0 0002 	movt	r0, #2
   11ed0:	f8d7 1120 	ldr.w	r1, [r7, #288]	; 0x120
   11ed4:	2201      	movs	r2, #1
   11ed6:	f7fe ecea 	blx	108ac <__ubsan_handle_add_overflow@plt>
   11eda:	f8c7 4120 	str.w	r4, [r7, #288]	; 0x120
   11ede:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
   11ee2:	2b3d      	cmp	r3, #61	; 0x3d
   11ee4:	ddca      	ble.n	11e7c <main+0x104>
    printf("Reg %02x, Val %02x Status %02x\n", i, read_reg(fd, i, &status), status);
    rxon(fd);
   11ee6:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   11eea:	f7ff fe41 	bl	11b70 <rxon>
    while(1)
    {
        uint32_t len = 0;
   11eee:	2300      	movs	r3, #0
   11ef0:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
        if((len = CheckRx(fd)))
   11ef4:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   11ef8:	f7ff fea6 	bl	11c48 <CheckRx>
   11efc:	4603      	mov	r3, r0
   11efe:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
   11f02:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   11f06:	2b00      	cmp	r3, #0
   11f08:	d0f1      	beq.n	11eee <main+0x176>
        {
            uint32_t j = 0;
   11f0a:	2300      	movs	r3, #0
   11f0c:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
            uint8_t clqi = 0, rssi = 0;
   11f10:	2300      	movs	r3, #0
   11f12:	f887 3113 	strb.w	r3, [r7, #275]	; 0x113
   11f16:	2300      	movs	r3, #0
   11f18:	f887 3112 	strb.w	r3, [r7, #274]	; 0x112
            struct timespec now;
            clock_gettime(CLOCK_REALTIME, &now);
   11f1c:	f107 0308 	add.w	r3, r7, #8
   11f20:	2000      	movs	r0, #0
   11f22:	4619      	mov	r1, r3
   11f24:	f7fe ec86 	blx	10834 <clock_gettime@plt>
            printf("Time %ld.%09ld ", now.tv_sec, now.tv_nsec);
   11f28:	f107 0308 	add.w	r3, r7, #8
   11f2c:	681a      	ldr	r2, [r3, #0]
   11f2e:	f107 0308 	add.w	r3, r7, #8
   11f32:	685b      	ldr	r3, [r3, #4]
   11f34:	f242 3054 	movw	r0, #9044	; 0x2354
   11f38:	f2c0 0001 	movt	r0, #1
   11f3c:	4611      	mov	r1, r2
   11f3e:	461a      	mov	r2, r3
   11f40:	f7fe ecba 	blx	108b8 <printf@plt>
            printf("Len:%x ", len); 
   11f44:	f242 3064 	movw	r0, #9060	; 0x2364
   11f48:	f2c0 0001 	movt	r0, #1
   11f4c:	f8d7 1114 	ldr.w	r1, [r7, #276]	; 0x114
   11f50:	f7fe ecb2 	blx	108b8 <printf@plt>
            ReceivePkt(fd, pktbuf, len);
   11f54:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   11f58:	b2db      	uxtb	r3, r3
   11f5a:	f107 0210 	add.w	r2, r7, #16
   11f5e:	f8d7 0118 	ldr.w	r0, [r7, #280]	; 0x118
   11f62:	4611      	mov	r1, r2
   11f64:	461a      	mov	r2, r3
   11f66:	f7ff fee1 	bl	11d2c <ReceivePkt>
            clqi = pktbuf[pktbuf[0] + 2];
   11f6a:	f107 0310 	add.w	r3, r7, #16
   11f6e:	781b      	ldrb	r3, [r3, #0]
   11f70:	1c9c      	adds	r4, r3, #2
   11f72:	2202      	movs	r2, #2
   11f74:	2a00      	cmp	r2, #0
   11f76:	db02      	blt.n	11f7e <main+0x206>
   11f78:	429c      	cmp	r4, r3
   11f7a:	da0a      	bge.n	11f92 <main+0x21a>
   11f7c:	e001      	b.n	11f82 <main+0x20a>
   11f7e:	429c      	cmp	r4, r3
   11f80:	dd07      	ble.n	11f92 <main+0x21a>
   11f82:	f642 40d4 	movw	r0, #11476	; 0x2cd4
   11f86:	f2c0 0002 	movt	r0, #2
   11f8a:	4619      	mov	r1, r3
   11f8c:	2202      	movs	r2, #2
   11f8e:	f7fe ec8e 	blx	108ac <__ubsan_handle_add_overflow@plt>
   11f92:	4622      	mov	r2, r4
   11f94:	f107 0310 	add.w	r3, r7, #16
   11f98:	5c9b      	ldrb	r3, [r3, r2]
   11f9a:	f887 3113 	strb.w	r3, [r7, #275]	; 0x113
            rssi =  pktbuf[pktbuf[0] + 1];
   11f9e:	f107 0310 	add.w	r3, r7, #16
   11fa2:	781b      	ldrb	r3, [r3, #0]
   11fa4:	1c5c      	adds	r4, r3, #1
   11fa6:	2201      	movs	r2, #1
   11fa8:	2a00      	cmp	r2, #0
   11faa:	db02      	blt.n	11fb2 <main+0x23a>
   11fac:	429c      	cmp	r4, r3
   11fae:	da0a      	bge.n	11fc6 <main+0x24e>
   11fb0:	e001      	b.n	11fb6 <main+0x23e>
   11fb2:	429c      	cmp	r4, r3
   11fb4:	dd07      	ble.n	11fc6 <main+0x24e>
   11fb6:	f642 40e4 	movw	r0, #11492	; 0x2ce4
   11fba:	f2c0 0002 	movt	r0, #2
   11fbe:	4619      	mov	r1, r3
   11fc0:	2201      	movs	r2, #1
   11fc2:	f7fe ec74 	blx	108ac <__ubsan_handle_add_overflow@plt>
   11fc6:	4622      	mov	r2, r4
   11fc8:	f107 0310 	add.w	r3, r7, #16
   11fcc:	5c9b      	ldrb	r3, [r3, r2]
   11fce:	f887 3112 	strb.w	r3, [r7, #274]	; 0x112
            printf("RSSI:%02X LQI : %02X ", rssi, (clqi & 0x7f));
   11fd2:	f897 2112 	ldrb.w	r2, [r7, #274]	; 0x112
   11fd6:	f897 3113 	ldrb.w	r3, [r7, #275]	; 0x113
   11fda:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   11fde:	f242 306c 	movw	r0, #9068	; 0x236c
   11fe2:	f2c0 0001 	movt	r0, #1
   11fe6:	4611      	mov	r1, r2
   11fe8:	461a      	mov	r2, r3
   11fea:	f7fe ec66 	blx	108b8 <printf@plt>
            if (clqi & 0x80)
   11fee:	f897 3113 	ldrb.w	r3, [r7, #275]	; 0x113
   11ff2:	b25b      	sxtb	r3, r3
   11ff4:	2b00      	cmp	r3, #0
   11ff6:	da09      	bge.n	1200c <main+0x294>
                printf("CRC:OK\n");
   11ff8:	f242 3084 	movw	r0, #9092	; 0x2384
   11ffc:	f2c0 0001 	movt	r0, #1
   12000:	f7fe ec72 	blx	108e8 <puts@plt>
            else
            {
                printf("CRC:Fail\n");
                continue;
            }
            for (j = 0; j < len; j++)
   12004:	2300      	movs	r3, #0
   12006:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
   1200a:	e02d      	b.n	12068 <main+0x2f0>
            printf("RSSI:%02X LQI : %02X ", rssi, (clqi & 0x7f));
            if (clqi & 0x80)
                printf("CRC:OK\n");
            else
            {
                printf("CRC:Fail\n");
   1200c:	f242 308c 	movw	r0, #9100	; 0x238c
   12010:	f2c0 0001 	movt	r0, #1
   12014:	f7fe ec68 	blx	108e8 <puts@plt>
   12018:	e769      	b.n	11eee <main+0x176>
                continue;
            }
            for (j = 0; j < len; j++)
            {
                if ( (4*j + 1) % 80 == false)
   1201a:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   1201e:	009b      	lsls	r3, r3, #2
   12020:	1c59      	adds	r1, r3, #1
   12022:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   12026:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
   1202a:	fba1 2303 	umull	r2, r3, r1, r3
   1202e:	099a      	lsrs	r2, r3, #6
   12030:	4613      	mov	r3, r2
   12032:	009b      	lsls	r3, r3, #2
   12034:	4413      	add	r3, r2
   12036:	011b      	lsls	r3, r3, #4
   12038:	1aca      	subs	r2, r1, r3
   1203a:	2a00      	cmp	r2, #0
   1203c:	d102      	bne.n	12044 <main+0x2cc>
                    printf("\n");
   1203e:	200a      	movs	r0, #10
   12040:	f7fe ec04 	blx	1084c <putchar@plt>
                printf(" %02X ", pktbuf[j]);
   12044:	f107 0210 	add.w	r2, r7, #16
   12048:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   1204c:	4413      	add	r3, r2
   1204e:	781b      	ldrb	r3, [r3, #0]
   12050:	f242 3098 	movw	r0, #9112	; 0x2398
   12054:	f2c0 0001 	movt	r0, #1
   12058:	4619      	mov	r1, r3
   1205a:	f7fe ec2e 	blx	108b8 <printf@plt>
            else
            {
                printf("CRC:Fail\n");
                continue;
            }
            for (j = 0; j < len; j++)
   1205e:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
   12062:	3301      	adds	r3, #1
   12064:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
   12068:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
   1206c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   12070:	429a      	cmp	r2, r3
   12072:	d3d2      	bcc.n	1201a <main+0x2a2>
            {
                if ( (4*j + 1) % 80 == false)
                    printf("\n");
                printf(" %02X ", pktbuf[j]);
            }
            printf("\n");
   12074:	200a      	movs	r0, #10
   12076:	f7fe ebea 	blx	1084c <putchar@plt>
            fflush(stdout);
   1207a:	f642 43f4 	movw	r3, #11508	; 0x2cf4
   1207e:	f2c0 0302 	movt	r3, #2
   12082:	681b      	ldr	r3, [r3, #0]
   12084:	4618      	mov	r0, r3
   12086:	f7fe ec06 	blx	10894 <fflush@plt>
            //nanosleep(&sleepval, NULL);
        }
    }
   1208a:	e730      	b.n	11eee <main+0x176>

0001208c <__libc_csu_init>:
   1208c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12090:	4607      	mov	r7, r0
   12092:	4e0c      	ldr	r6, [pc, #48]	; (120c4 <__libc_csu_init+0x38>)
   12094:	4688      	mov	r8, r1
   12096:	4d0c      	ldr	r5, [pc, #48]	; (120c8 <__libc_csu_init+0x3c>)
   12098:	4691      	mov	r9, r2
   1209a:	447e      	add	r6, pc
   1209c:	f7fe eba2 	blx	107e4 <_init>
   120a0:	447d      	add	r5, pc
   120a2:	1b76      	subs	r6, r6, r5
   120a4:	10b6      	asrs	r6, r6, #2
   120a6:	d00a      	beq.n	120be <__libc_csu_init+0x32>
   120a8:	3d04      	subs	r5, #4
   120aa:	2400      	movs	r4, #0
   120ac:	3401      	adds	r4, #1
   120ae:	f855 3f04 	ldr.w	r3, [r5, #4]!
   120b2:	4638      	mov	r0, r7
   120b4:	4641      	mov	r1, r8
   120b6:	464a      	mov	r2, r9
   120b8:	4798      	blx	r3
   120ba:	42b4      	cmp	r4, r6
   120bc:	d1f6      	bne.n	120ac <__libc_csu_init+0x20>
   120be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   120c2:	bf00      	nop
   120c4:	0001032e 	.word	0x0001032e
   120c8:	00010324 	.word	0x00010324

000120cc <__libc_csu_fini>:
   120cc:	4770      	bx	lr
   120ce:	bf00      	nop

Disassembly of section .fini:

000120d0 <_fini>:
   120d0:	e92d4008 	push	{r3, lr}
   120d4:	e8bd8008 	pop	{r3, pc}
