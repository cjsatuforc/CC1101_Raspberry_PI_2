
timesync:     file format elf32-littlearm


Disassembly of section .init:

00010874 <_init>:
   10874:	e92d4008 	push	{r3, lr}
   10878:	eb00005c 	bl	109f0 <call_weak_fn>
   1087c:	e8bd8008 	pop	{r3, pc}

Disassembly of section .plt:

00010880 <open@plt-0x14>:
   10880:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
   10884:	e59fe004 	ldr	lr, [pc, #4]	; 10890 <_init+0x1c>
   10888:	e08fe00e 	add	lr, pc, lr
   1088c:	e5bef008 	ldr	pc, [lr, #8]!
   10890:	000122b0 	.word	0x000122b0

00010894 <open@plt>:
   10894:	e28fc600 	add	ip, pc, #0, 12
   10898:	e28cca12 	add	ip, ip, #73728	; 0x12000
   1089c:	e5bcf2b0 	ldr	pc, [ip, #688]!	; 0x2b0

000108a0 <mmap@plt>:
   108a0:	e28fc600 	add	ip, pc, #0, 12
   108a4:	e28cca12 	add	ip, ip, #73728	; 0x12000
   108a8:	e5bcf2a8 	ldr	pc, [ip, #680]!	; 0x2a8

000108ac <abort@plt>:
   108ac:	e28fc600 	add	ip, pc, #0, 12
   108b0:	e28cca12 	add	ip, ip, #73728	; 0x12000
   108b4:	e5bcf2a0 	ldr	pc, [ip, #672]!	; 0x2a0

000108b8 <memcmp@plt>:
   108b8:	e28fc600 	add	ip, pc, #0, 12
   108bc:	e28cca12 	add	ip, ip, #73728	; 0x12000
   108c0:	e5bcf298 	ldr	pc, [ip, #664]!	; 0x298

000108c4 <__libc_start_main@plt>:
   108c4:	e28fc600 	add	ip, pc, #0, 12
   108c8:	e28cca12 	add	ip, ip, #73728	; 0x12000
   108cc:	e5bcf290 	ldr	pc, [ip, #656]!	; 0x290

000108d0 <clock_gettime@plt>:
   108d0:	e28fc600 	add	ip, pc, #0, 12
   108d4:	e28cca12 	add	ip, ip, #73728	; 0x12000
   108d8:	e5bcf288 	ldr	pc, [ip, #648]!	; 0x288

000108dc <__gmon_start__@plt>:
   108dc:	e28fc600 	add	ip, pc, #0, 12
   108e0:	e28cca12 	add	ip, ip, #73728	; 0x12000
   108e4:	e5bcf280 	ldr	pc, [ip, #640]!	; 0x280

000108e8 <putchar@plt>:
   108e8:	e28fc600 	add	ip, pc, #0, 12
   108ec:	e28cca12 	add	ip, ip, #73728	; 0x12000
   108f0:	e5bcf278 	ldr	pc, [ip, #632]!	; 0x278

000108f4 <calloc@plt>:
   108f4:	e28fc600 	add	ip, pc, #0, 12
   108f8:	e28cca12 	add	ip, ip, #73728	; 0x12000
   108fc:	e5bcf270 	ldr	pc, [ip, #624]!	; 0x270

00010900 <memset@plt>:
   10900:	e28fc600 	add	ip, pc, #0, 12
   10904:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10908:	e5bcf268 	ldr	pc, [ip, #616]!	; 0x268

0001090c <perror@plt>:
   1090c:	e28fc600 	add	ip, pc, #0, 12
   10910:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10914:	e5bcf260 	ldr	pc, [ip, #608]!	; 0x260

00010918 <__assert_fail@plt>:
   10918:	e28fc600 	add	ip, pc, #0, 12
   1091c:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10920:	e5bcf258 	ldr	pc, [ip, #600]!	; 0x258

00010924 <free@plt>:
   10924:	e28fc600 	add	ip, pc, #0, 12
   10928:	e28cca12 	add	ip, ip, #73728	; 0x12000
   1092c:	e5bcf250 	ldr	pc, [ip, #592]!	; 0x250

00010930 <fflush@plt>:
   10930:	e28fc600 	add	ip, pc, #0, 12
   10934:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10938:	e5bcf248 	ldr	pc, [ip, #584]!	; 0x248

0001093c <ioctl@plt>:
   1093c:	e28fc600 	add	ip, pc, #0, 12
   10940:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10944:	e5bcf240 	ldr	pc, [ip, #576]!	; 0x240

00010948 <__ubsan_handle_add_overflow@plt>:
   10948:	e28fc600 	add	ip, pc, #0, 12
   1094c:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10950:	e5bcf238 	ldr	pc, [ip, #568]!	; 0x238

00010954 <printf@plt>:
   10954:	e28fc600 	add	ip, pc, #0, 12
   10958:	e28cca12 	add	ip, ip, #73728	; 0x12000
   1095c:	e5bcf230 	ldr	pc, [ip, #560]!	; 0x230

00010960 <__ubsan_handle_shift_out_of_bounds@plt>:
   10960:	e28fc600 	add	ip, pc, #0, 12
   10964:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10968:	e5bcf228 	ldr	pc, [ip, #552]!	; 0x228

0001096c <close@plt>:
   1096c:	e28fc600 	add	ip, pc, #0, 12
   10970:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10974:	e5bcf220 	ldr	pc, [ip, #544]!	; 0x220

00010978 <malloc@plt>:
   10978:	e28fc600 	add	ip, pc, #0, 12
   1097c:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10980:	e5bcf218 	ldr	pc, [ip, #536]!	; 0x218

00010984 <__ubsan_handle_type_mismatch@plt>:
   10984:	e28fc600 	add	ip, pc, #0, 12
   10988:	e28cca12 	add	ip, ip, #73728	; 0x12000
   1098c:	e5bcf210 	ldr	pc, [ip, #528]!	; 0x210

00010990 <puts@plt>:
   10990:	e28fc600 	add	ip, pc, #0, 12
   10994:	e28cca12 	add	ip, ip, #73728	; 0x12000
   10998:	e5bcf208 	ldr	pc, [ip, #520]!	; 0x208

0001099c <nanosleep@plt>:
   1099c:	e28fc600 	add	ip, pc, #0, 12
   109a0:	e28cca12 	add	ip, ip, #73728	; 0x12000
   109a4:	e5bcf200 	ldr	pc, [ip, #512]!	; 0x200

000109a8 <strcmp@plt>:
   109a8:	e28fc600 	add	ip, pc, #0, 12
   109ac:	e28cca12 	add	ip, ip, #73728	; 0x12000
   109b0:	e5bcf1f8 	ldr	pc, [ip, #504]!	; 0x1f8

000109b4 <exit@plt>:
   109b4:	e28fc600 	add	ip, pc, #0, 12
   109b8:	e28cca12 	add	ip, ip, #73728	; 0x12000
   109bc:	e5bcf1f0 	ldr	pc, [ip, #496]!	; 0x1f0

Disassembly of section .text:

000109c0 <_start>:
   109c0:	f04f 0b00 	mov.w	fp, #0
   109c4:	f04f 0e00 	mov.w	lr, #0
   109c8:	bc02      	pop	{r1}
   109ca:	466a      	mov	r2, sp
   109cc:	b404      	push	{r2}
   109ce:	b401      	push	{r0}
   109d0:	f8df c010 	ldr.w	ip, [pc, #16]	; 109e4 <_start+0x24>
   109d4:	f84d cd04 	str.w	ip, [sp, #-4]!
   109d8:	4803      	ldr	r0, [pc, #12]	; (109e8 <_start+0x28>)
   109da:	4b04      	ldr	r3, [pc, #16]	; (109ec <_start+0x2c>)
   109dc:	f7ff ef72 	blx	108c4 <__libc_start_main@plt>
   109e0:	f7ff ef64 	blx	108ac <abort@plt>
   109e4:	000126b1 	.word	0x000126b1
   109e8:	00012521 	.word	0x00012521
   109ec:	00012671 	.word	0x00012671

000109f0 <call_weak_fn>:
   109f0:	e59f3014 	ldr	r3, [pc, #20]	; 10a0c <call_weak_fn+0x1c>
   109f4:	e59f2014 	ldr	r2, [pc, #20]	; 10a10 <call_weak_fn+0x20>
   109f8:	e08f3003 	add	r3, pc, r3
   109fc:	e7932002 	ldr	r2, [r3, r2]
   10a00:	e3520000 	cmp	r2, #0
   10a04:	012fff1e 	bxeq	lr
   10a08:	eaffffb3 	b	108dc <__gmon_start__@plt>
   10a0c:	00012140 	.word	0x00012140
   10a10:	00000070 	.word	0x00000070

00010a14 <deregister_tm_clones>:
   10a14:	4b07      	ldr	r3, [pc, #28]	; (10a34 <deregister_tm_clones+0x20>)
   10a16:	f649 504c 	movw	r0, #40268	; 0x9d4c
   10a1a:	f2c0 0002 	movt	r0, #2
   10a1e:	1a1b      	subs	r3, r3, r0
   10a20:	2b06      	cmp	r3, #6
   10a22:	d905      	bls.n	10a30 <deregister_tm_clones+0x1c>
   10a24:	f240 0300 	movw	r3, #0
   10a28:	f2c0 0300 	movt	r3, #0
   10a2c:	b103      	cbz	r3, 10a30 <deregister_tm_clones+0x1c>
   10a2e:	4718      	bx	r3
   10a30:	4770      	bx	lr
   10a32:	bf00      	nop
   10a34:	00029d4f 	.word	0x00029d4f

00010a38 <register_tm_clones>:
   10a38:	f649 534c 	movw	r3, #40268	; 0x9d4c
   10a3c:	f649 504c 	movw	r0, #40268	; 0x9d4c
   10a40:	f2c0 0302 	movt	r3, #2
   10a44:	f2c0 0002 	movt	r0, #2
   10a48:	1a19      	subs	r1, r3, r0
   10a4a:	1089      	asrs	r1, r1, #2
   10a4c:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
   10a50:	1049      	asrs	r1, r1, #1
   10a52:	d005      	beq.n	10a60 <register_tm_clones+0x28>
   10a54:	f240 0300 	movw	r3, #0
   10a58:	f2c0 0300 	movt	r3, #0
   10a5c:	b103      	cbz	r3, 10a60 <register_tm_clones+0x28>
   10a5e:	4718      	bx	r3
   10a60:	4770      	bx	lr
   10a62:	bf00      	nop

00010a64 <__do_global_dtors_aux>:
   10a64:	b510      	push	{r4, lr}
   10a66:	f649 5450 	movw	r4, #40272	; 0x9d50
   10a6a:	f2c0 0402 	movt	r4, #2
   10a6e:	7823      	ldrb	r3, [r4, #0]
   10a70:	b91b      	cbnz	r3, 10a7a <__do_global_dtors_aux+0x16>
   10a72:	f7ff ffcf 	bl	10a14 <deregister_tm_clones>
   10a76:	2301      	movs	r3, #1
   10a78:	7023      	strb	r3, [r4, #0]
   10a7a:	bd10      	pop	{r4, pc}

00010a7c <frame_dummy>:
   10a7c:	f642 2034 	movw	r0, #10804	; 0x2a34
   10a80:	b508      	push	{r3, lr}
   10a82:	f2c0 0002 	movt	r0, #2
   10a86:	6803      	ldr	r3, [r0, #0]
   10a88:	b913      	cbnz	r3, 10a90 <frame_dummy+0x14>
   10a8a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   10a8e:	e7d3      	b.n	10a38 <register_tm_clones>
   10a90:	f240 0300 	movw	r3, #0
   10a94:	f2c0 0300 	movt	r3, #0
   10a98:	2b00      	cmp	r3, #0
   10a9a:	d0f6      	beq.n	10a8a <frame_dummy+0xe>
   10a9c:	4798      	blx	r3
   10a9e:	e7f4      	b.n	10a8a <frame_dummy+0xe>

00010aa0 <setup_io>:
void setup_io();
 
 
 
void setup_io()
{
   10aa0:	b580      	push	{r7, lr}
   10aa2:	b082      	sub	sp, #8
   10aa4:	af02      	add	r7, sp, #8
   /* open /dev/mem */
   if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
   10aa6:	f242 700c 	movw	r0, #9996	; 0x270c
   10aaa:	f2c0 0001 	movt	r0, #1
   10aae:	f241 0102 	movw	r1, #4098	; 0x1002
   10ab2:	f2c0 0110 	movt	r1, #16
   10ab6:	f7ff eeee 	blx	10894 <open@plt>
   10aba:	4602      	mov	r2, r0
   10abc:	f649 5354 	movw	r3, #40276	; 0x9d54
   10ac0:	f2c0 0302 	movt	r3, #2
   10ac4:	601a      	str	r2, [r3, #0]
   10ac6:	f649 5354 	movw	r3, #40276	; 0x9d54
   10aca:	f2c0 0302 	movt	r3, #2
   10ace:	681b      	ldr	r3, [r3, #0]
   10ad0:	2b00      	cmp	r3, #0
   10ad2:	da09      	bge.n	10ae8 <setup_io+0x48>
      printf("can't open /dev/mem \n");
   10ad4:	f242 7018 	movw	r0, #10008	; 0x2718
   10ad8:	f2c0 0001 	movt	r0, #1
   10adc:	f7ff ef58 	blx	10990 <puts@plt>
      exit(-1);
   10ae0:	f04f 30ff 	mov.w	r0, #4294967295
   10ae4:	f7ff ef66 	blx	109b4 <exit@plt>
   }
 
   /* mmap GPIO */
   gpio_map = mmap(
   10ae8:	f649 5354 	movw	r3, #40276	; 0x9d54
   10aec:	f2c0 0302 	movt	r3, #2
   10af0:	681b      	ldr	r3, [r3, #0]
   10af2:	9300      	str	r3, [sp, #0]
   10af4:	2300      	movs	r3, #0
   10af6:	f6c3 7320 	movt	r3, #16160	; 0x3f20
   10afa:	9301      	str	r3, [sp, #4]
   10afc:	2000      	movs	r0, #0
   10afe:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   10b02:	2203      	movs	r2, #3
   10b04:	2301      	movs	r3, #1
   10b06:	f7ff eecc 	blx	108a0 <mmap@plt>
   10b0a:	4602      	mov	r2, r0
   10b0c:	f649 535c 	movw	r3, #40284	; 0x9d5c
   10b10:	f2c0 0302 	movt	r3, #2
   10b14:	601a      	str	r2, [r3, #0]
      MAP_SHARED,       //Shared with other processes
      mem_fd,           //File to map
      GPIO_BASE         //Offset to GPIO peripheral
   );
 
   close(mem_fd); //No need to keep mem_fd open after mmap
   10b16:	f649 5354 	movw	r3, #40276	; 0x9d54
   10b1a:	f2c0 0302 	movt	r3, #2
   10b1e:	681b      	ldr	r3, [r3, #0]
   10b20:	4618      	mov	r0, r3
   10b22:	f7ff ef24 	blx	1096c <close@plt>
 
   if (gpio_map == MAP_FAILED) {
   10b26:	f649 535c 	movw	r3, #40284	; 0x9d5c
   10b2a:	f2c0 0302 	movt	r3, #2
   10b2e:	681b      	ldr	r3, [r3, #0]
   10b30:	f1b3 3fff 	cmp.w	r3, #4294967295
   10b34:	d10f      	bne.n	10b56 <setup_io+0xb6>
      printf("mmap error %d\n", (int)gpio_map);//errno also set!
   10b36:	f649 535c 	movw	r3, #40284	; 0x9d5c
   10b3a:	f2c0 0302 	movt	r3, #2
   10b3e:	681b      	ldr	r3, [r3, #0]
   10b40:	f242 7030 	movw	r0, #10032	; 0x2730
   10b44:	f2c0 0001 	movt	r0, #1
   10b48:	4619      	mov	r1, r3
   10b4a:	f7ff ef04 	blx	10954 <printf@plt>
      exit(-1);
   10b4e:	f04f 30ff 	mov.w	r0, #4294967295
   10b52:	f7ff ef30 	blx	109b4 <exit@plt>
   }
 
   // Always use volatile pointer!
   gpio = (volatile unsigned *)gpio_map;
   10b56:	f649 535c 	movw	r3, #40284	; 0x9d5c
   10b5a:	f2c0 0302 	movt	r3, #2
   10b5e:	681a      	ldr	r2, [r3, #0]
   10b60:	f649 6360 	movw	r3, #40544	; 0x9e60
   10b64:	f2c0 0302 	movt	r3, #2
   10b68:	601a      	str	r2, [r3, #0]
 
 
} // setup_io
   10b6a:	46bd      	mov	sp, r7
   10b6c:	bd80      	pop	{r7, pc}
   10b6e:	bf00      	nop

00010b70 <open_spi>:

const char *spi_dev_name = SPI_DEVNAME;

int open_spi(const char *devname)
{
   10b70:	b580      	push	{r7, lr}
   10b72:	b084      	sub	sp, #16
   10b74:	af00      	add	r7, sp, #0
   10b76:	6078      	str	r0, [r7, #4]
    int fd = open(devname, O_RDWR);
   10b78:	6878      	ldr	r0, [r7, #4]
   10b7a:	2102      	movs	r1, #2
   10b7c:	f7ff ee8a 	blx	10894 <open@plt>
   10b80:	60f8      	str	r0, [r7, #12]
    if (fd < 0)
   10b82:	68fb      	ldr	r3, [r7, #12]
   10b84:	2b00      	cmp	r3, #0
   10b86:	da09      	bge.n	10b9c <open_spi+0x2c>
    {
        perror("Open Failed\n");
   10b88:	f242 7050 	movw	r0, #10064	; 0x2750
   10b8c:	f2c0 0001 	movt	r0, #1
   10b90:	f7ff eebc 	blx	1090c <perror@plt>
        exit(-1);
   10b94:	f04f 30ff 	mov.w	r0, #4294967295
   10b98:	f7ff ef0c 	blx	109b4 <exit@plt>
    }
    return fd;
   10b9c:	68fb      	ldr	r3, [r7, #12]
}
   10b9e:	4618      	mov	r0, r3
   10ba0:	3710      	adds	r7, #16
   10ba2:	46bd      	mov	sp, r7
   10ba4:	bd80      	pop	{r7, pc}
   10ba6:	bf00      	nop

00010ba8 <close_spi>:

int close_spi(int fd)
{
   10ba8:	b580      	push	{r7, lr}
   10baa:	b082      	sub	sp, #8
   10bac:	af00      	add	r7, sp, #0
   10bae:	6078      	str	r0, [r7, #4]
    if (close(fd))
   10bb0:	6878      	ldr	r0, [r7, #4]
   10bb2:	f7ff eedc 	blx	1096c <close@plt>
   10bb6:	4603      	mov	r3, r0
   10bb8:	2b00      	cmp	r3, #0
   10bba:	d009      	beq.n	10bd0 <close_spi+0x28>
    {
        perror("Close Failed\n");
   10bbc:	f242 7060 	movw	r0, #10080	; 0x2760
   10bc0:	f2c0 0001 	movt	r0, #1
   10bc4:	f7ff eea2 	blx	1090c <perror@plt>
        exit(-1);
   10bc8:	f04f 30ff 	mov.w	r0, #4294967295
   10bcc:	f7ff eef2 	blx	109b4 <exit@plt>
    }
    return 0;
   10bd0:	2300      	movs	r3, #0
}
   10bd2:	4618      	mov	r0, r3
   10bd4:	3708      	adds	r7, #8
   10bd6:	46bd      	mov	sp, r7
   10bd8:	bd80      	pop	{r7, pc}
   10bda:	bf00      	nop

00010bdc <default_spi_config>:

void default_spi_config(int fd)
{
   10bdc:	b580      	push	{r7, lr}
   10bde:	b084      	sub	sp, #16
   10be0:	af00      	add	r7, sp, #0
   10be2:	6078      	str	r0, [r7, #4]
    int x; 
    x = SPI_MODE_0;
   10be4:	2300      	movs	r3, #0
   10be6:	60fb      	str	r3, [r7, #12]
    if(ioctl(fd, SPI_IOC_WR_MODE, &x))
   10be8:	f107 030c 	add.w	r3, r7, #12
   10bec:	6878      	ldr	r0, [r7, #4]
   10bee:	f646 3101 	movw	r1, #27393	; 0x6b01
   10bf2:	f2c4 0101 	movt	r1, #16385	; 0x4001
   10bf6:	461a      	mov	r2, r3
   10bf8:	f7ff eea0 	blx	1093c <ioctl@plt>
   10bfc:	4603      	mov	r3, r0
   10bfe:	2b00      	cmp	r3, #0
   10c00:	d005      	beq.n	10c0e <default_spi_config+0x32>
    {
        perror("Failed to set mode to SPI_MODE_0");
   10c02:	f242 7070 	movw	r0, #10096	; 0x2770
   10c06:	f2c0 0001 	movt	r0, #1
   10c0a:	f7ff ee80 	blx	1090c <perror@plt>
    }
    x = SPI_SPEED;
   10c0e:	f644 3340 	movw	r3, #19264	; 0x4b40
   10c12:	f2c0 034c 	movt	r3, #76	; 0x4c
   10c16:	60fb      	str	r3, [r7, #12]
    if(ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &x))
   10c18:	f107 030c 	add.w	r3, r7, #12
   10c1c:	6878      	ldr	r0, [r7, #4]
   10c1e:	f646 3104 	movw	r1, #27396	; 0x6b04
   10c22:	f2c4 0104 	movt	r1, #16388	; 0x4004
   10c26:	461a      	mov	r2, r3
   10c28:	f7ff ee88 	blx	1093c <ioctl@plt>
   10c2c:	4603      	mov	r3, r0
   10c2e:	2b00      	cmp	r3, #0
   10c30:	d005      	beq.n	10c3e <default_spi_config+0x62>
    {
        perror("Failed to set speed");
   10c32:	f242 7094 	movw	r0, #10132	; 0x2794
   10c36:	f2c0 0001 	movt	r0, #1
   10c3a:	f7ff ee68 	blx	1090c <perror@plt>
    }
    x = 8;  
   10c3e:	2308      	movs	r3, #8
   10c40:	60fb      	str	r3, [r7, #12]
    if(ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &x))
   10c42:	f107 030c 	add.w	r3, r7, #12
   10c46:	6878      	ldr	r0, [r7, #4]
   10c48:	f646 3103 	movw	r1, #27395	; 0x6b03
   10c4c:	f2c4 0101 	movt	r1, #16385	; 0x4001
   10c50:	461a      	mov	r2, r3
   10c52:	f7ff ee74 	blx	1093c <ioctl@plt>
   10c56:	4603      	mov	r3, r0
   10c58:	2b00      	cmp	r3, #0
   10c5a:	d006      	beq.n	10c6a <default_spi_config+0x8e>
    {
        perror("Failed to set bpw");
   10c5c:	f242 70a8 	movw	r0, #10152	; 0x27a8
   10c60:	f2c0 0001 	movt	r0, #1
   10c64:	f7ff ee52 	blx	1090c <perror@plt>
   10c68:	e01b      	b.n	10ca2 <default_spi_config+0xc6>
    }
    else if(ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &x))
   10c6a:	f107 030c 	add.w	r3, r7, #12
   10c6e:	6878      	ldr	r0, [r7, #4]
   10c70:	f646 3103 	movw	r1, #27395	; 0x6b03
   10c74:	f2c8 0101 	movt	r1, #32769	; 0x8001
   10c78:	461a      	mov	r2, r3
   10c7a:	f7ff ee60 	blx	1093c <ioctl@plt>
   10c7e:	4603      	mov	r3, r0
   10c80:	2b00      	cmp	r3, #0
   10c82:	d006      	beq.n	10c92 <default_spi_config+0xb6>
    {
        perror("Failed to get bwp");
   10c84:	f242 70bc 	movw	r0, #10172	; 0x27bc
   10c88:	f2c0 0001 	movt	r0, #1
   10c8c:	f7ff ee3e 	blx	1090c <perror@plt>
   10c90:	e007      	b.n	10ca2 <default_spi_config+0xc6>
    }
    else
    {
        printf("BPW: %d\n", x);
   10c92:	68fb      	ldr	r3, [r7, #12]
   10c94:	f242 70d0 	movw	r0, #10192	; 0x27d0
   10c98:	f2c0 0001 	movt	r0, #1
   10c9c:	4619      	mov	r1, r3
   10c9e:	f7ff ee5a 	blx	10954 <printf@plt>
    }
}
   10ca2:	3710      	adds	r7, #16
   10ca4:	46bd      	mov	sp, r7
   10ca6:	bd80      	pop	{r7, pc}

00010ca8 <write_reg>:
#define READ_CMD_BIT (1<<7)
#define BURST_CMD_BIT (1<<6)


void write_reg(int fd, uint8_t addr, uint8_t value, uint8_t *response)
{
   10ca8:	b5b0      	push	{r4, r5, r7, lr}
   10caa:	b090      	sub	sp, #64	; 0x40
   10cac:	af00      	add	r7, sp, #0
   10cae:	60f8      	str	r0, [r7, #12]
   10cb0:	607b      	str	r3, [r7, #4]
   10cb2:	460b      	mov	r3, r1
   10cb4:	72fb      	strb	r3, [r7, #11]
   10cb6:	4613      	mov	r3, r2
   10cb8:	72bb      	strb	r3, [r7, #10]
    int ret;
    struct spi_ioc_transfer tr;
    #define N_RESP_BYTES (2) 
    uint8_t *wr, *rd;
    wr = malloc(N_RESP_BYTES);
   10cba:	2002      	movs	r0, #2
   10cbc:	f7ff ee5c 	blx	10978 <malloc@plt>
   10cc0:	4603      	mov	r3, r0
   10cc2:	63fb      	str	r3, [r7, #60]	; 0x3c
    rd = malloc(N_RESP_BYTES);
   10cc4:	2002      	movs	r0, #2
   10cc6:	f7ff ee58 	blx	10978 <malloc@plt>
   10cca:	4603      	mov	r3, r0
   10ccc:	63bb      	str	r3, [r7, #56]	; 0x38
    memset(&tr, 0, sizeof(tr));
   10cce:	f107 0310 	add.w	r3, r7, #16
   10cd2:	4618      	mov	r0, r3
   10cd4:	2100      	movs	r1, #0
   10cd6:	2220      	movs	r2, #32
   10cd8:	f7ff ee12 	blx	10900 <memset@plt>
    memset(wr, 0, 10);
   10cdc:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   10cde:	2100      	movs	r1, #0
   10ce0:	220a      	movs	r2, #10
   10ce2:	f7ff ee0e 	blx	10900 <memset@plt>
    memset(rd, 0, 10);
   10ce6:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   10ce8:	2100      	movs	r1, #0
   10cea:	220a      	movs	r2, #10
   10cec:	f7ff ee08 	blx	10900 <memset@plt>

    wr[0] = (addr);
   10cf0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10cf2:	2b00      	cmp	r3, #0
   10cf4:	d106      	bne.n	10d04 <write_reg+0x5c>
   10cf6:	f249 30b4 	movw	r0, #37812	; 0x93b4
   10cfa:	f2c0 0002 	movt	r0, #2
   10cfe:	2100      	movs	r1, #0
   10d00:	f7ff ee40 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10d04:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10d06:	7afa      	ldrb	r2, [r7, #11]
   10d08:	701a      	strb	r2, [r3, #0]
    wr[1] = value;
   10d0a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10d0c:	1c5c      	adds	r4, r3, #1
   10d0e:	2c00      	cmp	r4, #0
   10d10:	d106      	bne.n	10d20 <write_reg+0x78>
   10d12:	f249 30cc 	movw	r0, #37836	; 0x93cc
   10d16:	f2c0 0002 	movt	r0, #2
   10d1a:	2100      	movs	r1, #0
   10d1c:	f7ff ee32 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10d20:	7abb      	ldrb	r3, [r7, #10]
   10d22:	7023      	strb	r3, [r4, #0]

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   10d24:	f649 6360 	movw	r3, #40544	; 0x9e60
   10d28:	f2c0 0302 	movt	r3, #2
   10d2c:	681b      	ldr	r3, [r3, #0]
   10d2e:	f103 0428 	add.w	r4, r3, #40	; 0x28
   10d32:	2c00      	cmp	r4, #0
   10d34:	d106      	bne.n	10d44 <write_reg+0x9c>
   10d36:	f249 4000 	movw	r0, #37888	; 0x9400
   10d3a:	f2c0 0002 	movt	r0, #2
   10d3e:	2100      	movs	r1, #0
   10d40:	f7ff ee20 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10d44:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   10d48:	6023      	str	r3, [r4, #0]
    while(GET_GPIO(GPIO_RDY))
   10d4a:	e01b      	b.n	10d84 <write_reg+0xdc>
    {
        int i = 0;
   10d4c:	2300      	movs	r3, #0
   10d4e:	637b      	str	r3, [r7, #52]	; 0x34
        printf("Waiting for Chiprdy ....%d\n", i++);
   10d50:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   10d52:	1c65      	adds	r5, r4, #1
   10d54:	2301      	movs	r3, #1
   10d56:	2b00      	cmp	r3, #0
   10d58:	db02      	blt.n	10d60 <write_reg+0xb8>
   10d5a:	42a5      	cmp	r5, r4
   10d5c:	da0a      	bge.n	10d74 <write_reg+0xcc>
   10d5e:	e001      	b.n	10d64 <write_reg+0xbc>
   10d60:	42a5      	cmp	r5, r4
   10d62:	dd07      	ble.n	10d74 <write_reg+0xcc>
   10d64:	f249 4078 	movw	r0, #38008	; 0x9478
   10d68:	f2c0 0002 	movt	r0, #2
   10d6c:	4621      	mov	r1, r4
   10d6e:	2201      	movs	r2, #1
   10d70:	f7ff edea 	blx	10948 <__ubsan_handle_add_overflow@plt>
   10d74:	637d      	str	r5, [r7, #52]	; 0x34
   10d76:	f242 70e8 	movw	r0, #10216	; 0x27e8
   10d7a:	f2c0 0001 	movt	r0, #1
   10d7e:	4621      	mov	r1, r4
   10d80:	f7ff ede8 	blx	10954 <printf@plt>

    wr[0] = (addr);
    wr[1] = value;

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
    while(GET_GPIO(GPIO_RDY))
   10d84:	f649 6360 	movw	r3, #40544	; 0x9e60
   10d88:	f2c0 0302 	movt	r3, #2
   10d8c:	681b      	ldr	r3, [r3, #0]
   10d8e:	f103 0434 	add.w	r4, r3, #52	; 0x34
   10d92:	2c00      	cmp	r4, #0
   10d94:	d106      	bne.n	10da4 <write_reg+0xfc>
   10d96:	f249 4018 	movw	r0, #37912	; 0x9418
   10d9a:	f2c0 0002 	movt	r0, #2
   10d9e:	2100      	movs	r1, #0
   10da0:	f7ff edf0 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10da4:	6823      	ldr	r3, [r4, #0]
   10da6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   10daa:	2b00      	cmp	r3, #0
   10dac:	d1ce      	bne.n	10d4c <write_reg+0xa4>
        printf("Waiting for Chiprdy ....%d\n", i++);
    }
#if 0
    printf("Writing %02x val %02x\n", addr, value);
#endif
    tr.tx_buf = (unsigned long) wr;
   10dae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10db0:	461a      	mov	r2, r3
   10db2:	f04f 0300 	mov.w	r3, #0
   10db6:	e9c7 2304 	strd	r2, r3, [r7, #16]
    tr.rx_buf = (unsigned long) rd;
   10dba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10dbc:	461a      	mov	r2, r3
   10dbe:	f04f 0300 	mov.w	r3, #0
   10dc2:	e9c7 2306 	strd	r2, r3, [r7, #24]
    tr.len = N_RESP_BYTES;
   10dc6:	2302      	movs	r3, #2
   10dc8:	623b      	str	r3, [r7, #32]
    tr.delay_usecs = 90;
   10dca:	235a      	movs	r3, #90	; 0x5a
   10dcc:	853b      	strh	r3, [r7, #40]	; 0x28
    tr.speed_hz = SPI_SPEED;
   10dce:	f644 3340 	movw	r3, #19264	; 0x4b40
   10dd2:	f2c0 034c 	movt	r3, #76	; 0x4c
   10dd6:	627b      	str	r3, [r7, #36]	; 0x24
    tr.bits_per_word = 8;
   10dd8:	2308      	movs	r3, #8
   10dda:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    tr.cs_change = 0;
   10dde:	2300      	movs	r3, #0
   10de0:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
   10de4:	f107 0310 	add.w	r3, r7, #16
   10de8:	68f8      	ldr	r0, [r7, #12]
   10dea:	f44f 41d6 	mov.w	r1, #27392	; 0x6b00
   10dee:	f2c4 0120 	movt	r1, #16416	; 0x4020
   10df2:	461a      	mov	r2, r3
   10df4:	f7ff eda2 	blx	1093c <ioctl@plt>
   10df8:	6338      	str	r0, [r7, #48]	; 0x30
    if (ret < 1)
   10dfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10dfc:	2b00      	cmp	r3, #0
   10dfe:	dc05      	bgt.n	10e0c <write_reg+0x164>
        perror("can't send spi message");
   10e00:	f642 0004 	movw	r0, #10244	; 0x2804
   10e04:	f2c0 0001 	movt	r0, #1
   10e08:	f7ff ed80 	blx	1090c <perror@plt>
#if 0
    for (ret = 0; ret < tr.len; ret++) {
        printf("..%02X.. ", rd[ret]);
    }
#endif
    if (response)
   10e0c:	687b      	ldr	r3, [r7, #4]
   10e0e:	2b00      	cmp	r3, #0
   10e10:	d018      	beq.n	10e44 <write_reg+0x19c>
        response[0] = rd[1];
   10e12:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10e14:	2b00      	cmp	r3, #0
   10e16:	d106      	bne.n	10e26 <write_reg+0x17e>
   10e18:	f249 4030 	movw	r0, #37936	; 0x9430
   10e1c:	f2c0 0002 	movt	r0, #2
   10e20:	2100      	movs	r1, #0
   10e22:	f7ff edb0 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10e26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10e28:	785c      	ldrb	r4, [r3, #1]
   10e2a:	687b      	ldr	r3, [r7, #4]
   10e2c:	2b00      	cmp	r3, #0
   10e2e:	d106      	bne.n	10e3e <write_reg+0x196>
   10e30:	f249 4048 	movw	r0, #37960	; 0x9448
   10e34:	f2c0 0002 	movt	r0, #2
   10e38:	2100      	movs	r1, #0
   10e3a:	f7ff eda4 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10e3e:	687b      	ldr	r3, [r7, #4]
   10e40:	4622      	mov	r2, r4
   10e42:	701a      	strb	r2, [r3, #0]
    GPIO_SET = 1 << (GPIO_CHIP_SEL);
   10e44:	f649 6360 	movw	r3, #40544	; 0x9e60
   10e48:	f2c0 0302 	movt	r3, #2
   10e4c:	681b      	ldr	r3, [r3, #0]
   10e4e:	f103 041c 	add.w	r4, r3, #28
   10e52:	2c00      	cmp	r4, #0
   10e54:	d106      	bne.n	10e64 <write_reg+0x1bc>
   10e56:	f249 4060 	movw	r0, #37984	; 0x9460
   10e5a:	f2c0 0002 	movt	r0, #2
   10e5e:	2100      	movs	r1, #0
   10e60:	f7ff ed90 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10e64:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   10e68:	6023      	str	r3, [r4, #0]
    free(wr);
   10e6a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   10e6c:	f7ff ed5a 	blx	10924 <free@plt>
    free(rd);
   10e70:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   10e72:	f7ff ed58 	blx	10924 <free@plt>
}
   10e76:	3740      	adds	r7, #64	; 0x40
   10e78:	46bd      	mov	sp, r7
   10e7a:	bdb0      	pop	{r4, r5, r7, pc}

00010e7c <read_reg_burst>:

void read_reg_burst(int fd, uint8_t addr, uint8_t len, uint8_t *dest)
{
   10e7c:	b5b0      	push	{r4, r5, r7, lr}
   10e7e:	b092      	sub	sp, #72	; 0x48
   10e80:	af00      	add	r7, sp, #0
   10e82:	60f8      	str	r0, [r7, #12]
   10e84:	607b      	str	r3, [r7, #4]
   10e86:	460b      	mov	r3, r1
   10e88:	72fb      	strb	r3, [r7, #11]
   10e8a:	4613      	mov	r3, r2
   10e8c:	72bb      	strb	r3, [r7, #10]
    int ret;
    uint32_t i;
    struct spi_ioc_transfer tr;
    #define N_RESP_BYTES (2) 
    uint8_t *wr, *rd;
    wr = malloc(len + 1);
   10e8e:	7abb      	ldrb	r3, [r7, #10]
   10e90:	1c5c      	adds	r4, r3, #1
   10e92:	2201      	movs	r2, #1
   10e94:	2a00      	cmp	r2, #0
   10e96:	db02      	blt.n	10e9e <read_reg_burst+0x22>
   10e98:	429c      	cmp	r4, r3
   10e9a:	da0a      	bge.n	10eb2 <read_reg_burst+0x36>
   10e9c:	e001      	b.n	10ea2 <read_reg_burst+0x26>
   10e9e:	429c      	cmp	r4, r3
   10ea0:	dd07      	ble.n	10eb2 <read_reg_burst+0x36>
   10ea2:	f249 5018 	movw	r0, #38168	; 0x9518
   10ea6:	f2c0 0002 	movt	r0, #2
   10eaa:	4619      	mov	r1, r3
   10eac:	2201      	movs	r2, #1
   10eae:	f7ff ed4c 	blx	10948 <__ubsan_handle_add_overflow@plt>
   10eb2:	4623      	mov	r3, r4
   10eb4:	4618      	mov	r0, r3
   10eb6:	f7ff ed60 	blx	10978 <malloc@plt>
   10eba:	4603      	mov	r3, r0
   10ebc:	63fb      	str	r3, [r7, #60]	; 0x3c
    rd = malloc(len + 1);
   10ebe:	7abb      	ldrb	r3, [r7, #10]
   10ec0:	1c5c      	adds	r4, r3, #1
   10ec2:	2201      	movs	r2, #1
   10ec4:	2a00      	cmp	r2, #0
   10ec6:	db02      	blt.n	10ece <read_reg_burst+0x52>
   10ec8:	429c      	cmp	r4, r3
   10eca:	da0a      	bge.n	10ee2 <read_reg_burst+0x66>
   10ecc:	e001      	b.n	10ed2 <read_reg_burst+0x56>
   10ece:	429c      	cmp	r4, r3
   10ed0:	dd07      	ble.n	10ee2 <read_reg_burst+0x66>
   10ed2:	f249 5028 	movw	r0, #38184	; 0x9528
   10ed6:	f2c0 0002 	movt	r0, #2
   10eda:	4619      	mov	r1, r3
   10edc:	2201      	movs	r2, #1
   10ede:	f7ff ed34 	blx	10948 <__ubsan_handle_add_overflow@plt>
   10ee2:	4623      	mov	r3, r4
   10ee4:	4618      	mov	r0, r3
   10ee6:	f7ff ed48 	blx	10978 <malloc@plt>
   10eea:	4603      	mov	r3, r0
   10eec:	63bb      	str	r3, [r7, #56]	; 0x38
    memset(&tr, 0, sizeof(tr));
   10eee:	f107 0310 	add.w	r3, r7, #16
   10ef2:	4618      	mov	r0, r3
   10ef4:	2100      	movs	r1, #0
   10ef6:	2220      	movs	r2, #32
   10ef8:	f7ff ed02 	blx	10900 <memset@plt>
    memset(wr, 0, 10);
   10efc:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   10efe:	2100      	movs	r1, #0
   10f00:	220a      	movs	r2, #10
   10f02:	f7ff ecfe 	blx	10900 <memset@plt>
    memset(rd, 0, 10);
   10f06:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   10f08:	2100      	movs	r1, #0
   10f0a:	220a      	movs	r2, #10
   10f0c:	f7ff ecf8 	blx	10900 <memset@plt>
    memset(wr, 0xde, sizeof(wr[0])*len);
   10f10:	7abb      	ldrb	r3, [r7, #10]
   10f12:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   10f14:	21de      	movs	r1, #222	; 0xde
   10f16:	461a      	mov	r2, r3
   10f18:	f7ff ecf2 	blx	10900 <memset@plt>
    wr[0] = (addr) | BURST_CMD_BIT | READ_CMD_BIT;
   10f1c:	7afb      	ldrb	r3, [r7, #11]
   10f1e:	f063 033f 	orn	r3, r3, #63	; 0x3f
   10f22:	b2dc      	uxtb	r4, r3
   10f24:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10f26:	2b00      	cmp	r3, #0
   10f28:	d106      	bne.n	10f38 <read_reg_burst+0xbc>
   10f2a:	f249 4088 	movw	r0, #38024	; 0x9488
   10f2e:	f2c0 0002 	movt	r0, #2
   10f32:	2100      	movs	r1, #0
   10f34:	f7ff ed26 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10f38:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10f3a:	4622      	mov	r2, r4
   10f3c:	701a      	strb	r2, [r3, #0]

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   10f3e:	f649 6360 	movw	r3, #40544	; 0x9e60
   10f42:	f2c0 0302 	movt	r3, #2
   10f46:	681b      	ldr	r3, [r3, #0]
   10f48:	f103 0428 	add.w	r4, r3, #40	; 0x28
   10f4c:	2c00      	cmp	r4, #0
   10f4e:	d106      	bne.n	10f5e <read_reg_burst+0xe2>
   10f50:	f249 40a0 	movw	r0, #38048	; 0x94a0
   10f54:	f2c0 0002 	movt	r0, #2
   10f58:	2100      	movs	r1, #0
   10f5a:	f7ff ed14 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10f5e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   10f62:	6023      	str	r3, [r4, #0]

    while(GET_GPIO(GPIO_RDY))
   10f64:	e009      	b.n	10f7a <read_reg_burst+0xfe>
    {
        printf("Waiting for Chiprdy ....%d\n", i++);
   10f66:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   10f68:	1c5a      	adds	r2, r3, #1
   10f6a:	647a      	str	r2, [r7, #68]	; 0x44
   10f6c:	f242 70e8 	movw	r0, #10216	; 0x27e8
   10f70:	f2c0 0001 	movt	r0, #1
   10f74:	4619      	mov	r1, r3
   10f76:	f7ff ecee 	blx	10954 <printf@plt>
    memset(wr, 0xde, sizeof(wr[0])*len);
    wr[0] = (addr) | BURST_CMD_BIT | READ_CMD_BIT;

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);

    while(GET_GPIO(GPIO_RDY))
   10f7a:	f649 6360 	movw	r3, #40544	; 0x9e60
   10f7e:	f2c0 0302 	movt	r3, #2
   10f82:	681b      	ldr	r3, [r3, #0]
   10f84:	f103 0434 	add.w	r4, r3, #52	; 0x34
   10f88:	2c00      	cmp	r4, #0
   10f8a:	d106      	bne.n	10f9a <read_reg_burst+0x11e>
   10f8c:	f249 40b8 	movw	r0, #38072	; 0x94b8
   10f90:	f2c0 0002 	movt	r0, #2
   10f94:	2100      	movs	r1, #0
   10f96:	f7ff ecf6 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   10f9a:	6823      	ldr	r3, [r4, #0]
   10f9c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   10fa0:	2b00      	cmp	r3, #0
   10fa2:	d1e0      	bne.n	10f66 <read_reg_burst+0xea>
        printf("Waiting for Chiprdy ....%d\n", i++);
    }
#if 0
    printf("Burst Reading %02x\n", addr);
#endif
    tr.tx_buf = (unsigned long) wr;
   10fa4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   10fa6:	461a      	mov	r2, r3
   10fa8:	f04f 0300 	mov.w	r3, #0
   10fac:	e9c7 2304 	strd	r2, r3, [r7, #16]
    tr.rx_buf = (unsigned long) rd;
   10fb0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   10fb2:	461a      	mov	r2, r3
   10fb4:	f04f 0300 	mov.w	r3, #0
   10fb8:	e9c7 2306 	strd	r2, r3, [r7, #24]
    tr.len = len + 1;
   10fbc:	7abb      	ldrb	r3, [r7, #10]
   10fbe:	1c5c      	adds	r4, r3, #1
   10fc0:	2201      	movs	r2, #1
   10fc2:	2a00      	cmp	r2, #0
   10fc4:	db02      	blt.n	10fcc <read_reg_burst+0x150>
   10fc6:	429c      	cmp	r4, r3
   10fc8:	da0a      	bge.n	10fe0 <read_reg_burst+0x164>
   10fca:	e001      	b.n	10fd0 <read_reg_burst+0x154>
   10fcc:	429c      	cmp	r4, r3
   10fce:	dd07      	ble.n	10fe0 <read_reg_burst+0x164>
   10fd0:	f249 5038 	movw	r0, #38200	; 0x9538
   10fd4:	f2c0 0002 	movt	r0, #2
   10fd8:	4619      	mov	r1, r3
   10fda:	2201      	movs	r2, #1
   10fdc:	f7ff ecb4 	blx	10948 <__ubsan_handle_add_overflow@plt>
   10fe0:	4623      	mov	r3, r4
   10fe2:	623b      	str	r3, [r7, #32]
    tr.delay_usecs = 90;
   10fe4:	235a      	movs	r3, #90	; 0x5a
   10fe6:	853b      	strh	r3, [r7, #40]	; 0x28
    tr.speed_hz = SPI_SPEED;
   10fe8:	f644 3340 	movw	r3, #19264	; 0x4b40
   10fec:	f2c0 034c 	movt	r3, #76	; 0x4c
   10ff0:	627b      	str	r3, [r7, #36]	; 0x24
    tr.bits_per_word = 8;
   10ff2:	2308      	movs	r3, #8
   10ff4:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    tr.cs_change = 0;
   10ff8:	2300      	movs	r3, #0
   10ffa:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
   10ffe:	f107 0310 	add.w	r3, r7, #16
   11002:	68f8      	ldr	r0, [r7, #12]
   11004:	f44f 41d6 	mov.w	r1, #27392	; 0x6b00
   11008:	f2c4 0120 	movt	r1, #16416	; 0x4020
   1100c:	461a      	mov	r2, r3
   1100e:	f7ff ec96 	blx	1093c <ioctl@plt>
   11012:	6378      	str	r0, [r7, #52]	; 0x34
    if (ret < 1)
   11014:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   11016:	2b00      	cmp	r3, #0
   11018:	dc05      	bgt.n	11026 <read_reg_burst+0x1aa>
        perror("can't send spi message");
   1101a:	f642 0004 	movw	r0, #10244	; 0x2804
   1101e:	f2c0 0001 	movt	r0, #1
   11022:	f7ff ec74 	blx	1090c <perror@plt>
#if 0
    for (i = 0; i < tr.len; i++) {
        printf("..%02X.. ", rd[ret]);
    }
#endif
    if (dest)
   11026:	687b      	ldr	r3, [r7, #4]
   11028:	2b00      	cmp	r3, #0
   1102a:	d037      	beq.n	1109c <read_reg_burst+0x220>
    {
        int i;
        for (i = 0; i < len; i++)
   1102c:	2300      	movs	r3, #0
   1102e:	643b      	str	r3, [r7, #64]	; 0x40
   11030:	e030      	b.n	11094 <read_reg_burst+0x218>
            dest[i] = rd[i + 1];
   11032:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   11034:	687a      	ldr	r2, [r7, #4]
   11036:	18d4      	adds	r4, r2, r3
   11038:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1103a:	3301      	adds	r3, #1
   1103c:	6bba      	ldr	r2, [r7, #56]	; 0x38
   1103e:	18d5      	adds	r5, r2, r3
   11040:	2d00      	cmp	r5, #0
   11042:	d106      	bne.n	11052 <read_reg_burst+0x1d6>
   11044:	f249 40d0 	movw	r0, #38096	; 0x94d0
   11048:	f2c0 0002 	movt	r0, #2
   1104c:	2100      	movs	r1, #0
   1104e:	f7ff ec9a 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11052:	782d      	ldrb	r5, [r5, #0]
   11054:	2c00      	cmp	r4, #0
   11056:	d106      	bne.n	11066 <read_reg_burst+0x1ea>
   11058:	f249 40e8 	movw	r0, #38120	; 0x94e8
   1105c:	f2c0 0002 	movt	r0, #2
   11060:	2100      	movs	r1, #0
   11062:	f7ff ec90 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11066:	462b      	mov	r3, r5
   11068:	7023      	strb	r3, [r4, #0]
    }
#endif
    if (dest)
    {
        int i;
        for (i = 0; i < len; i++)
   1106a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1106c:	1c5c      	adds	r4, r3, #1
   1106e:	2301      	movs	r3, #1
   11070:	2b00      	cmp	r3, #0
   11072:	db03      	blt.n	1107c <read_reg_burst+0x200>
   11074:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   11076:	429c      	cmp	r4, r3
   11078:	da0b      	bge.n	11092 <read_reg_burst+0x216>
   1107a:	e002      	b.n	11082 <read_reg_burst+0x206>
   1107c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1107e:	429c      	cmp	r4, r3
   11080:	dd07      	ble.n	11092 <read_reg_burst+0x216>
   11082:	f249 5048 	movw	r0, #38216	; 0x9548
   11086:	f2c0 0002 	movt	r0, #2
   1108a:	6c39      	ldr	r1, [r7, #64]	; 0x40
   1108c:	2201      	movs	r2, #1
   1108e:	f7ff ec5c 	blx	10948 <__ubsan_handle_add_overflow@plt>
   11092:	643c      	str	r4, [r7, #64]	; 0x40
   11094:	7aba      	ldrb	r2, [r7, #10]
   11096:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   11098:	429a      	cmp	r2, r3
   1109a:	dcca      	bgt.n	11032 <read_reg_burst+0x1b6>
            dest[i] = rd[i + 1];
    }
    GPIO_SET = 1 << (GPIO_CHIP_SEL);
   1109c:	f649 6360 	movw	r3, #40544	; 0x9e60
   110a0:	f2c0 0302 	movt	r3, #2
   110a4:	681b      	ldr	r3, [r3, #0]
   110a6:	f103 041c 	add.w	r4, r3, #28
   110aa:	2c00      	cmp	r4, #0
   110ac:	d106      	bne.n	110bc <read_reg_burst+0x240>
   110ae:	f249 5000 	movw	r0, #38144	; 0x9500
   110b2:	f2c0 0002 	movt	r0, #2
   110b6:	2100      	movs	r1, #0
   110b8:	f7ff ec64 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   110bc:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   110c0:	6023      	str	r3, [r4, #0]
    free(wr);
   110c2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   110c4:	f7ff ec2e 	blx	10924 <free@plt>
    free(rd);
   110c8:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   110ca:	f7ff ec2c 	blx	10924 <free@plt>
    return;
   110ce:	bf00      	nop
}
   110d0:	3748      	adds	r7, #72	; 0x48
   110d2:	46bd      	mov	sp, r7
   110d4:	bdb0      	pop	{r4, r5, r7, pc}
   110d6:	bf00      	nop

000110d8 <write_reg_burst>:

uint8_t write_reg_burst(int fd, uint8_t addr, uint8_t *value, uint8_t len)
{
   110d8:	b5b0      	push	{r4, r5, r7, lr}
   110da:	b092      	sub	sp, #72	; 0x48
   110dc:	af00      	add	r7, sp, #0
   110de:	60f8      	str	r0, [r7, #12]
   110e0:	607a      	str	r2, [r7, #4]
   110e2:	461a      	mov	r2, r3
   110e4:	460b      	mov	r3, r1
   110e6:	72fb      	strb	r3, [r7, #11]
   110e8:	4613      	mov	r3, r2
   110ea:	72bb      	strb	r3, [r7, #10]
    int ret;
    uint8_t *ptr;
    struct spi_ioc_transfer tr;
    #define N_RESP_BYTES (2) 
    uint8_t *wr, *rd;
    wr = malloc(len + 1);
   110ec:	7abb      	ldrb	r3, [r7, #10]
   110ee:	1c5c      	adds	r4, r3, #1
   110f0:	2201      	movs	r2, #1
   110f2:	2a00      	cmp	r2, #0
   110f4:	db02      	blt.n	110fc <write_reg_burst+0x24>
   110f6:	429c      	cmp	r4, r3
   110f8:	da0a      	bge.n	11110 <write_reg_burst+0x38>
   110fa:	e001      	b.n	11100 <write_reg_burst+0x28>
   110fc:	429c      	cmp	r4, r3
   110fe:	dd07      	ble.n	11110 <write_reg_burst+0x38>
   11100:	f249 6000 	movw	r0, #38400	; 0x9600
   11104:	f2c0 0002 	movt	r0, #2
   11108:	4619      	mov	r1, r3
   1110a:	2201      	movs	r2, #1
   1110c:	f7ff ec1c 	blx	10948 <__ubsan_handle_add_overflow@plt>
   11110:	4623      	mov	r3, r4
   11112:	4618      	mov	r0, r3
   11114:	f7ff ec30 	blx	10978 <malloc@plt>
   11118:	4603      	mov	r3, r0
   1111a:	63fb      	str	r3, [r7, #60]	; 0x3c
    rd = malloc(len + 1);
   1111c:	7abb      	ldrb	r3, [r7, #10]
   1111e:	1c5c      	adds	r4, r3, #1
   11120:	2201      	movs	r2, #1
   11122:	2a00      	cmp	r2, #0
   11124:	db02      	blt.n	1112c <write_reg_burst+0x54>
   11126:	429c      	cmp	r4, r3
   11128:	da0a      	bge.n	11140 <write_reg_burst+0x68>
   1112a:	e001      	b.n	11130 <write_reg_burst+0x58>
   1112c:	429c      	cmp	r4, r3
   1112e:	dd07      	ble.n	11140 <write_reg_burst+0x68>
   11130:	f249 6010 	movw	r0, #38416	; 0x9610
   11134:	f2c0 0002 	movt	r0, #2
   11138:	4619      	mov	r1, r3
   1113a:	2201      	movs	r2, #1
   1113c:	f7ff ec04 	blx	10948 <__ubsan_handle_add_overflow@plt>
   11140:	4623      	mov	r3, r4
   11142:	4618      	mov	r0, r3
   11144:	f7ff ec18 	blx	10978 <malloc@plt>
   11148:	4603      	mov	r3, r0
   1114a:	63bb      	str	r3, [r7, #56]	; 0x38
    memset(&tr, 0, sizeof(tr));
   1114c:	f107 0310 	add.w	r3, r7, #16
   11150:	4618      	mov	r0, r3
   11152:	2100      	movs	r1, #0
   11154:	2220      	movs	r2, #32
   11156:	f7ff ebd4 	blx	10900 <memset@plt>
    memset(wr, 0, 10);
   1115a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   1115c:	2100      	movs	r1, #0
   1115e:	220a      	movs	r2, #10
   11160:	f7ff ebce 	blx	10900 <memset@plt>
    memset(rd, 0, 10);
   11164:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   11166:	2100      	movs	r1, #0
   11168:	220a      	movs	r2, #10
   1116a:	f7ff ebca 	blx	10900 <memset@plt>

    wr[0] = (addr) | BURST_CMD_BIT;
   1116e:	7afb      	ldrb	r3, [r7, #11]
   11170:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   11174:	b2dc      	uxtb	r4, r3
   11176:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11178:	2b00      	cmp	r3, #0
   1117a:	d106      	bne.n	1118a <write_reg_burst+0xb2>
   1117c:	f249 5058 	movw	r0, #38232	; 0x9558
   11180:	f2c0 0002 	movt	r0, #2
   11184:	2100      	movs	r1, #0
   11186:	f7ff ebfe 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1118a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1118c:	4622      	mov	r2, r4
   1118e:	701a      	strb	r2, [r3, #0]
    ptr = &wr[1];
   11190:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11192:	3301      	adds	r3, #1
   11194:	647b      	str	r3, [r7, #68]	; 0x44
    for (int i = 0; i < len; i++)
   11196:	2300      	movs	r3, #0
   11198:	643b      	str	r3, [r7, #64]	; 0x40
   1119a:	e02f      	b.n	111fc <write_reg_burst+0x124>
        *ptr++ = *value++;
   1119c:	6c7c      	ldr	r4, [r7, #68]	; 0x44
   1119e:	1c63      	adds	r3, r4, #1
   111a0:	647b      	str	r3, [r7, #68]	; 0x44
   111a2:	687d      	ldr	r5, [r7, #4]
   111a4:	1c6b      	adds	r3, r5, #1
   111a6:	607b      	str	r3, [r7, #4]
   111a8:	2d00      	cmp	r5, #0
   111aa:	d106      	bne.n	111ba <write_reg_burst+0xe2>
   111ac:	f249 5070 	movw	r0, #38256	; 0x9570
   111b0:	f2c0 0002 	movt	r0, #2
   111b4:	2100      	movs	r1, #0
   111b6:	f7ff ebe6 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   111ba:	782d      	ldrb	r5, [r5, #0]
   111bc:	2c00      	cmp	r4, #0
   111be:	d106      	bne.n	111ce <write_reg_burst+0xf6>
   111c0:	f249 5088 	movw	r0, #38280	; 0x9588
   111c4:	f2c0 0002 	movt	r0, #2
   111c8:	2100      	movs	r1, #0
   111ca:	f7ff ebdc 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   111ce:	462b      	mov	r3, r5
   111d0:	7023      	strb	r3, [r4, #0]
    memset(wr, 0, 10);
    memset(rd, 0, 10);

    wr[0] = (addr) | BURST_CMD_BIT;
    ptr = &wr[1];
    for (int i = 0; i < len; i++)
   111d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   111d4:	1c5c      	adds	r4, r3, #1
   111d6:	2301      	movs	r3, #1
   111d8:	2b00      	cmp	r3, #0
   111da:	db03      	blt.n	111e4 <write_reg_burst+0x10c>
   111dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   111de:	429c      	cmp	r4, r3
   111e0:	da0b      	bge.n	111fa <write_reg_burst+0x122>
   111e2:	e002      	b.n	111ea <write_reg_burst+0x112>
   111e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   111e6:	429c      	cmp	r4, r3
   111e8:	dd07      	ble.n	111fa <write_reg_burst+0x122>
   111ea:	f249 6020 	movw	r0, #38432	; 0x9620
   111ee:	f2c0 0002 	movt	r0, #2
   111f2:	6c39      	ldr	r1, [r7, #64]	; 0x40
   111f4:	2201      	movs	r2, #1
   111f6:	f7ff eba8 	blx	10948 <__ubsan_handle_add_overflow@plt>
   111fa:	643c      	str	r4, [r7, #64]	; 0x40
   111fc:	7aba      	ldrb	r2, [r7, #10]
   111fe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   11200:	429a      	cmp	r2, r3
   11202:	dccb      	bgt.n	1119c <write_reg_burst+0xc4>
        *ptr++ = *value++;
    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   11204:	f649 6360 	movw	r3, #40544	; 0x9e60
   11208:	f2c0 0302 	movt	r3, #2
   1120c:	681b      	ldr	r3, [r3, #0]
   1120e:	f103 0428 	add.w	r4, r3, #40	; 0x28
   11212:	2c00      	cmp	r4, #0
   11214:	d106      	bne.n	11224 <write_reg_burst+0x14c>
   11216:	f249 50a0 	movw	r0, #38304	; 0x95a0
   1121a:	f2c0 0002 	movt	r0, #2
   1121e:	2100      	movs	r1, #0
   11220:	f7ff ebb0 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11224:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11228:	6023      	str	r3, [r4, #0]
    while(GET_GPIO(GPIO_RDY))
   1122a:	e01b      	b.n	11264 <write_reg_burst+0x18c>
    {
        int i = 0;
   1122c:	2300      	movs	r3, #0
   1122e:	637b      	str	r3, [r7, #52]	; 0x34
        printf("Waiting for Chiprdy ....%d\n", i++);
   11230:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   11232:	1c65      	adds	r5, r4, #1
   11234:	2301      	movs	r3, #1
   11236:	2b00      	cmp	r3, #0
   11238:	db02      	blt.n	11240 <write_reg_burst+0x168>
   1123a:	42a5      	cmp	r5, r4
   1123c:	da0a      	bge.n	11254 <write_reg_burst+0x17c>
   1123e:	e001      	b.n	11244 <write_reg_burst+0x16c>
   11240:	42a5      	cmp	r5, r4
   11242:	dd07      	ble.n	11254 <write_reg_burst+0x17c>
   11244:	f249 6030 	movw	r0, #38448	; 0x9630
   11248:	f2c0 0002 	movt	r0, #2
   1124c:	4621      	mov	r1, r4
   1124e:	2201      	movs	r2, #1
   11250:	f7ff eb7a 	blx	10948 <__ubsan_handle_add_overflow@plt>
   11254:	637d      	str	r5, [r7, #52]	; 0x34
   11256:	f242 70e8 	movw	r0, #10216	; 0x27e8
   1125a:	f2c0 0001 	movt	r0, #1
   1125e:	4621      	mov	r1, r4
   11260:	f7ff eb78 	blx	10954 <printf@plt>
    wr[0] = (addr) | BURST_CMD_BIT;
    ptr = &wr[1];
    for (int i = 0; i < len; i++)
        *ptr++ = *value++;
    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
    while(GET_GPIO(GPIO_RDY))
   11264:	f649 6360 	movw	r3, #40544	; 0x9e60
   11268:	f2c0 0302 	movt	r3, #2
   1126c:	681b      	ldr	r3, [r3, #0]
   1126e:	f103 0434 	add.w	r4, r3, #52	; 0x34
   11272:	2c00      	cmp	r4, #0
   11274:	d106      	bne.n	11284 <write_reg_burst+0x1ac>
   11276:	f249 50b8 	movw	r0, #38328	; 0x95b8
   1127a:	f2c0 0002 	movt	r0, #2
   1127e:	2100      	movs	r1, #0
   11280:	f7ff eb80 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11284:	6823      	ldr	r3, [r4, #0]
   11286:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   1128a:	2b00      	cmp	r3, #0
   1128c:	d1ce      	bne.n	1122c <write_reg_burst+0x154>
    {
        int i = 0;
        printf("Waiting for Chiprdy ....%d\n", i++);
    }
    printf("Writing %02x \n", addr);
   1128e:	7afb      	ldrb	r3, [r7, #11]
   11290:	f642 001c 	movw	r0, #10268	; 0x281c
   11294:	f2c0 0001 	movt	r0, #1
   11298:	4619      	mov	r1, r3
   1129a:	f7ff eb5c 	blx	10954 <printf@plt>
    tr.tx_buf = (unsigned long) wr;
   1129e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   112a0:	461a      	mov	r2, r3
   112a2:	f04f 0300 	mov.w	r3, #0
   112a6:	e9c7 2304 	strd	r2, r3, [r7, #16]
    tr.rx_buf = (unsigned long) rd;
   112aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   112ac:	461a      	mov	r2, r3
   112ae:	f04f 0300 	mov.w	r3, #0
   112b2:	e9c7 2306 	strd	r2, r3, [r7, #24]
    tr.len = len + 1;
   112b6:	7abb      	ldrb	r3, [r7, #10]
   112b8:	1c5c      	adds	r4, r3, #1
   112ba:	2201      	movs	r2, #1
   112bc:	2a00      	cmp	r2, #0
   112be:	db02      	blt.n	112c6 <write_reg_burst+0x1ee>
   112c0:	429c      	cmp	r4, r3
   112c2:	da0a      	bge.n	112da <write_reg_burst+0x202>
   112c4:	e001      	b.n	112ca <write_reg_burst+0x1f2>
   112c6:	429c      	cmp	r4, r3
   112c8:	dd07      	ble.n	112da <write_reg_burst+0x202>
   112ca:	f249 6040 	movw	r0, #38464	; 0x9640
   112ce:	f2c0 0002 	movt	r0, #2
   112d2:	4619      	mov	r1, r3
   112d4:	2201      	movs	r2, #1
   112d6:	f7ff eb38 	blx	10948 <__ubsan_handle_add_overflow@plt>
   112da:	4623      	mov	r3, r4
   112dc:	623b      	str	r3, [r7, #32]
    tr.delay_usecs = 90;
   112de:	235a      	movs	r3, #90	; 0x5a
   112e0:	853b      	strh	r3, [r7, #40]	; 0x28
    tr.speed_hz = SPI_SPEED;
   112e2:	f644 3340 	movw	r3, #19264	; 0x4b40
   112e6:	f2c0 034c 	movt	r3, #76	; 0x4c
   112ea:	627b      	str	r3, [r7, #36]	; 0x24
    tr.bits_per_word = 8;
   112ec:	2308      	movs	r3, #8
   112ee:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    tr.cs_change = 0;
   112f2:	2300      	movs	r3, #0
   112f4:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
   112f8:	f107 0310 	add.w	r3, r7, #16
   112fc:	68f8      	ldr	r0, [r7, #12]
   112fe:	f44f 41d6 	mov.w	r1, #27392	; 0x6b00
   11302:	f2c4 0120 	movt	r1, #16416	; 0x4020
   11306:	461a      	mov	r2, r3
   11308:	f7ff eb18 	blx	1093c <ioctl@plt>
   1130c:	6338      	str	r0, [r7, #48]	; 0x30
    if (ret < 1)
   1130e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   11310:	2b00      	cmp	r3, #0
   11312:	dc05      	bgt.n	11320 <write_reg_burst+0x248>
        perror("can't send spi message");
   11314:	f642 0004 	movw	r0, #10244	; 0x2804
   11318:	f2c0 0001 	movt	r0, #1
   1131c:	f7ff eaf6 	blx	1090c <perror@plt>
#if 0
    for (ret = 0; ret < tr.len; ret++) {
        printf("..%02X.. ", rd[ret]);
    }
#endif
    GPIO_SET = 1 << (GPIO_CHIP_SEL);
   11320:	f649 6360 	movw	r3, #40544	; 0x9e60
   11324:	f2c0 0302 	movt	r3, #2
   11328:	681b      	ldr	r3, [r3, #0]
   1132a:	f103 041c 	add.w	r4, r3, #28
   1132e:	2c00      	cmp	r4, #0
   11330:	d106      	bne.n	11340 <write_reg_burst+0x268>
   11332:	f249 50d0 	movw	r0, #38352	; 0x95d0
   11336:	f2c0 0002 	movt	r0, #2
   1133a:	2100      	movs	r1, #0
   1133c:	f7ff eb22 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11340:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11344:	6023      	str	r3, [r4, #0]
    free(wr);
   11346:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   11348:	f7ff eaec 	blx	10924 <free@plt>
    free(rd);
   1134c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   1134e:	f7ff eaea 	blx	10924 <free@plt>
    return rd[1];
   11352:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   11354:	2b00      	cmp	r3, #0
   11356:	d106      	bne.n	11366 <write_reg_burst+0x28e>
   11358:	f249 50e8 	movw	r0, #38376	; 0x95e8
   1135c:	f2c0 0002 	movt	r0, #2
   11360:	2100      	movs	r1, #0
   11362:	f7ff eb10 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11366:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   11368:	785b      	ldrb	r3, [r3, #1]
}
   1136a:	4618      	mov	r0, r3
   1136c:	3748      	adds	r7, #72	; 0x48
   1136e:	46bd      	mov	sp, r7
   11370:	bdb0      	pop	{r4, r5, r7, pc}
   11372:	bf00      	nop

00011374 <read_reg>:

uint8_t read_reg(int fd, uint8_t addr, uint8_t *status)
{
   11374:	b5b0      	push	{r4, r5, r7, lr}
   11376:	b090      	sub	sp, #64	; 0x40
   11378:	af00      	add	r7, sp, #0
   1137a:	60f8      	str	r0, [r7, #12]
   1137c:	460b      	mov	r3, r1
   1137e:	607a      	str	r2, [r7, #4]
   11380:	72fb      	strb	r3, [r7, #11]
    int ret;
    struct spi_ioc_transfer tr;
    #define N_RESP_BYTES (2) 
    uint8_t *wr, *rd;
    wr = calloc(N_RESP_BYTES , sizeof(uint8_t));
   11382:	2002      	movs	r0, #2
   11384:	2101      	movs	r1, #1
   11386:	f7ff eab6 	blx	108f4 <calloc@plt>
   1138a:	4603      	mov	r3, r0
   1138c:	63fb      	str	r3, [r7, #60]	; 0x3c
    rd = calloc(N_RESP_BYTES , sizeof(uint8_t));
   1138e:	2002      	movs	r0, #2
   11390:	2101      	movs	r1, #1
   11392:	f7ff eab0 	blx	108f4 <calloc@plt>
   11396:	4603      	mov	r3, r0
   11398:	63bb      	str	r3, [r7, #56]	; 0x38
    memset(&tr, 0, sizeof(tr));
   1139a:	f107 0310 	add.w	r3, r7, #16
   1139e:	4618      	mov	r0, r3
   113a0:	2100      	movs	r1, #0
   113a2:	2220      	movs	r2, #32
   113a4:	f7ff eaac 	blx	10900 <memset@plt>

    wr[0] = (addr & 0x3f) | READ_CMD_BIT;
   113a8:	7afb      	ldrb	r3, [r7, #11]
   113aa:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   113ae:	b2db      	uxtb	r3, r3
   113b0:	f063 037f 	orn	r3, r3, #127	; 0x7f
   113b4:	b2db      	uxtb	r3, r3
   113b6:	b2dc      	uxtb	r4, r3
   113b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   113ba:	2b00      	cmp	r3, #0
   113bc:	d106      	bne.n	113cc <read_reg+0x58>
   113be:	f249 6050 	movw	r0, #38480	; 0x9650
   113c2:	f2c0 0002 	movt	r0, #2
   113c6:	2100      	movs	r1, #0
   113c8:	f7ff eadc 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   113cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   113ce:	4622      	mov	r2, r4
   113d0:	701a      	strb	r2, [r3, #0]
    wr[1] = 0x3e;
   113d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   113d4:	1c5c      	adds	r4, r3, #1
   113d6:	2c00      	cmp	r4, #0
   113d8:	d106      	bne.n	113e8 <read_reg+0x74>
   113da:	f249 6068 	movw	r0, #38504	; 0x9668
   113de:	f2c0 0002 	movt	r0, #2
   113e2:	2100      	movs	r1, #0
   113e4:	f7ff eace 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   113e8:	233e      	movs	r3, #62	; 0x3e
   113ea:	7023      	strb	r3, [r4, #0]
    if (addr >= 0x30)
   113ec:	7afb      	ldrb	r3, [r7, #11]
   113ee:	2b2f      	cmp	r3, #47	; 0x2f
   113f0:	d91b      	bls.n	1142a <read_reg+0xb6>
    {
        wr[0] |= BURST_CMD_BIT;
   113f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   113f4:	2b00      	cmp	r3, #0
   113f6:	d106      	bne.n	11406 <read_reg+0x92>
   113f8:	f249 6080 	movw	r0, #38528	; 0x9680
   113fc:	f2c0 0002 	movt	r0, #2
   11400:	2100      	movs	r1, #0
   11402:	f7ff eac0 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11406:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11408:	781b      	ldrb	r3, [r3, #0]
   1140a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1140e:	b2dc      	uxtb	r4, r3
   11410:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11412:	2b00      	cmp	r3, #0
   11414:	d106      	bne.n	11424 <read_reg+0xb0>
   11416:	f249 6098 	movw	r0, #38552	; 0x9698
   1141a:	f2c0 0002 	movt	r0, #2
   1141e:	2100      	movs	r1, #0
   11420:	f7ff eab0 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11424:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   11426:	4622      	mov	r2, r4
   11428:	701a      	strb	r2, [r3, #0]
    }

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   1142a:	f649 6360 	movw	r3, #40544	; 0x9e60
   1142e:	f2c0 0302 	movt	r3, #2
   11432:	681b      	ldr	r3, [r3, #0]
   11434:	f103 0428 	add.w	r4, r3, #40	; 0x28
   11438:	2c00      	cmp	r4, #0
   1143a:	d106      	bne.n	1144a <read_reg+0xd6>
   1143c:	f249 60b0 	movw	r0, #38576	; 0x96b0
   11440:	f2c0 0002 	movt	r0, #2
   11444:	2100      	movs	r1, #0
   11446:	f7ff ea9e 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1144a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   1144e:	6023      	str	r3, [r4, #0]
    while(GET_GPIO(GPIO_RDY))
   11450:	e01b      	b.n	1148a <read_reg+0x116>
    {
        int i = 0;
   11452:	2300      	movs	r3, #0
   11454:	637b      	str	r3, [r7, #52]	; 0x34
        printf("Waiting for Chiprdy ....%d\n", i++);
   11456:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   11458:	1c65      	adds	r5, r4, #1
   1145a:	2301      	movs	r3, #1
   1145c:	2b00      	cmp	r3, #0
   1145e:	db02      	blt.n	11466 <read_reg+0xf2>
   11460:	42a5      	cmp	r5, r4
   11462:	da0a      	bge.n	1147a <read_reg+0x106>
   11464:	e001      	b.n	1146a <read_reg+0xf6>
   11466:	42a5      	cmp	r5, r4
   11468:	dd07      	ble.n	1147a <read_reg+0x106>
   1146a:	f249 7040 	movw	r0, #38720	; 0x9740
   1146e:	f2c0 0002 	movt	r0, #2
   11472:	4621      	mov	r1, r4
   11474:	2201      	movs	r2, #1
   11476:	f7ff ea68 	blx	10948 <__ubsan_handle_add_overflow@plt>
   1147a:	637d      	str	r5, [r7, #52]	; 0x34
   1147c:	f242 70e8 	movw	r0, #10216	; 0x27e8
   11480:	f2c0 0001 	movt	r0, #1
   11484:	4621      	mov	r1, r4
   11486:	f7ff ea66 	blx	10954 <printf@plt>
    {
        wr[0] |= BURST_CMD_BIT;
    }

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
    while(GET_GPIO(GPIO_RDY))
   1148a:	f649 6360 	movw	r3, #40544	; 0x9e60
   1148e:	f2c0 0302 	movt	r3, #2
   11492:	681b      	ldr	r3, [r3, #0]
   11494:	f103 0434 	add.w	r4, r3, #52	; 0x34
   11498:	2c00      	cmp	r4, #0
   1149a:	d106      	bne.n	114aa <read_reg+0x136>
   1149c:	f249 60c8 	movw	r0, #38600	; 0x96c8
   114a0:	f2c0 0002 	movt	r0, #2
   114a4:	2100      	movs	r1, #0
   114a6:	f7ff ea6e 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   114aa:	6823      	ldr	r3, [r4, #0]
   114ac:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   114b0:	2b00      	cmp	r3, #0
   114b2:	d1ce      	bne.n	11452 <read_reg+0xde>
    {
        int i = 0;
        printf("Waiting for Chiprdy ....%d\n", i++);
    }

    tr.tx_buf = (unsigned long)wr;
   114b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   114b6:	461a      	mov	r2, r3
   114b8:	f04f 0300 	mov.w	r3, #0
   114bc:	e9c7 2304 	strd	r2, r3, [r7, #16]
    tr.rx_buf = (unsigned long)rd;
   114c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   114c2:	461a      	mov	r2, r3
   114c4:	f04f 0300 	mov.w	r3, #0
   114c8:	e9c7 2306 	strd	r2, r3, [r7, #24]
    tr.len = N_RESP_BYTES;
   114cc:	2302      	movs	r3, #2
   114ce:	623b      	str	r3, [r7, #32]
    tr.delay_usecs = 90;
   114d0:	235a      	movs	r3, #90	; 0x5a
   114d2:	853b      	strh	r3, [r7, #40]	; 0x28
    tr.speed_hz = SPI_SPEED;
   114d4:	f644 3340 	movw	r3, #19264	; 0x4b40
   114d8:	f2c0 034c 	movt	r3, #76	; 0x4c
   114dc:	627b      	str	r3, [r7, #36]	; 0x24
    tr.bits_per_word = 8;
   114de:	2308      	movs	r3, #8
   114e0:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    tr.cs_change = 0;
   114e4:	2300      	movs	r3, #0
   114e6:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
   114ea:	f107 0310 	add.w	r3, r7, #16
   114ee:	68f8      	ldr	r0, [r7, #12]
   114f0:	f44f 41d6 	mov.w	r1, #27392	; 0x6b00
   114f4:	f2c4 0120 	movt	r1, #16416	; 0x4020
   114f8:	461a      	mov	r2, r3
   114fa:	f7ff ea20 	blx	1093c <ioctl@plt>
   114fe:	6338      	str	r0, [r7, #48]	; 0x30
    if (ret < 1)
   11500:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   11502:	2b00      	cmp	r3, #0
   11504:	dc05      	bgt.n	11512 <read_reg+0x19e>
        perror("can't send spi message");
   11506:	f642 0004 	movw	r0, #10244	; 0x2804
   1150a:	f2c0 0001 	movt	r0, #1
   1150e:	f7ff e9fe 	blx	1090c <perror@plt>
#if 0
    for (ret = 0; ret < tr.len; ret++) {
        printf("%02X ", rd[ret]);
    }
#endif
    GPIO_SET = 1 << (GPIO_CHIP_SEL);
   11512:	f649 6360 	movw	r3, #40544	; 0x9e60
   11516:	f2c0 0302 	movt	r3, #2
   1151a:	681b      	ldr	r3, [r3, #0]
   1151c:	f103 041c 	add.w	r4, r3, #28
   11520:	2c00      	cmp	r4, #0
   11522:	d106      	bne.n	11532 <read_reg+0x1be>
   11524:	f249 60e0 	movw	r0, #38624	; 0x96e0
   11528:	f2c0 0002 	movt	r0, #2
   1152c:	2100      	movs	r1, #0
   1152e:	f7ff ea2a 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11532:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11536:	6023      	str	r3, [r4, #0]
    if (status)
   11538:	687b      	ldr	r3, [r7, #4]
   1153a:	2b00      	cmp	r3, #0
   1153c:	d018      	beq.n	11570 <read_reg+0x1fc>
        status[0] = rd[0];
   1153e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   11540:	2b00      	cmp	r3, #0
   11542:	d106      	bne.n	11552 <read_reg+0x1de>
   11544:	f249 60f8 	movw	r0, #38648	; 0x96f8
   11548:	f2c0 0002 	movt	r0, #2
   1154c:	2100      	movs	r1, #0
   1154e:	f7ff ea1a 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11552:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   11554:	781c      	ldrb	r4, [r3, #0]
   11556:	687b      	ldr	r3, [r7, #4]
   11558:	2b00      	cmp	r3, #0
   1155a:	d106      	bne.n	1156a <read_reg+0x1f6>
   1155c:	f249 7010 	movw	r0, #38672	; 0x9710
   11560:	f2c0 0002 	movt	r0, #2
   11564:	2100      	movs	r1, #0
   11566:	f7ff ea0e 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1156a:	687b      	ldr	r3, [r7, #4]
   1156c:	4622      	mov	r2, r4
   1156e:	701a      	strb	r2, [r3, #0]
    return rd[1];
   11570:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   11572:	2b00      	cmp	r3, #0
   11574:	d106      	bne.n	11584 <read_reg+0x210>
   11576:	f249 7028 	movw	r0, #38696	; 0x9728
   1157a:	f2c0 0002 	movt	r0, #2
   1157e:	2100      	movs	r1, #0
   11580:	f7ff ea00 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11584:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   11586:	785b      	ldrb	r3, [r3, #1]
}
   11588:	4618      	mov	r0, r3
   1158a:	3740      	adds	r7, #64	; 0x40
   1158c:	46bd      	mov	sp, r7
   1158e:	bdb0      	pop	{r4, r5, r7, pc}

00011590 <strobe_cmd>:

void strobe_cmd(int fd, uint8_t cmd, uint8_t *response)
{
   11590:	b580      	push	{r7, lr}
   11592:	b084      	sub	sp, #16
   11594:	af00      	add	r7, sp, #0
   11596:	60f8      	str	r0, [r7, #12]
   11598:	460b      	mov	r3, r1
   1159a:	607a      	str	r2, [r7, #4]
   1159c:	72fb      	strb	r3, [r7, #11]
    assert(cmd <= 0x3d && cmd >= 0x30);        
   1159e:	7afb      	ldrb	r3, [r7, #11]
   115a0:	2b3d      	cmp	r3, #61	; 0x3d
   115a2:	d802      	bhi.n	115aa <strobe_cmd+0x1a>
   115a4:	7afb      	ldrb	r3, [r7, #11]
   115a6:	2b2f      	cmp	r3, #47	; 0x2f
   115a8:	d80f      	bhi.n	115ca <strobe_cmd+0x3a>
   115aa:	f642 002c 	movw	r0, #10284	; 0x282c
   115ae:	f2c0 0001 	movt	r0, #1
   115b2:	f242 71dc 	movw	r1, #10204	; 0x27dc
   115b6:	f2c0 0101 	movt	r1, #1
   115ba:	f240 2246 	movw	r2, #582	; 0x246
   115be:	f642 13f8 	movw	r3, #10744	; 0x29f8
   115c2:	f2c0 0301 	movt	r3, #1
   115c6:	f7ff e9a8 	blx	10918 <__assert_fail@plt>
    write_reg(fd, cmd, 0, response); 
   115ca:	7afb      	ldrb	r3, [r7, #11]
   115cc:	68f8      	ldr	r0, [r7, #12]
   115ce:	4619      	mov	r1, r3
   115d0:	2200      	movs	r2, #0
   115d2:	687b      	ldr	r3, [r7, #4]
   115d4:	f7ff fb68 	bl	10ca8 <write_reg>
     
}
   115d8:	3710      	adds	r7, #16
   115da:	46bd      	mov	sp, r7
   115dc:	bd80      	pop	{r7, pc}
   115de:	bf00      	nop

000115e0 <cfg_gpio>:


void cfg_gpio()
{
   115e0:	b5b0      	push	{r4, r5, r7, lr}
   115e2:	af00      	add	r7, sp, #0
    INP_GPIO(GPIO_CHIP_SEL); // must use INP_GPIO before we can use OUT_GPIO
   115e4:	f649 6360 	movw	r3, #40544	; 0x9e60
   115e8:	f2c0 0302 	movt	r3, #2
   115ec:	681b      	ldr	r3, [r3, #0]
   115ee:	f103 0408 	add.w	r4, r3, #8
   115f2:	f649 6360 	movw	r3, #40544	; 0x9e60
   115f6:	f2c0 0302 	movt	r3, #2
   115fa:	681b      	ldr	r3, [r3, #0]
   115fc:	f103 0508 	add.w	r5, r3, #8
   11600:	2d00      	cmp	r5, #0
   11602:	d106      	bne.n	11612 <cfg_gpio+0x32>
   11604:	f249 7050 	movw	r0, #38736	; 0x9750
   11608:	f2c0 0002 	movt	r0, #2
   1160c:	2100      	movs	r1, #0
   1160e:	f7ff e9ba 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11612:	682b      	ldr	r3, [r5, #0]
   11614:	f423 75e0 	bic.w	r5, r3, #448	; 0x1c0
   11618:	2c00      	cmp	r4, #0
   1161a:	d106      	bne.n	1162a <cfg_gpio+0x4a>
   1161c:	f249 7068 	movw	r0, #38760	; 0x9768
   11620:	f2c0 0002 	movt	r0, #2
   11624:	2100      	movs	r1, #0
   11626:	f7ff e9ae 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1162a:	6025      	str	r5, [r4, #0]
    OUT_GPIO(GPIO_CHIP_SEL);
   1162c:	f649 6360 	movw	r3, #40544	; 0x9e60
   11630:	f2c0 0302 	movt	r3, #2
   11634:	681b      	ldr	r3, [r3, #0]
   11636:	f103 0408 	add.w	r4, r3, #8
   1163a:	f649 6360 	movw	r3, #40544	; 0x9e60
   1163e:	f2c0 0302 	movt	r3, #2
   11642:	681b      	ldr	r3, [r3, #0]
   11644:	f103 0508 	add.w	r5, r3, #8
   11648:	2d00      	cmp	r5, #0
   1164a:	d106      	bne.n	1165a <cfg_gpio+0x7a>
   1164c:	f249 7080 	movw	r0, #38784	; 0x9780
   11650:	f2c0 0002 	movt	r0, #2
   11654:	2100      	movs	r1, #0
   11656:	f7ff e996 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1165a:	682b      	ldr	r3, [r5, #0]
   1165c:	f043 0540 	orr.w	r5, r3, #64	; 0x40
   11660:	2c00      	cmp	r4, #0
   11662:	d106      	bne.n	11672 <cfg_gpio+0x92>
   11664:	f249 7098 	movw	r0, #38808	; 0x9798
   11668:	f2c0 0002 	movt	r0, #2
   1166c:	2100      	movs	r1, #0
   1166e:	f7ff e98a 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11672:	6025      	str	r5, [r4, #0]
    GPIO_SET = 1<<GPIO_CHIP_SEL;
   11674:	f649 6360 	movw	r3, #40544	; 0x9e60
   11678:	f2c0 0302 	movt	r3, #2
   1167c:	681b      	ldr	r3, [r3, #0]
   1167e:	f103 041c 	add.w	r4, r3, #28
   11682:	2c00      	cmp	r4, #0
   11684:	d106      	bne.n	11694 <cfg_gpio+0xb4>
   11686:	f249 70b0 	movw	r0, #38832	; 0x97b0
   1168a:	f2c0 0002 	movt	r0, #2
   1168e:	2100      	movs	r1, #0
   11690:	f7ff e978 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11694:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11698:	6023      	str	r3, [r4, #0]

    INP_GPIO(GPIO_RDY); // must use INP_GPIO before we can use OUT_GPIO
   1169a:	f649 6360 	movw	r3, #40544	; 0x9e60
   1169e:	f2c0 0302 	movt	r3, #2
   116a2:	681b      	ldr	r3, [r3, #0]
   116a4:	f103 0408 	add.w	r4, r3, #8
   116a8:	f649 6360 	movw	r3, #40544	; 0x9e60
   116ac:	f2c0 0302 	movt	r3, #2
   116b0:	681b      	ldr	r3, [r3, #0]
   116b2:	f103 0508 	add.w	r5, r3, #8
   116b6:	2d00      	cmp	r5, #0
   116b8:	d106      	bne.n	116c8 <cfg_gpio+0xe8>
   116ba:	f249 70c8 	movw	r0, #38856	; 0x97c8
   116be:	f2c0 0002 	movt	r0, #2
   116c2:	2100      	movs	r1, #0
   116c4:	f7ff e95e 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   116c8:	682b      	ldr	r3, [r5, #0]
   116ca:	f423 3560 	bic.w	r5, r3, #229376	; 0x38000
   116ce:	2c00      	cmp	r4, #0
   116d0:	d106      	bne.n	116e0 <cfg_gpio+0x100>
   116d2:	f249 70e0 	movw	r0, #38880	; 0x97e0
   116d6:	f2c0 0002 	movt	r0, #2
   116da:	2100      	movs	r1, #0
   116dc:	f7ff e952 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   116e0:	6025      	str	r5, [r4, #0]

    INP_GPIO(GPIO_GD0);
   116e2:	f649 6360 	movw	r3, #40544	; 0x9e60
   116e6:	f2c0 0302 	movt	r3, #2
   116ea:	681b      	ldr	r3, [r3, #0]
   116ec:	f103 0408 	add.w	r4, r3, #8
   116f0:	f649 6360 	movw	r3, #40544	; 0x9e60
   116f4:	f2c0 0302 	movt	r3, #2
   116f8:	681b      	ldr	r3, [r3, #0]
   116fa:	f103 0508 	add.w	r5, r3, #8
   116fe:	2d00      	cmp	r5, #0
   11700:	d106      	bne.n	11710 <cfg_gpio+0x130>
   11702:	f249 70f8 	movw	r0, #38904	; 0x97f8
   11706:	f2c0 0002 	movt	r0, #2
   1170a:	2100      	movs	r1, #0
   1170c:	f7ff e93a 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11710:	682b      	ldr	r3, [r5, #0]
   11712:	f423 45e0 	bic.w	r5, r3, #28672	; 0x7000
   11716:	2c00      	cmp	r4, #0
   11718:	d106      	bne.n	11728 <cfg_gpio+0x148>
   1171a:	f649 0010 	movw	r0, #38928	; 0x9810
   1171e:	f2c0 0002 	movt	r0, #2
   11722:	2100      	movs	r1, #0
   11724:	f7ff e92e 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11728:	6025      	str	r5, [r4, #0]
    INP_GPIO(GPIO_GD2);
   1172a:	f649 6360 	movw	r3, #40544	; 0x9e60
   1172e:	f2c0 0302 	movt	r3, #2
   11732:	681b      	ldr	r3, [r3, #0]
   11734:	f103 0408 	add.w	r4, r3, #8
   11738:	f649 6360 	movw	r3, #40544	; 0x9e60
   1173c:	f2c0 0302 	movt	r3, #2
   11740:	681b      	ldr	r3, [r3, #0]
   11742:	f103 0508 	add.w	r5, r3, #8
   11746:	2d00      	cmp	r5, #0
   11748:	d106      	bne.n	11758 <cfg_gpio+0x178>
   1174a:	f649 0028 	movw	r0, #38952	; 0x9828
   1174e:	f2c0 0002 	movt	r0, #2
   11752:	2100      	movs	r1, #0
   11754:	f7ff e916 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11758:	682b      	ldr	r3, [r5, #0]
   1175a:	f423 6560 	bic.w	r5, r3, #3584	; 0xe00
   1175e:	2c00      	cmp	r4, #0
   11760:	d106      	bne.n	11770 <cfg_gpio+0x190>
   11762:	f649 0040 	movw	r0, #38976	; 0x9840
   11766:	f2c0 0002 	movt	r0, #2
   1176a:	2100      	movs	r1, #0
   1176c:	f7ff e90a 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11770:	6025      	str	r5, [r4, #0]
}
   11772:	bdb0      	pop	{r4, r5, r7, pc}

00011774 <delay_loop>:

void delay_loop(int count)
{
   11774:	b5b0      	push	{r4, r5, r7, lr}
   11776:	b084      	sub	sp, #16
   11778:	af00      	add	r7, sp, #0
   1177a:	6078      	str	r0, [r7, #4]
    volatile int x = count;
   1177c:	687b      	ldr	r3, [r7, #4]
   1177e:	60fb      	str	r3, [r7, #12]
    while(x--)
   11780:	bf00      	nop
   11782:	68fc      	ldr	r4, [r7, #12]
   11784:	1e65      	subs	r5, r4, #1
   11786:	f04f 33ff 	mov.w	r3, #4294967295
   1178a:	2b00      	cmp	r3, #0
   1178c:	db02      	blt.n	11794 <delay_loop+0x20>
   1178e:	42a5      	cmp	r5, r4
   11790:	da0b      	bge.n	117aa <delay_loop+0x36>
   11792:	e001      	b.n	11798 <delay_loop+0x24>
   11794:	42a5      	cmp	r5, r4
   11796:	dd08      	ble.n	117aa <delay_loop+0x36>
   11798:	f649 0058 	movw	r0, #39000	; 0x9858
   1179c:	f2c0 0002 	movt	r0, #2
   117a0:	4621      	mov	r1, r4
   117a2:	f04f 32ff 	mov.w	r2, #4294967295
   117a6:	f7ff e8d0 	blx	10948 <__ubsan_handle_add_overflow@plt>
   117aa:	462b      	mov	r3, r5
   117ac:	60fb      	str	r3, [r7, #12]
   117ae:	2c00      	cmp	r4, #0
   117b0:	d1e7      	bne.n	11782 <delay_loop+0xe>
    ;

}
   117b2:	3710      	adds	r7, #16
   117b4:	46bd      	mov	sp, r7
   117b6:	bdb0      	pop	{r4, r5, r7, pc}

000117b8 <cc1101_reset>:

void cc1101_reset()
{
   117b8:	b5b0      	push	{r4, r5, r7, lr}
   117ba:	af00      	add	r7, sp, #0
    /*SCK HIGH*/
    INP_GPIO(GPIO_SCK); // must use INP_GPIO before we can use OUT_GPIO
   117bc:	f649 6360 	movw	r3, #40544	; 0x9e60
   117c0:	f2c0 0302 	movt	r3, #2
   117c4:	681b      	ldr	r3, [r3, #0]
   117c6:	1d1c      	adds	r4, r3, #4
   117c8:	f649 6360 	movw	r3, #40544	; 0x9e60
   117cc:	f2c0 0302 	movt	r3, #2
   117d0:	681b      	ldr	r3, [r3, #0]
   117d2:	1d1d      	adds	r5, r3, #4
   117d4:	2d00      	cmp	r5, #0
   117d6:	d106      	bne.n	117e6 <cc1101_reset+0x2e>
   117d8:	f649 0068 	movw	r0, #39016	; 0x9868
   117dc:	f2c0 0002 	movt	r0, #2
   117e0:	2100      	movs	r1, #0
   117e2:	f7ff e8d0 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   117e6:	682b      	ldr	r3, [r5, #0]
   117e8:	f023 0538 	bic.w	r5, r3, #56	; 0x38
   117ec:	2c00      	cmp	r4, #0
   117ee:	d106      	bne.n	117fe <cc1101_reset+0x46>
   117f0:	f649 0080 	movw	r0, #39040	; 0x9880
   117f4:	f2c0 0002 	movt	r0, #2
   117f8:	2100      	movs	r1, #0
   117fa:	f7ff e8c4 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   117fe:	6025      	str	r5, [r4, #0]
    OUT_GPIO(GPIO_SCK);
   11800:	f649 6360 	movw	r3, #40544	; 0x9e60
   11804:	f2c0 0302 	movt	r3, #2
   11808:	681b      	ldr	r3, [r3, #0]
   1180a:	1d1c      	adds	r4, r3, #4
   1180c:	f649 6360 	movw	r3, #40544	; 0x9e60
   11810:	f2c0 0302 	movt	r3, #2
   11814:	681b      	ldr	r3, [r3, #0]
   11816:	1d1d      	adds	r5, r3, #4
   11818:	2d00      	cmp	r5, #0
   1181a:	d106      	bne.n	1182a <cc1101_reset+0x72>
   1181c:	f649 0098 	movw	r0, #39064	; 0x9898
   11820:	f2c0 0002 	movt	r0, #2
   11824:	2100      	movs	r1, #0
   11826:	f7ff e8ae 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1182a:	682b      	ldr	r3, [r5, #0]
   1182c:	f043 0508 	orr.w	r5, r3, #8
   11830:	2c00      	cmp	r4, #0
   11832:	d106      	bne.n	11842 <cc1101_reset+0x8a>
   11834:	f649 00b0 	movw	r0, #39088	; 0x98b0
   11838:	f2c0 0002 	movt	r0, #2
   1183c:	2100      	movs	r1, #0
   1183e:	f7ff e8a2 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11842:	6025      	str	r5, [r4, #0]
    GPIO_SET = 1<<GPIO_SCK;
   11844:	f649 6360 	movw	r3, #40544	; 0x9e60
   11848:	f2c0 0302 	movt	r3, #2
   1184c:	681b      	ldr	r3, [r3, #0]
   1184e:	f103 041c 	add.w	r4, r3, #28
   11852:	2c00      	cmp	r4, #0
   11854:	d106      	bne.n	11864 <cc1101_reset+0xac>
   11856:	f649 00c8 	movw	r0, #39112	; 0x98c8
   1185a:	f2c0 0002 	movt	r0, #2
   1185e:	2100      	movs	r1, #0
   11860:	f7ff e890 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11864:	f44f 6300 	mov.w	r3, #2048	; 0x800
   11868:	6023      	str	r3, [r4, #0]

    /*MOSI LOW */
    INP_GPIO(GPIO_MOSI); // must use INP_GPIO before we can use OUT_GPIO
   1186a:	f649 6360 	movw	r3, #40544	; 0x9e60
   1186e:	f2c0 0302 	movt	r3, #2
   11872:	681b      	ldr	r3, [r3, #0]
   11874:	1d1c      	adds	r4, r3, #4
   11876:	f649 6360 	movw	r3, #40544	; 0x9e60
   1187a:	f2c0 0302 	movt	r3, #2
   1187e:	681b      	ldr	r3, [r3, #0]
   11880:	1d1d      	adds	r5, r3, #4
   11882:	2d00      	cmp	r5, #0
   11884:	d106      	bne.n	11894 <cc1101_reset+0xdc>
   11886:	f649 00e0 	movw	r0, #39136	; 0x98e0
   1188a:	f2c0 0002 	movt	r0, #2
   1188e:	2100      	movs	r1, #0
   11890:	f7ff e878 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11894:	682b      	ldr	r3, [r5, #0]
   11896:	f023 0507 	bic.w	r5, r3, #7
   1189a:	2c00      	cmp	r4, #0
   1189c:	d106      	bne.n	118ac <cc1101_reset+0xf4>
   1189e:	f649 00f8 	movw	r0, #39160	; 0x98f8
   118a2:	f2c0 0002 	movt	r0, #2
   118a6:	2100      	movs	r1, #0
   118a8:	f7ff e86c 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   118ac:	6025      	str	r5, [r4, #0]
    OUT_GPIO(GPIO_MOSI);
   118ae:	f649 6360 	movw	r3, #40544	; 0x9e60
   118b2:	f2c0 0302 	movt	r3, #2
   118b6:	681b      	ldr	r3, [r3, #0]
   118b8:	1d1c      	adds	r4, r3, #4
   118ba:	f649 6360 	movw	r3, #40544	; 0x9e60
   118be:	f2c0 0302 	movt	r3, #2
   118c2:	681b      	ldr	r3, [r3, #0]
   118c4:	1d1d      	adds	r5, r3, #4
   118c6:	2d00      	cmp	r5, #0
   118c8:	d106      	bne.n	118d8 <cc1101_reset+0x120>
   118ca:	f649 1010 	movw	r0, #39184	; 0x9910
   118ce:	f2c0 0002 	movt	r0, #2
   118d2:	2100      	movs	r1, #0
   118d4:	f7ff e856 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   118d8:	682b      	ldr	r3, [r5, #0]
   118da:	f043 0501 	orr.w	r5, r3, #1
   118de:	2c00      	cmp	r4, #0
   118e0:	d106      	bne.n	118f0 <cc1101_reset+0x138>
   118e2:	f649 1028 	movw	r0, #39208	; 0x9928
   118e6:	f2c0 0002 	movt	r0, #2
   118ea:	2100      	movs	r1, #0
   118ec:	f7ff e84a 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   118f0:	6025      	str	r5, [r4, #0]
    GPIO_CLR = 1<<GPIO_MOSI;
   118f2:	f649 6360 	movw	r3, #40544	; 0x9e60
   118f6:	f2c0 0302 	movt	r3, #2
   118fa:	681b      	ldr	r3, [r3, #0]
   118fc:	f103 0428 	add.w	r4, r3, #40	; 0x28
   11900:	2c00      	cmp	r4, #0
   11902:	d106      	bne.n	11912 <cc1101_reset+0x15a>
   11904:	f649 1040 	movw	r0, #39232	; 0x9940
   11908:	f2c0 0002 	movt	r0, #2
   1190c:	2100      	movs	r1, #0
   1190e:	f7ff e83a 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11912:	f44f 6380 	mov.w	r3, #1024	; 0x400
   11916:	6023      	str	r3, [r4, #0]

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   11918:	f649 6360 	movw	r3, #40544	; 0x9e60
   1191c:	f2c0 0302 	movt	r3, #2
   11920:	681b      	ldr	r3, [r3, #0]
   11922:	f103 0428 	add.w	r4, r3, #40	; 0x28
   11926:	2c00      	cmp	r4, #0
   11928:	d106      	bne.n	11938 <cc1101_reset+0x180>
   1192a:	f649 1058 	movw	r0, #39256	; 0x9958
   1192e:	f2c0 0002 	movt	r0, #2
   11932:	2100      	movs	r1, #0
   11934:	f7ff e826 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11938:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   1193c:	6023      	str	r3, [r4, #0]
    delay_loop(100);
   1193e:	2064      	movs	r0, #100	; 0x64
   11940:	f7ff ff18 	bl	11774 <delay_loop>
    GPIO_SET = 1<<(GPIO_CHIP_SEL);
   11944:	f649 6360 	movw	r3, #40544	; 0x9e60
   11948:	f2c0 0302 	movt	r3, #2
   1194c:	681b      	ldr	r3, [r3, #0]
   1194e:	f103 041c 	add.w	r4, r3, #28
   11952:	2c00      	cmp	r4, #0
   11954:	d106      	bne.n	11964 <cc1101_reset+0x1ac>
   11956:	f649 1070 	movw	r0, #39280	; 0x9970
   1195a:	f2c0 0002 	movt	r0, #2
   1195e:	2100      	movs	r1, #0
   11960:	f7ff e810 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11964:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11968:	6023      	str	r3, [r4, #0]
    delay_loop(8000);
   1196a:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
   1196e:	f7ff ff01 	bl	11774 <delay_loop>

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);
   11972:	f649 6360 	movw	r3, #40544	; 0x9e60
   11976:	f2c0 0302 	movt	r3, #2
   1197a:	681b      	ldr	r3, [r3, #0]
   1197c:	f103 0428 	add.w	r4, r3, #40	; 0x28
   11980:	2c00      	cmp	r4, #0
   11982:	d106      	bne.n	11992 <cc1101_reset+0x1da>
   11984:	f649 1088 	movw	r0, #39304	; 0x9988
   11988:	f2c0 0002 	movt	r0, #2
   1198c:	2100      	movs	r1, #0
   1198e:	f7fe effa 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11992:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   11996:	6023      	str	r3, [r4, #0]

    while(GET_GPIO(GPIO_RDY))
   11998:	e005      	b.n	119a6 <cc1101_reset+0x1ee>
        printf("Waiting for GPIO_RDY");
   1199a:	f642 0048 	movw	r0, #10312	; 0x2848
   1199e:	f2c0 0001 	movt	r0, #1
   119a2:	f7fe efd8 	blx	10954 <printf@plt>
    GPIO_SET = 1<<(GPIO_CHIP_SEL);
    delay_loop(8000);

    GPIO_CLR = 1<<(GPIO_CHIP_SEL);

    while(GET_GPIO(GPIO_RDY))
   119a6:	f649 6360 	movw	r3, #40544	; 0x9e60
   119aa:	f2c0 0302 	movt	r3, #2
   119ae:	681b      	ldr	r3, [r3, #0]
   119b0:	f103 0434 	add.w	r4, r3, #52	; 0x34
   119b4:	2c00      	cmp	r4, #0
   119b6:	d106      	bne.n	119c6 <cc1101_reset+0x20e>
   119b8:	f649 10a0 	movw	r0, #39328	; 0x99a0
   119bc:	f2c0 0002 	movt	r0, #2
   119c0:	2100      	movs	r1, #0
   119c2:	f7fe efe0 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   119c6:	6823      	ldr	r3, [r4, #0]
   119c8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   119cc:	2b00      	cmp	r3, #0
   119ce:	d1e4      	bne.n	1199a <cc1101_reset+0x1e2>
        printf("Waiting for GPIO_RDY");

    INP_GPIO(GPIO_SCK); // must use INP_GPIO before we can use OUT_GPIO
   119d0:	f649 6360 	movw	r3, #40544	; 0x9e60
   119d4:	f2c0 0302 	movt	r3, #2
   119d8:	681b      	ldr	r3, [r3, #0]
   119da:	1d1c      	adds	r4, r3, #4
   119dc:	f649 6360 	movw	r3, #40544	; 0x9e60
   119e0:	f2c0 0302 	movt	r3, #2
   119e4:	681b      	ldr	r3, [r3, #0]
   119e6:	1d1d      	adds	r5, r3, #4
   119e8:	2d00      	cmp	r5, #0
   119ea:	d106      	bne.n	119fa <cc1101_reset+0x242>
   119ec:	f649 10b8 	movw	r0, #39352	; 0x99b8
   119f0:	f2c0 0002 	movt	r0, #2
   119f4:	2100      	movs	r1, #0
   119f6:	f7fe efc6 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   119fa:	682b      	ldr	r3, [r5, #0]
   119fc:	f023 0538 	bic.w	r5, r3, #56	; 0x38
   11a00:	2c00      	cmp	r4, #0
   11a02:	d106      	bne.n	11a12 <cc1101_reset+0x25a>
   11a04:	f649 10d0 	movw	r0, #39376	; 0x99d0
   11a08:	f2c0 0002 	movt	r0, #2
   11a0c:	2100      	movs	r1, #0
   11a0e:	f7fe efba 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11a12:	6025      	str	r5, [r4, #0]
    SET_GPIO_ALT(GPIO_SCK,0);
   11a14:	f649 6360 	movw	r3, #40544	; 0x9e60
   11a18:	f2c0 0302 	movt	r3, #2
   11a1c:	681b      	ldr	r3, [r3, #0]
   11a1e:	1d1c      	adds	r4, r3, #4
   11a20:	f649 6360 	movw	r3, #40544	; 0x9e60
   11a24:	f2c0 0302 	movt	r3, #2
   11a28:	681b      	ldr	r3, [r3, #0]
   11a2a:	1d1d      	adds	r5, r3, #4
   11a2c:	2d00      	cmp	r5, #0
   11a2e:	d106      	bne.n	11a3e <cc1101_reset+0x286>
   11a30:	f649 10e8 	movw	r0, #39400	; 0x99e8
   11a34:	f2c0 0002 	movt	r0, #2
   11a38:	2100      	movs	r1, #0
   11a3a:	f7fe efa4 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11a3e:	682b      	ldr	r3, [r5, #0]
   11a40:	f043 0520 	orr.w	r5, r3, #32
   11a44:	2c00      	cmp	r4, #0
   11a46:	d106      	bne.n	11a56 <cc1101_reset+0x29e>
   11a48:	f649 2000 	movw	r0, #39424	; 0x9a00
   11a4c:	f2c0 0002 	movt	r0, #2
   11a50:	2100      	movs	r1, #0
   11a52:	f7fe ef98 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11a56:	6025      	str	r5, [r4, #0]

    INP_GPIO(GPIO_MOSI); // must use INP_GPIO before we can use OUT_GPIO
   11a58:	f649 6360 	movw	r3, #40544	; 0x9e60
   11a5c:	f2c0 0302 	movt	r3, #2
   11a60:	681b      	ldr	r3, [r3, #0]
   11a62:	1d1c      	adds	r4, r3, #4
   11a64:	f649 6360 	movw	r3, #40544	; 0x9e60
   11a68:	f2c0 0302 	movt	r3, #2
   11a6c:	681b      	ldr	r3, [r3, #0]
   11a6e:	1d1d      	adds	r5, r3, #4
   11a70:	2d00      	cmp	r5, #0
   11a72:	d106      	bne.n	11a82 <cc1101_reset+0x2ca>
   11a74:	f649 2018 	movw	r0, #39448	; 0x9a18
   11a78:	f2c0 0002 	movt	r0, #2
   11a7c:	2100      	movs	r1, #0
   11a7e:	f7fe ef82 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11a82:	682b      	ldr	r3, [r5, #0]
   11a84:	f023 0507 	bic.w	r5, r3, #7
   11a88:	2c00      	cmp	r4, #0
   11a8a:	d106      	bne.n	11a9a <cc1101_reset+0x2e2>
   11a8c:	f649 2030 	movw	r0, #39472	; 0x9a30
   11a90:	f2c0 0002 	movt	r0, #2
   11a94:	2100      	movs	r1, #0
   11a96:	f7fe ef76 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11a9a:	6025      	str	r5, [r4, #0]
    SET_GPIO_ALT(GPIO_MOSI, 0);
   11a9c:	f649 6360 	movw	r3, #40544	; 0x9e60
   11aa0:	f2c0 0302 	movt	r3, #2
   11aa4:	681b      	ldr	r3, [r3, #0]
   11aa6:	1d1c      	adds	r4, r3, #4
   11aa8:	f649 6360 	movw	r3, #40544	; 0x9e60
   11aac:	f2c0 0302 	movt	r3, #2
   11ab0:	681b      	ldr	r3, [r3, #0]
   11ab2:	1d1d      	adds	r5, r3, #4
   11ab4:	2d00      	cmp	r5, #0
   11ab6:	d106      	bne.n	11ac6 <cc1101_reset+0x30e>
   11ab8:	f649 2048 	movw	r0, #39496	; 0x9a48
   11abc:	f2c0 0002 	movt	r0, #2
   11ac0:	2100      	movs	r1, #0
   11ac2:	f7fe ef60 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11ac6:	682b      	ldr	r3, [r5, #0]
   11ac8:	f043 0504 	orr.w	r5, r3, #4
   11acc:	2c00      	cmp	r4, #0
   11ace:	d106      	bne.n	11ade <cc1101_reset+0x326>
   11ad0:	f649 2060 	movw	r0, #39520	; 0x9a60
   11ad4:	f2c0 0002 	movt	r0, #2
   11ad8:	2100      	movs	r1, #0
   11ada:	f7fe ef54 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11ade:	6025      	str	r5, [r4, #0]
}
   11ae0:	bdb0      	pop	{r4, r5, r7, pc}
   11ae2:	bf00      	nop

00011ae4 <cc1101_cfg_band>:

void cc1101_cfg_band(int fd, fset_t fset)
{
   11ae4:	b590      	push	{r4, r7, lr}
   11ae6:	b085      	sub	sp, #20
   11ae8:	af00      	add	r7, sp, #0
   11aea:	6078      	str	r0, [r7, #4]
   11aec:	6039      	str	r1, [r7, #0]
    uint8_t i;
    assert(fset >= ISM_EU && fset < ISM_MAX);
   11aee:	683b      	ldr	r3, [r7, #0]
   11af0:	2b02      	cmp	r3, #2
   11af2:	d90f      	bls.n	11b14 <cc1101_cfg_band+0x30>
   11af4:	f642 0060 	movw	r0, #10336	; 0x2860
   11af8:	f2c0 0001 	movt	r0, #1
   11afc:	f242 71dc 	movw	r1, #10204	; 0x27dc
   11b00:	f2c0 0101 	movt	r1, #1
   11b04:	f44f 7220 	mov.w	r2, #640	; 0x280
   11b08:	f642 2304 	movw	r3, #10756	; 0x2a04
   11b0c:	f2c0 0301 	movt	r3, #1
   11b10:	f7fe ef02 	blx	10918 <__assert_fail@plt>
    for ( i = 0; i < sizeof(band_regs)/sizeof(band_regs[0]); i++)
   11b14:	2300      	movs	r3, #0
   11b16:	73fb      	strb	r3, [r7, #15]
   11b18:	e01a      	b.n	11b50 <cc1101_cfg_band+0x6c>
    {
        write_reg(fd, band_regs[i], freq_config[fset][i], NULL);
   11b1a:	7bfa      	ldrb	r2, [r7, #15]
   11b1c:	f249 3384 	movw	r3, #37764	; 0x9384
   11b20:	f2c0 0302 	movt	r3, #2
   11b24:	5c9c      	ldrb	r4, [r3, r2]
   11b26:	7bf8      	ldrb	r0, [r7, #15]
   11b28:	f249 328c 	movw	r2, #37772	; 0x938c
   11b2c:	f2c0 0202 	movt	r2, #2
   11b30:	6839      	ldr	r1, [r7, #0]
   11b32:	460b      	mov	r3, r1
   11b34:	009b      	lsls	r3, r3, #2
   11b36:	440b      	add	r3, r1
   11b38:	4403      	add	r3, r0
   11b3a:	4413      	add	r3, r2
   11b3c:	781b      	ldrb	r3, [r3, #0]
   11b3e:	6878      	ldr	r0, [r7, #4]
   11b40:	4621      	mov	r1, r4
   11b42:	461a      	mov	r2, r3
   11b44:	2300      	movs	r3, #0
   11b46:	f7ff f8af 	bl	10ca8 <write_reg>

void cc1101_cfg_band(int fd, fset_t fset)
{
    uint8_t i;
    assert(fset >= ISM_EU && fset < ISM_MAX);
    for ( i = 0; i < sizeof(band_regs)/sizeof(band_regs[0]); i++)
   11b4a:	7bfb      	ldrb	r3, [r7, #15]
   11b4c:	3301      	adds	r3, #1
   11b4e:	73fb      	strb	r3, [r7, #15]
   11b50:	7bfb      	ldrb	r3, [r7, #15]
   11b52:	2b04      	cmp	r3, #4
   11b54:	d9e1      	bls.n	11b1a <cc1101_cfg_band+0x36>
    {
        write_reg(fd, band_regs[i], freq_config[fset][i], NULL);
    }
    
}
   11b56:	3714      	adds	r7, #20
   11b58:	46bd      	mov	sp, r7
   11b5a:	bd90      	pop	{r4, r7, pc}

00011b5c <cc1101_cfg_regs>:

void cc1101_cfg_regs(int fd)
{
   11b5c:	b580      	push	{r7, lr}
   11b5e:	b084      	sub	sp, #16
   11b60:	af00      	add	r7, sp, #0
   11b62:	6078      	str	r0, [r7, #4]
    uint32_t i;
    for (i = 0; i < sizeof(wbslRadioCfg)/sizeof(wbslRadioCfg[0]); i++)
   11b64:	2300      	movs	r3, #0
   11b66:	60fb      	str	r3, [r7, #12]
   11b68:	e01b      	b.n	11ba2 <cc1101_cfg_regs+0x46>
    {
        uint8_t reg = wbslRadioCfg[i][0];
   11b6a:	f242 63c0 	movw	r3, #9920	; 0x26c0
   11b6e:	f2c0 0301 	movt	r3, #1
   11b72:	68fa      	ldr	r2, [r7, #12]
   11b74:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
   11b78:	72fb      	strb	r3, [r7, #11]
        uint8_t val = wbslRadioCfg[i][1];
   11b7a:	f242 62c0 	movw	r2, #9920	; 0x26c0
   11b7e:	f2c0 0201 	movt	r2, #1
   11b82:	68fb      	ldr	r3, [r7, #12]
   11b84:	005b      	lsls	r3, r3, #1
   11b86:	4413      	add	r3, r2
   11b88:	785b      	ldrb	r3, [r3, #1]
   11b8a:	72bb      	strb	r3, [r7, #10]
        write_reg(fd, reg, val, NULL); 
   11b8c:	7afa      	ldrb	r2, [r7, #11]
   11b8e:	7abb      	ldrb	r3, [r7, #10]
   11b90:	6878      	ldr	r0, [r7, #4]
   11b92:	4611      	mov	r1, r2
   11b94:	461a      	mov	r2, r3
   11b96:	2300      	movs	r3, #0
   11b98:	f7ff f886 	bl	10ca8 <write_reg>
}

void cc1101_cfg_regs(int fd)
{
    uint32_t i;
    for (i = 0; i < sizeof(wbslRadioCfg)/sizeof(wbslRadioCfg[0]); i++)
   11b9c:	68fb      	ldr	r3, [r7, #12]
   11b9e:	3301      	adds	r3, #1
   11ba0:	60fb      	str	r3, [r7, #12]
   11ba2:	68fb      	ldr	r3, [r7, #12]
   11ba4:	2b25      	cmp	r3, #37	; 0x25
   11ba6:	d9e0      	bls.n	11b6a <cc1101_cfg_regs+0xe>
    {
        uint8_t reg = wbslRadioCfg[i][0];
        uint8_t val = wbslRadioCfg[i][1];
        write_reg(fd, reg, val, NULL); 
    }
    write_reg(fd, IOCFG0, WBSL_GDO_SYNC, NULL);
   11ba8:	6878      	ldr	r0, [r7, #4]
   11baa:	2102      	movs	r1, #2
   11bac:	2206      	movs	r2, #6
   11bae:	2300      	movs	r3, #0
   11bb0:	f7ff f87a 	bl	10ca8 <write_reg>
    write_reg(fd, IOCFG2, 7, NULL);
   11bb4:	6878      	ldr	r0, [r7, #4]
   11bb6:	2100      	movs	r1, #0
   11bb8:	2207      	movs	r2, #7
   11bba:	2300      	movs	r3, #0
   11bbc:	f7ff f874 	bl	10ca8 <write_reg>
}
   11bc0:	3710      	adds	r7, #16
   11bc2:	46bd      	mov	sp, r7
   11bc4:	bd80      	pop	{r7, pc}
   11bc6:	bf00      	nop

00011bc8 <cc1101_initialize>:


void cc1101_initialize(int fd, fset_t fset)
{
   11bc8:	b580      	push	{r7, lr}
   11bca:	b084      	sub	sp, #16
   11bcc:	af00      	add	r7, sp, #0
   11bce:	6078      	str	r0, [r7, #4]
   11bd0:	6039      	str	r1, [r7, #0]

    cc1101_reset();
   11bd2:	f7ff fdf1 	bl	117b8 <cc1101_reset>
    uint8_t response;
    strobe_cmd(fd, SRES, &response);
   11bd6:	f107 030f 	add.w	r3, r7, #15
   11bda:	6878      	ldr	r0, [r7, #4]
   11bdc:	2130      	movs	r1, #48	; 0x30
   11bde:	461a      	mov	r2, r3
   11be0:	f7ff fcd6 	bl	11590 <strobe_cmd>
    while (response & 0x70)
   11be4:	e00e      	b.n	11c04 <cc1101_initialize+0x3c>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
   11be6:	7bfb      	ldrb	r3, [r7, #15]
   11be8:	f642 0084 	movw	r0, #10372	; 0x2884
   11bec:	f2c0 0001 	movt	r0, #1
   11bf0:	4619      	mov	r1, r3
   11bf2:	f7fe eeb0 	blx	10954 <printf@plt>
        strobe_cmd(fd, SIDLE, &response);
   11bf6:	f107 030f 	add.w	r3, r7, #15
   11bfa:	6878      	ldr	r0, [r7, #4]
   11bfc:	2136      	movs	r1, #54	; 0x36
   11bfe:	461a      	mov	r2, r3
   11c00:	f7ff fcc6 	bl	11590 <strobe_cmd>
{

    cc1101_reset();
    uint8_t response;
    strobe_cmd(fd, SRES, &response);
    while (response & 0x70)
   11c04:	7bfb      	ldrb	r3, [r7, #15]
   11c06:	f003 0370 	and.w	r3, r3, #112	; 0x70
   11c0a:	2b00      	cmp	r3, #0
   11c0c:	d1eb      	bne.n	11be6 <cc1101_initialize+0x1e>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
        strobe_cmd(fd, SIDLE, &response);
    }

    cc1101_cfg_regs(fd);
   11c0e:	6878      	ldr	r0, [r7, #4]
   11c10:	f7ff ffa4 	bl	11b5c <cc1101_cfg_regs>
    cc1101_cfg_band(fd, fset);
   11c14:	6878      	ldr	r0, [r7, #4]
   11c16:	6839      	ldr	r1, [r7, #0]
   11c18:	f7ff ff64 	bl	11ae4 <cc1101_cfg_band>
}
   11c1c:	3710      	adds	r7, #16
   11c1e:	46bd      	mov	sp, r7
   11c20:	bd80      	pop	{r7, pc}
   11c22:	bf00      	nop

00011c24 <rxon>:

void rxon(int fd)
{
   11c24:	b580      	push	{r7, lr}
   11c26:	b082      	sub	sp, #8
   11c28:	af00      	add	r7, sp, #0
   11c2a:	6078      	str	r0, [r7, #4]
    strobe_cmd(fd, SRX, NULL); 
   11c2c:	6878      	ldr	r0, [r7, #4]
   11c2e:	2134      	movs	r1, #52	; 0x34
   11c30:	2200      	movs	r2, #0
   11c32:	f7ff fcad 	bl	11590 <strobe_cmd>
}
   11c36:	3708      	adds	r7, #8
   11c38:	46bd      	mov	sp, r7
   11c3a:	bd80      	pop	{r7, pc}

00011c3c <rxoff>:


void rxoff(int fd)
{
   11c3c:	b580      	push	{r7, lr}
   11c3e:	b084      	sub	sp, #16
   11c40:	af00      	add	r7, sp, #0
   11c42:	6078      	str	r0, [r7, #4]
    uint8_t response;
    strobe_cmd(fd, SFRX, &response);
   11c44:	f107 030f 	add.w	r3, r7, #15
   11c48:	6878      	ldr	r0, [r7, #4]
   11c4a:	213a      	movs	r1, #58	; 0x3a
   11c4c:	461a      	mov	r2, r3
   11c4e:	f7ff fc9f 	bl	11590 <strobe_cmd>
    strobe_cmd(fd, SIDLE, &response);
   11c52:	f107 030f 	add.w	r3, r7, #15
   11c56:	6878      	ldr	r0, [r7, #4]
   11c58:	2136      	movs	r1, #54	; 0x36
   11c5a:	461a      	mov	r2, r3
   11c5c:	f7ff fc98 	bl	11590 <strobe_cmd>
    while (response & 0x70)
   11c60:	e00e      	b.n	11c80 <rxoff+0x44>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
   11c62:	7bfb      	ldrb	r3, [r7, #15]
   11c64:	f642 0084 	movw	r0, #10372	; 0x2884
   11c68:	f2c0 0001 	movt	r0, #1
   11c6c:	4619      	mov	r1, r3
   11c6e:	f7fe ee72 	blx	10954 <printf@plt>
        strobe_cmd(fd, SIDLE, &response);
   11c72:	f107 030f 	add.w	r3, r7, #15
   11c76:	6878      	ldr	r0, [r7, #4]
   11c78:	2136      	movs	r1, #54	; 0x36
   11c7a:	461a      	mov	r2, r3
   11c7c:	f7ff fc88 	bl	11590 <strobe_cmd>
void rxoff(int fd)
{
    uint8_t response;
    strobe_cmd(fd, SFRX, &response);
    strobe_cmd(fd, SIDLE, &response);
    while (response & 0x70)
   11c80:	7bfb      	ldrb	r3, [r7, #15]
   11c82:	f003 0370 	and.w	r3, r3, #112	; 0x70
   11c86:	2b00      	cmp	r3, #0
   11c88:	d1eb      	bne.n	11c62 <rxoff+0x26>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
        strobe_cmd(fd, SIDLE, &response);
    }

}
   11c8a:	3710      	adds	r7, #16
   11c8c:	46bd      	mov	sp, r7
   11c8e:	bd80      	pop	{r7, pc}

00011c90 <txstart>:

void txstart(int fd)
{
   11c90:	b580      	push	{r7, lr}
   11c92:	b082      	sub	sp, #8
   11c94:	af00      	add	r7, sp, #0
   11c96:	6078      	str	r0, [r7, #4]
    strobe_cmd(fd, STX, NULL); 
   11c98:	6878      	ldr	r0, [r7, #4]
   11c9a:	2135      	movs	r1, #53	; 0x35
   11c9c:	2200      	movs	r2, #0
   11c9e:	f7ff fc77 	bl	11590 <strobe_cmd>
}
   11ca2:	3708      	adds	r7, #8
   11ca4:	46bd      	mov	sp, r7
   11ca6:	bd80      	pop	{r7, pc}

00011ca8 <txoff>:

void txoff(int fd)
{
   11ca8:	b580      	push	{r7, lr}
   11caa:	b084      	sub	sp, #16
   11cac:	af00      	add	r7, sp, #0
   11cae:	6078      	str	r0, [r7, #4]
    uint8_t response;
    strobe_cmd(fd, SFTX, &response);
   11cb0:	f107 030f 	add.w	r3, r7, #15
   11cb4:	6878      	ldr	r0, [r7, #4]
   11cb6:	213b      	movs	r1, #59	; 0x3b
   11cb8:	461a      	mov	r2, r3
   11cba:	f7ff fc69 	bl	11590 <strobe_cmd>
    strobe_cmd(fd, SIDLE, &response);
   11cbe:	f107 030f 	add.w	r3, r7, #15
   11cc2:	6878      	ldr	r0, [r7, #4]
   11cc4:	2136      	movs	r1, #54	; 0x36
   11cc6:	461a      	mov	r2, r3
   11cc8:	f7ff fc62 	bl	11590 <strobe_cmd>
    while (response & 0x70)
   11ccc:	e00e      	b.n	11cec <txoff+0x44>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
   11cce:	7bfb      	ldrb	r3, [r7, #15]
   11cd0:	f642 0084 	movw	r0, #10372	; 0x2884
   11cd4:	f2c0 0001 	movt	r0, #1
   11cd8:	4619      	mov	r1, r3
   11cda:	f7fe ee3c 	blx	10954 <printf@plt>
        strobe_cmd(fd, SIDLE, &response);
   11cde:	f107 030f 	add.w	r3, r7, #15
   11ce2:	6878      	ldr	r0, [r7, #4]
   11ce4:	2136      	movs	r1, #54	; 0x36
   11ce6:	461a      	mov	r2, r3
   11ce8:	f7ff fc52 	bl	11590 <strobe_cmd>
void txoff(int fd)
{
    uint8_t response;
    strobe_cmd(fd, SFTX, &response);
    strobe_cmd(fd, SIDLE, &response);
    while (response & 0x70)
   11cec:	7bfb      	ldrb	r3, [r7, #15]
   11cee:	f003 0370 	and.w	r3, r3, #112	; 0x70
   11cf2:	2b00      	cmp	r3, #0
   11cf4:	d1eb      	bne.n	11cce <txoff+0x26>
    {
        printf("Waiting for Radio to idle....%02X\n", response);
        strobe_cmd(fd, SIDLE, &response);
    }

}
   11cf6:	3710      	adds	r7, #16
   11cf8:	46bd      	mov	sp, r7
   11cfa:	bd80      	pop	{r7, pc}

00011cfc <CheckRx>:


uint8_t CheckRx(int fd)
{
   11cfc:	b590      	push	{r4, r7, lr}
   11cfe:	b085      	sub	sp, #20
   11d00:	af00      	add	r7, sp, #0
   11d02:	6078      	str	r0, [r7, #4]
    uint8_t bytes = 0;
   11d04:	2300      	movs	r3, #0
   11d06:	73bb      	strb	r3, [r7, #14]
    uint8_t marc_state = read_reg(fd, MARCSTATE, NULL) & 0x1f;
   11d08:	6878      	ldr	r0, [r7, #4]
   11d0a:	2135      	movs	r1, #53	; 0x35
   11d0c:	2200      	movs	r2, #0
   11d0e:	f7ff fb31 	bl	11374 <read_reg>
   11d12:	4603      	mov	r3, r0
   11d14:	f003 031f 	and.w	r3, r3, #31
   11d18:	737b      	strb	r3, [r7, #13]
    if (marc_state == 0x11)
   11d1a:	7b7b      	ldrb	r3, [r7, #13]
   11d1c:	2b11      	cmp	r3, #17
   11d1e:	d10b      	bne.n	11d38 <CheckRx+0x3c>
    {
        printf("RX overflow\n");
   11d20:	f642 00a8 	movw	r0, #10408	; 0x28a8
   11d24:	f2c0 0001 	movt	r0, #1
   11d28:	f7fe ee32 	blx	10990 <puts@plt>
        rxoff(fd);
   11d2c:	6878      	ldr	r0, [r7, #4]
   11d2e:	f7ff ff85 	bl	11c3c <rxoff>
        rxon(fd);
   11d32:	6878      	ldr	r0, [r7, #4]
   11d34:	f7ff ff76 	bl	11c24 <rxon>
    }
    if (!GET_GPIO(GPIO_GD2))
   11d38:	f649 6360 	movw	r3, #40544	; 0x9e60
   11d3c:	f2c0 0302 	movt	r3, #2
   11d40:	681b      	ldr	r3, [r3, #0]
   11d42:	f103 0434 	add.w	r4, r3, #52	; 0x34
   11d46:	2c00      	cmp	r4, #0
   11d48:	d106      	bne.n	11d58 <CheckRx+0x5c>
   11d4a:	f649 2078 	movw	r0, #39544	; 0x9a78
   11d4e:	f2c0 0002 	movt	r0, #2
   11d52:	2100      	movs	r1, #0
   11d54:	f7fe ee16 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11d58:	6823      	ldr	r3, [r4, #0]
   11d5a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
   11d5e:	2b00      	cmp	r3, #0
   11d60:	d101      	bne.n	11d66 <CheckRx+0x6a>
    {
        return 0;
   11d62:	2300      	movs	r3, #0
   11d64:	e037      	b.n	11dd6 <CheckRx+0xda>
    }
    else 
    {
        int8_t val = bytes = read_reg(fd,RXBYTES, NULL);
   11d66:	6878      	ldr	r0, [r7, #4]
   11d68:	213b      	movs	r1, #59	; 0x3b
   11d6a:	2200      	movs	r2, #0
   11d6c:	f7ff fb02 	bl	11374 <read_reg>
   11d70:	4603      	mov	r3, r0
   11d72:	73bb      	strb	r3, [r7, #14]
   11d74:	7bbb      	ldrb	r3, [r7, #14]
   11d76:	73fb      	strb	r3, [r7, #15]
        if (val)
   11d78:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11d7c:	2b00      	cmp	r3, #0
   11d7e:	d019      	beq.n	11db4 <CheckRx+0xb8>
        {
            int8_t tmpval = 0;
   11d80:	2300      	movs	r3, #0
   11d82:	733b      	strb	r3, [r7, #12]
            while (val != (tmpval = read_reg(fd, RXBYTES, NULL)))
   11d84:	e001      	b.n	11d8a <CheckRx+0x8e>
                val = tmpval;
   11d86:	7b3b      	ldrb	r3, [r7, #12]
   11d88:	73fb      	strb	r3, [r7, #15]
    {
        int8_t val = bytes = read_reg(fd,RXBYTES, NULL);
        if (val)
        {
            int8_t tmpval = 0;
            while (val != (tmpval = read_reg(fd, RXBYTES, NULL)))
   11d8a:	6878      	ldr	r0, [r7, #4]
   11d8c:	213b      	movs	r1, #59	; 0x3b
   11d8e:	2200      	movs	r2, #0
   11d90:	f7ff faf0 	bl	11374 <read_reg>
   11d94:	4603      	mov	r3, r0
   11d96:	733b      	strb	r3, [r7, #12]
   11d98:	f997 200c 	ldrsb.w	r2, [r7, #12]
   11d9c:	f997 300f 	ldrsb.w	r3, [r7, #15]
   11da0:	429a      	cmp	r2, r3
   11da2:	d1f0      	bne.n	11d86 <CheckRx+0x8a>
                val = tmpval;
            val = val & 0x7f;
   11da4:	7bfb      	ldrb	r3, [r7, #15]
   11da6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   11daa:	73fb      	strb	r3, [r7, #15]
            return bytes = val;
   11dac:	7bfb      	ldrb	r3, [r7, #15]
   11dae:	73bb      	strb	r3, [r7, #14]
   11db0:	7bbb      	ldrb	r3, [r7, #14]
   11db2:	e010      	b.n	11dd6 <CheckRx+0xda>
        }
        else
        {
            /* False Packet Detected ? */
            rxoff(fd); 
   11db4:	6878      	ldr	r0, [r7, #4]
   11db6:	f7ff ff41 	bl	11c3c <rxoff>
            rxon(fd);
   11dba:	6878      	ldr	r0, [r7, #4]
   11dbc:	f7ff ff32 	bl	11c24 <rxon>
            val = 0;
   11dc0:	2300      	movs	r3, #0
   11dc2:	73fb      	strb	r3, [r7, #15]
            bytes = 0;
   11dc4:	2300      	movs	r3, #0
   11dc6:	73bb      	strb	r3, [r7, #14]
            printf("Radio Reset due to false detection !!!\n");
   11dc8:	f642 00b4 	movw	r0, #10420	; 0x28b4
   11dcc:	f2c0 0001 	movt	r0, #1
   11dd0:	f7fe edde 	blx	10990 <puts@plt>
        }

      }

    return bytes;
   11dd4:	7bbb      	ldrb	r3, [r7, #14]
}
   11dd6:	4618      	mov	r0, r3
   11dd8:	3714      	adds	r7, #20
   11dda:	46bd      	mov	sp, r7
   11ddc:	bd90      	pop	{r4, r7, pc}
   11dde:	bf00      	nop

00011de0 <ReceivePkt>:

void ReceivePkt(int fd, uint8_t *pktbuf, uint8_t bytes)
{
   11de0:	b580      	push	{r7, lr}
   11de2:	b084      	sub	sp, #16
   11de4:	af00      	add	r7, sp, #0
   11de6:	60f8      	str	r0, [r7, #12]
   11de8:	60b9      	str	r1, [r7, #8]
   11dea:	4613      	mov	r3, r2
   11dec:	71fb      	strb	r3, [r7, #7]
    read_reg_burst(fd, RXFIFO, bytes, pktbuf); 
   11dee:	79fb      	ldrb	r3, [r7, #7]
   11df0:	68f8      	ldr	r0, [r7, #12]
   11df2:	213f      	movs	r1, #63	; 0x3f
   11df4:	461a      	mov	r2, r3
   11df6:	68bb      	ldr	r3, [r7, #8]
   11df8:	f7ff f840 	bl	10e7c <read_reg_burst>
}
   11dfc:	3710      	adds	r7, #16
   11dfe:	46bd      	mov	sp, r7
   11e00:	bd80      	pop	{r7, pc}
   11e02:	bf00      	nop

00011e04 <TransmitPkt>:

void TransmitPkt(int fd, uint8_t *payload, uint8_t len)
{
   11e04:	b5b0      	push	{r4, r5, r7, lr}
   11e06:	b084      	sub	sp, #16
   11e08:	af00      	add	r7, sp, #0
   11e0a:	60f8      	str	r0, [r7, #12]
   11e0c:	60b9      	str	r1, [r7, #8]
   11e0e:	4613      	mov	r3, r2
   11e10:	71fb      	strb	r3, [r7, #7]
    /*convert to State machine*/
    rxoff(fd);
   11e12:	68f8      	ldr	r0, [r7, #12]
   11e14:	f7ff ff12 	bl	11c3c <rxoff>
    assert(payload[0] == len - 1);
   11e18:	68bb      	ldr	r3, [r7, #8]
   11e1a:	2b00      	cmp	r3, #0
   11e1c:	d106      	bne.n	11e2c <TransmitPkt+0x28>
   11e1e:	f649 2090 	movw	r0, #39568	; 0x9a90
   11e22:	f2c0 0002 	movt	r0, #2
   11e26:	2100      	movs	r1, #0
   11e28:	f7fe edac 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11e2c:	68bb      	ldr	r3, [r7, #8]
   11e2e:	781b      	ldrb	r3, [r3, #0]
   11e30:	461d      	mov	r5, r3
   11e32:	79fb      	ldrb	r3, [r7, #7]
   11e34:	1e5c      	subs	r4, r3, #1
   11e36:	f04f 32ff 	mov.w	r2, #4294967295
   11e3a:	2a00      	cmp	r2, #0
   11e3c:	db02      	blt.n	11e44 <TransmitPkt+0x40>
   11e3e:	429c      	cmp	r4, r3
   11e40:	da0b      	bge.n	11e5a <TransmitPkt+0x56>
   11e42:	e001      	b.n	11e48 <TransmitPkt+0x44>
   11e44:	429c      	cmp	r4, r3
   11e46:	dd08      	ble.n	11e5a <TransmitPkt+0x56>
   11e48:	f649 20d8 	movw	r0, #39640	; 0x9ad8
   11e4c:	f2c0 0002 	movt	r0, #2
   11e50:	4619      	mov	r1, r3
   11e52:	f04f 32ff 	mov.w	r2, #4294967295
   11e56:	f7fe ed78 	blx	10948 <__ubsan_handle_add_overflow@plt>
   11e5a:	4623      	mov	r3, r4
   11e5c:	429d      	cmp	r5, r3
   11e5e:	d00f      	beq.n	11e80 <TransmitPkt+0x7c>
   11e60:	f642 00dc 	movw	r0, #10460	; 0x28dc
   11e64:	f2c0 0001 	movt	r0, #1
   11e68:	f242 71dc 	movw	r1, #10204	; 0x27dc
   11e6c:	f2c0 0101 	movt	r1, #1
   11e70:	f240 22fd 	movw	r2, #765	; 0x2fd
   11e74:	f642 2314 	movw	r3, #10772	; 0x2a14
   11e78:	f2c0 0301 	movt	r3, #1
   11e7c:	f7fe ed4c 	blx	10918 <__assert_fail@plt>
    write_reg_burst(fd, TXFIFO, payload, len);
   11e80:	79fb      	ldrb	r3, [r7, #7]
   11e82:	68f8      	ldr	r0, [r7, #12]
   11e84:	213f      	movs	r1, #63	; 0x3f
   11e86:	68ba      	ldr	r2, [r7, #8]
   11e88:	f7ff f926 	bl	110d8 <write_reg_burst>
    txstart(fd);
   11e8c:	68f8      	ldr	r0, [r7, #12]
   11e8e:	f7ff feff 	bl	11c90 <txstart>
    while(!GET_GPIO(GPIO_GD0));
   11e92:	bf00      	nop
   11e94:	f649 6360 	movw	r3, #40544	; 0x9e60
   11e98:	f2c0 0302 	movt	r3, #2
   11e9c:	681b      	ldr	r3, [r3, #0]
   11e9e:	f103 0434 	add.w	r4, r3, #52	; 0x34
   11ea2:	2c00      	cmp	r4, #0
   11ea4:	d106      	bne.n	11eb4 <TransmitPkt+0xb0>
   11ea6:	f649 20a8 	movw	r0, #39592	; 0x9aa8
   11eaa:	f2c0 0002 	movt	r0, #2
   11eae:	2100      	movs	r1, #0
   11eb0:	f7fe ed68 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11eb4:	6823      	ldr	r3, [r4, #0]
   11eb6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
   11eba:	2b00      	cmp	r3, #0
   11ebc:	d0ea      	beq.n	11e94 <TransmitPkt+0x90>
    while(GET_GPIO(GPIO_GD0));
   11ebe:	bf00      	nop
   11ec0:	f649 6360 	movw	r3, #40544	; 0x9e60
   11ec4:	f2c0 0302 	movt	r3, #2
   11ec8:	681b      	ldr	r3, [r3, #0]
   11eca:	f103 0434 	add.w	r4, r3, #52	; 0x34
   11ece:	2c00      	cmp	r4, #0
   11ed0:	d106      	bne.n	11ee0 <TransmitPkt+0xdc>
   11ed2:	f649 20c0 	movw	r0, #39616	; 0x9ac0
   11ed6:	f2c0 0002 	movt	r0, #2
   11eda:	2100      	movs	r1, #0
   11edc:	f7fe ed52 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11ee0:	6823      	ldr	r3, [r4, #0]
   11ee2:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
   11ee6:	2b00      	cmp	r3, #0
   11ee8:	d1ea      	bne.n	11ec0 <TransmitPkt+0xbc>
}
   11eea:	3710      	adds	r7, #16
   11eec:	46bd      	mov	sp, r7
   11eee:	bdb0      	pop	{r4, r5, r7, pc}

00011ef0 <WaitRx>:

uint8_t RxPktBuf[256];
uint8_t WaitRx(int fd)
{
   11ef0:	b580      	push	{r7, lr}
   11ef2:	b084      	sub	sp, #16
   11ef4:	af00      	add	r7, sp, #0
   11ef6:	6078      	str	r0, [r7, #4]
    uint8_t len = 0;
   11ef8:	2300      	movs	r3, #0
   11efa:	73fb      	strb	r3, [r7, #15]
    while (!(len = CheckRx(fd)))
   11efc:	6878      	ldr	r0, [r7, #4]
   11efe:	f7ff fefd 	bl	11cfc <CheckRx>
   11f02:	4603      	mov	r3, r0
   11f04:	73fb      	strb	r3, [r7, #15]
   11f06:	7bfb      	ldrb	r3, [r7, #15]
   11f08:	2b00      	cmp	r3, #0
   11f0a:	d0f7      	beq.n	11efc <WaitRx+0xc>
        ;
    return len;
   11f0c:	7bfb      	ldrb	r3, [r7, #15]
}
   11f0e:	4618      	mov	r0, r3
   11f10:	3710      	adds	r7, #16
   11f12:	46bd      	mov	sp, r7
   11f14:	bd80      	pop	{r7, pc}
   11f16:	bf00      	nop

00011f18 <GetPacket>:

uint8_t GetPacket(int fd, uint8_t *pktbuf)
{
   11f18:	b590      	push	{r4, r7, lr}
   11f1a:	b089      	sub	sp, #36	; 0x24
   11f1c:	af00      	add	r7, sp, #0
   11f1e:	6078      	str	r0, [r7, #4]
   11f20:	6039      	str	r1, [r7, #0]
    uint8_t len;
    rxon(fd);
   11f22:	6878      	ldr	r0, [r7, #4]
   11f24:	f7ff fe7e 	bl	11c24 <rxon>
    if((len = WaitRx(fd)))
   11f28:	6878      	ldr	r0, [r7, #4]
   11f2a:	f7ff ffe1 	bl	11ef0 <WaitRx>
   11f2e:	4603      	mov	r3, r0
   11f30:	77fb      	strb	r3, [r7, #31]
   11f32:	7ffb      	ldrb	r3, [r7, #31]
   11f34:	2b00      	cmp	r3, #0
   11f36:	f000 80b4 	beq.w	120a2 <GetPacket+0x18a>
    {
        uint32_t j = 0;
   11f3a:	2300      	movs	r3, #0
   11f3c:	61bb      	str	r3, [r7, #24]
        uint8_t clqi = 0, rssi = 0;
   11f3e:	2300      	movs	r3, #0
   11f40:	75fb      	strb	r3, [r7, #23]
   11f42:	2300      	movs	r3, #0
   11f44:	75bb      	strb	r3, [r7, #22]
        struct timespec now;
        clock_gettime(CLOCK_REALTIME, &now);
   11f46:	f107 030c 	add.w	r3, r7, #12
   11f4a:	2000      	movs	r0, #0
   11f4c:	4619      	mov	r1, r3
   11f4e:	f7fe ecc0 	blx	108d0 <clock_gettime@plt>
        printf("Time %ld.%09ld ", now.tv_sec, now.tv_nsec);
   11f52:	68fa      	ldr	r2, [r7, #12]
   11f54:	693b      	ldr	r3, [r7, #16]
   11f56:	f642 00f4 	movw	r0, #10484	; 0x28f4
   11f5a:	f2c0 0001 	movt	r0, #1
   11f5e:	4611      	mov	r1, r2
   11f60:	461a      	mov	r2, r3
   11f62:	f7fe ecf8 	blx	10954 <printf@plt>
        printf("Len:%x ", len); 
   11f66:	7ffb      	ldrb	r3, [r7, #31]
   11f68:	f642 1004 	movw	r0, #10500	; 0x2904
   11f6c:	f2c0 0001 	movt	r0, #1
   11f70:	4619      	mov	r1, r3
   11f72:	f7fe ecf0 	blx	10954 <printf@plt>
        ReceivePkt(fd, pktbuf, len);
   11f76:	7ffb      	ldrb	r3, [r7, #31]
   11f78:	6878      	ldr	r0, [r7, #4]
   11f7a:	6839      	ldr	r1, [r7, #0]
   11f7c:	461a      	mov	r2, r3
   11f7e:	f7ff ff2f 	bl	11de0 <ReceivePkt>
        clqi = pktbuf[pktbuf[0] + 2];
   11f82:	683b      	ldr	r3, [r7, #0]
   11f84:	2b00      	cmp	r3, #0
   11f86:	d106      	bne.n	11f96 <GetPacket+0x7e>
   11f88:	f649 20e8 	movw	r0, #39656	; 0x9ae8
   11f8c:	f2c0 0002 	movt	r0, #2
   11f90:	2100      	movs	r1, #0
   11f92:	f7fe ecf8 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11f96:	683b      	ldr	r3, [r7, #0]
   11f98:	781b      	ldrb	r3, [r3, #0]
   11f9a:	3302      	adds	r3, #2
   11f9c:	683a      	ldr	r2, [r7, #0]
   11f9e:	18d4      	adds	r4, r2, r3
   11fa0:	2c00      	cmp	r4, #0
   11fa2:	d106      	bne.n	11fb2 <GetPacket+0x9a>
   11fa4:	f649 3000 	movw	r0, #39680	; 0x9b00
   11fa8:	f2c0 0002 	movt	r0, #2
   11fac:	2100      	movs	r1, #0
   11fae:	f7fe ecea 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11fb2:	7823      	ldrb	r3, [r4, #0]
   11fb4:	75fb      	strb	r3, [r7, #23]
        rssi =  pktbuf[pktbuf[0] + 1];
   11fb6:	683b      	ldr	r3, [r7, #0]
   11fb8:	2b00      	cmp	r3, #0
   11fba:	d106      	bne.n	11fca <GetPacket+0xb2>
   11fbc:	f649 3018 	movw	r0, #39704	; 0x9b18
   11fc0:	f2c0 0002 	movt	r0, #2
   11fc4:	2100      	movs	r1, #0
   11fc6:	f7fe ecde 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11fca:	683b      	ldr	r3, [r7, #0]
   11fcc:	781b      	ldrb	r3, [r3, #0]
   11fce:	3301      	adds	r3, #1
   11fd0:	683a      	ldr	r2, [r7, #0]
   11fd2:	18d4      	adds	r4, r2, r3
   11fd4:	2c00      	cmp	r4, #0
   11fd6:	d106      	bne.n	11fe6 <GetPacket+0xce>
   11fd8:	f649 3030 	movw	r0, #39728	; 0x9b30
   11fdc:	f2c0 0002 	movt	r0, #2
   11fe0:	2100      	movs	r1, #0
   11fe2:	f7fe ecd0 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   11fe6:	7823      	ldrb	r3, [r4, #0]
   11fe8:	75bb      	strb	r3, [r7, #22]
        printf("RSSI:%02X LQI : %02X ", rssi, (clqi & 0x7f));
   11fea:	7dba      	ldrb	r2, [r7, #22]
   11fec:	7dfb      	ldrb	r3, [r7, #23]
   11fee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   11ff2:	f642 100c 	movw	r0, #10508	; 0x290c
   11ff6:	f2c0 0001 	movt	r0, #1
   11ffa:	4611      	mov	r1, r2
   11ffc:	461a      	mov	r2, r3
   11ffe:	f7fe ecaa 	blx	10954 <printf@plt>
        if (clqi & 0x80)
   12002:	7dfb      	ldrb	r3, [r7, #23]
   12004:	b25b      	sxtb	r3, r3
   12006:	2b00      	cmp	r3, #0
   12008:	da06      	bge.n	12018 <GetPacket+0x100>
            printf("CRC:OK\n");
   1200a:	f642 1024 	movw	r0, #10532	; 0x2924
   1200e:	f2c0 0001 	movt	r0, #1
   12012:	f7fe ecbe 	blx	10990 <puts@plt>
   12016:	e007      	b.n	12028 <GetPacket+0x110>
        else
        {
            printf("CRC:Fail\n");
   12018:	f642 102c 	movw	r0, #10540	; 0x292c
   1201c:	f2c0 0001 	movt	r0, #1
   12020:	f7fe ecb6 	blx	10990 <puts@plt>
            len = 0;
   12024:	2300      	movs	r3, #0
   12026:	77fb      	strb	r3, [r7, #31]
        }
        for (j = 0; j < len; j++)
   12028:	2300      	movs	r3, #0
   1202a:	61bb      	str	r3, [r7, #24]
   1202c:	e02a      	b.n	12084 <GetPacket+0x16c>
        {
            if ( (4*j + 1) % 80 == false)
   1202e:	69bb      	ldr	r3, [r7, #24]
   12030:	009b      	lsls	r3, r3, #2
   12032:	1c59      	adds	r1, r3, #1
   12034:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   12038:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
   1203c:	fba1 2303 	umull	r2, r3, r1, r3
   12040:	099a      	lsrs	r2, r3, #6
   12042:	4613      	mov	r3, r2
   12044:	009b      	lsls	r3, r3, #2
   12046:	4413      	add	r3, r2
   12048:	011b      	lsls	r3, r3, #4
   1204a:	1aca      	subs	r2, r1, r3
   1204c:	2a00      	cmp	r2, #0
   1204e:	d102      	bne.n	12056 <GetPacket+0x13e>
                printf("\n");
   12050:	200a      	movs	r0, #10
   12052:	f7fe ec4a 	blx	108e8 <putchar@plt>
           printf(" %02X ", pktbuf[j]);
   12056:	683a      	ldr	r2, [r7, #0]
   12058:	69bb      	ldr	r3, [r7, #24]
   1205a:	18d4      	adds	r4, r2, r3
   1205c:	2c00      	cmp	r4, #0
   1205e:	d106      	bne.n	1206e <GetPacket+0x156>
   12060:	f649 3048 	movw	r0, #39752	; 0x9b48
   12064:	f2c0 0002 	movt	r0, #2
   12068:	2100      	movs	r1, #0
   1206a:	f7fe ec8c 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1206e:	7823      	ldrb	r3, [r4, #0]
   12070:	f642 1038 	movw	r0, #10552	; 0x2938
   12074:	f2c0 0001 	movt	r0, #1
   12078:	4619      	mov	r1, r3
   1207a:	f7fe ec6c 	blx	10954 <printf@plt>
        else
        {
            printf("CRC:Fail\n");
            len = 0;
        }
        for (j = 0; j < len; j++)
   1207e:	69bb      	ldr	r3, [r7, #24]
   12080:	3301      	adds	r3, #1
   12082:	61bb      	str	r3, [r7, #24]
   12084:	7ffa      	ldrb	r2, [r7, #31]
   12086:	69bb      	ldr	r3, [r7, #24]
   12088:	429a      	cmp	r2, r3
   1208a:	d8d0      	bhi.n	1202e <GetPacket+0x116>
        {
            if ( (4*j + 1) % 80 == false)
                printf("\n");
           printf(" %02X ", pktbuf[j]);
        }
        printf("\n");
   1208c:	200a      	movs	r0, #10
   1208e:	f7fe ec2c 	blx	108e8 <putchar@plt>
        fflush(stdout);
   12092:	f649 534c 	movw	r3, #40268	; 0x9d4c
   12096:	f2c0 0302 	movt	r3, #2
   1209a:	681b      	ldr	r3, [r3, #0]
   1209c:	4618      	mov	r0, r3
   1209e:	f7fe ec48 	blx	10930 <fflush@plt>
        //nanosleep(&sleepval, NULL);
    }
    return len;
   120a2:	7ffb      	ldrb	r3, [r7, #31]
}
   120a4:	4618      	mov	r0, r3
   120a6:	3724      	adds	r7, #36	; 0x24
   120a8:	46bd      	mov	sp, r7
   120aa:	bd90      	pop	{r4, r7, pc}

000120ac <wait_for_discovery>:
}__attribute__((packed)) wbsl_data_ack_t;

uint8_t linked, epaddr;

void wait_for_discovery(int fd, int force)
{
   120ac:	b580      	push	{r7, lr}
   120ae:	b086      	sub	sp, #24
   120b0:	af00      	add	r7, sp, #0
   120b2:	6078      	str	r0, [r7, #4]
   120b4:	6039      	str	r1, [r7, #0]
    uint8_t discoveryPayload[]= {0xBA,0x5E,0xBA,0x11};
   120b6:	f642 1360 	movw	r3, #10592	; 0x2960
   120ba:	f2c0 0301 	movt	r3, #1
   120be:	f107 020c 	add.w	r2, r7, #12
   120c2:	6818      	ldr	r0, [r3, #0]
   120c4:	6010      	str	r0, [r2, #0]
    uint8_t len = 0;
   120c6:	2300      	movs	r3, #0
   120c8:	75fb      	strb	r3, [r7, #23]
    wbsl_disc_pkt_t *disc = (wbsl_disc_pkt_t *)RxPktBuf;
   120ca:	f649 5360 	movw	r3, #40288	; 0x9d60
   120ce:	f2c0 0302 	movt	r3, #2
   120d2:	613b      	str	r3, [r7, #16]
    while (!linked || force)
   120d4:	e058      	b.n	12188 <wait_for_discovery+0xdc>
    {
        len = GetPacket(fd, RxPktBuf);
   120d6:	6878      	ldr	r0, [r7, #4]
   120d8:	f649 5160 	movw	r1, #40288	; 0x9d60
   120dc:	f2c0 0102 	movt	r1, #2
   120e0:	f7ff ff1a 	bl	11f18 <GetPacket>
   120e4:	4603      	mov	r3, r0
   120e6:	75fb      	strb	r3, [r7, #23]
        if (len < 7)
   120e8:	7dfb      	ldrb	r3, [r7, #23]
   120ea:	2b06      	cmp	r3, #6
   120ec:	d800      	bhi.n	120f0 <wait_for_discovery+0x44>
            continue;
   120ee:	e04b      	b.n	12188 <wait_for_discovery+0xdc>
        if (!disc->hdr.da && !memcmp(discoveryPayload, disc->payload, sizeof(discoveryPayload)))
   120f0:	693b      	ldr	r3, [r7, #16]
   120f2:	2b00      	cmp	r3, #0
   120f4:	d106      	bne.n	12104 <wait_for_discovery+0x58>
   120f6:	f649 3080 	movw	r0, #39808	; 0x9b80
   120fa:	f2c0 0002 	movt	r0, #2
   120fe:	2100      	movs	r1, #0
   12100:	f7fe ec40 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   12104:	693b      	ldr	r3, [r7, #16]
   12106:	785b      	ldrb	r3, [r3, #1]
   12108:	2b00      	cmp	r3, #0
   1210a:	d136      	bne.n	1217a <wait_for_discovery+0xce>
   1210c:	693b      	ldr	r3, [r7, #16]
   1210e:	3304      	adds	r3, #4
   12110:	f107 020c 	add.w	r2, r7, #12
   12114:	4610      	mov	r0, r2
   12116:	4619      	mov	r1, r3
   12118:	2204      	movs	r2, #4
   1211a:	f7fe ebce 	blx	108b8 <memcmp@plt>
   1211e:	4603      	mov	r3, r0
   12120:	2b00      	cmp	r3, #0
   12122:	d12a      	bne.n	1217a <wait_for_discovery+0xce>
        {
            printf("Discovered %02X\n", disc->hdr.ta);
   12124:	693b      	ldr	r3, [r7, #16]
   12126:	2b00      	cmp	r3, #0
   12128:	d106      	bne.n	12138 <wait_for_discovery+0x8c>
   1212a:	f649 3098 	movw	r0, #39832	; 0x9b98
   1212e:	f2c0 0002 	movt	r0, #2
   12132:	2100      	movs	r1, #0
   12134:	f7fe ec26 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   12138:	693b      	ldr	r3, [r7, #16]
   1213a:	789b      	ldrb	r3, [r3, #2]
   1213c:	f642 1040 	movw	r0, #10560	; 0x2940
   12140:	f2c0 0001 	movt	r0, #1
   12144:	4619      	mov	r1, r3
   12146:	f7fe ec06 	blx	10954 <printf@plt>
            epaddr = disc->hdr.ta;
   1214a:	693b      	ldr	r3, [r7, #16]
   1214c:	2b00      	cmp	r3, #0
   1214e:	d106      	bne.n	1215e <wait_for_discovery+0xb2>
   12150:	f649 30b0 	movw	r0, #39856	; 0x9bb0
   12154:	f2c0 0002 	movt	r0, #2
   12158:	2100      	movs	r1, #0
   1215a:	f7fe ec14 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1215e:	693b      	ldr	r3, [r7, #16]
   12160:	789a      	ldrb	r2, [r3, #2]
   12162:	f649 5358 	movw	r3, #40280	; 0x9d58
   12166:	f2c0 0302 	movt	r3, #2
   1216a:	701a      	strb	r2, [r3, #0]
            linked = true;
   1216c:	f649 6364 	movw	r3, #40548	; 0x9e64
   12170:	f2c0 0302 	movt	r3, #2
   12174:	2201      	movs	r2, #1
   12176:	701a      	strb	r2, [r3, #0]
   12178:	e006      	b.n	12188 <wait_for_discovery+0xdc>
        }
        else
        {
            printf("Not Disc\n");
   1217a:	f642 1054 	movw	r0, #10580	; 0x2954
   1217e:	f2c0 0001 	movt	r0, #1
   12182:	f7fe ec06 	blx	10990 <puts@plt>
            continue;
   12186:	bf00      	nop
void wait_for_discovery(int fd, int force)
{
    uint8_t discoveryPayload[]= {0xBA,0x5E,0xBA,0x11};
    uint8_t len = 0;
    wbsl_disc_pkt_t *disc = (wbsl_disc_pkt_t *)RxPktBuf;
    while (!linked || force)
   12188:	f649 6364 	movw	r3, #40548	; 0x9e64
   1218c:	f2c0 0302 	movt	r3, #2
   12190:	781b      	ldrb	r3, [r3, #0]
   12192:	2b00      	cmp	r3, #0
   12194:	d09f      	beq.n	120d6 <wait_for_discovery+0x2a>
   12196:	683b      	ldr	r3, [r7, #0]
   12198:	2b00      	cmp	r3, #0
   1219a:	d19c      	bne.n	120d6 <wait_for_discovery+0x2a>
        {
            printf("Not Disc\n");
            continue;
        }
    }
}
   1219c:	3718      	adds	r7, #24
   1219e:	46bd      	mov	sp, r7
   121a0:	bd80      	pop	{r7, pc}
   121a2:	bf00      	nop

000121a4 <send_disc_ack>:


void send_disc_ack(int fd)
{
   121a4:	b580      	push	{r7, lr}
   121a6:	b084      	sub	sp, #16
   121a8:	af00      	add	r7, sp, #0
   121aa:	6078      	str	r0, [r7, #4]
    wbsl_disc_ack_t dack = {
   121ac:	2303      	movs	r3, #3
   121ae:	733b      	strb	r3, [r7, #12]
   121b0:	f649 5358 	movw	r3, #40280	; 0x9d58
   121b4:	f2c0 0302 	movt	r3, #2
   121b8:	781b      	ldrb	r3, [r3, #0]
   121ba:	737b      	strb	r3, [r7, #13]
   121bc:	23ca      	movs	r3, #202	; 0xca
   121be:	73bb      	strb	r3, [r7, #14]
   121c0:	2301      	movs	r3, #1
   121c2:	73fb      	strb	r3, [r7, #15]
        .len = sizeof(dack) - sizeof(dack.len), 
        .hdr = { .da = epaddr, 
            .ta = WBSL_AP_ADDRESS}, 
        .status = WBSL_ACK_STATUS_SUCCESS };
    TransmitPkt(fd, (uint8_t *)&dack, sizeof(dack));
   121c4:	f107 030c 	add.w	r3, r7, #12
   121c8:	6878      	ldr	r0, [r7, #4]
   121ca:	4619      	mov	r1, r3
   121cc:	2204      	movs	r2, #4
   121ce:	f7ff fe19 	bl	11e04 <TransmitPkt>
}
   121d2:	3710      	adds	r7, #16
   121d4:	46bd      	mov	sp, r7
   121d6:	bd80      	pop	{r7, pc}

000121d8 <start_update>:

uint8_t init_packet[] = { 5, 0xad, 0xca, 0, 0 ,0}; 
int start_update(int fd)
{
   121d8:	b5b0      	push	{r4, r5, r7, lr}
   121da:	b08c      	sub	sp, #48	; 0x30
   121dc:	af00      	add	r7, sp, #0
   121de:	6078      	str	r0, [r7, #4]
    int i;
    int j;
    uint8_t retx = 0;
   121e0:	2300      	movs	r3, #0
   121e2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    uint8_t len = 0;
   121e6:	2300      	movs	r3, #0
   121e8:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
    struct timespec ack_timeout = { .tv_nsec = 20000};
   121ec:	2300      	movs	r3, #0
   121ee:	617b      	str	r3, [r7, #20]
   121f0:	2300      	movs	r3, #0
   121f2:	61bb      	str	r3, [r7, #24]
   121f4:	f644 6320 	movw	r3, #20000	; 0x4e20
   121f8:	61bb      	str	r3, [r7, #24]
    struct timespec wait_restart = { .tv_nsec = 200000};
   121fa:	2300      	movs	r3, #0
   121fc:	60fb      	str	r3, [r7, #12]
   121fe:	2300      	movs	r3, #0
   12200:	613b      	str	r3, [r7, #16]
   12202:	f44f 6354 	mov.w	r3, #3392	; 0xd40
   12206:	f2c0 0303 	movt	r3, #3
   1220a:	613b      	str	r3, [r7, #16]
    for ( i = 0; i <  sizeof(npkts)/sizeof(npkts[0]); i++)
   1220c:	2300      	movs	r3, #0
   1220e:	62fb      	str	r3, [r7, #44]	; 0x2c
   12210:	e17d      	b.n	1250e <start_update+0x336>
    {  
        wait_for_discovery(fd, false);
   12212:	6878      	ldr	r0, [r7, #4]
   12214:	2100      	movs	r1, #0
   12216:	f7ff ff49 	bl	120ac <wait_for_discovery>
        nanosleep(&ack_timeout, NULL);
   1221a:	f107 0314 	add.w	r3, r7, #20
   1221e:	4618      	mov	r0, r3
   12220:	2100      	movs	r1, #0
   12222:	f7fe ebbc 	blx	1099c <nanosleep@plt>
        send_disc_ack(fd);
   12226:	6878      	ldr	r0, [r7, #4]
   12228:	f7ff ffbc 	bl	121a4 <send_disc_ack>
        init_packet[3] = npkts[i] & 0xff;
   1222c:	f642 33bc 	movw	r3, #11196	; 0x2bbc
   12230:	f2c0 0302 	movt	r3, #2
   12234:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   12236:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   1223a:	b2da      	uxtb	r2, r3
   1223c:	f649 33c8 	movw	r3, #39880	; 0x9bc8
   12240:	f2c0 0302 	movt	r3, #2
   12244:	70da      	strb	r2, [r3, #3]
        init_packet[4] = (npkts[i] >> 8 ) & 0xff;
   12246:	f642 33bc 	movw	r3, #11196	; 0x2bbc
   1224a:	f2c0 0302 	movt	r3, #2
   1224e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   12250:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   12254:	0a1b      	lsrs	r3, r3, #8
   12256:	b29b      	uxth	r3, r3
   12258:	b2da      	uxtb	r2, r3
   1225a:	f649 33c8 	movw	r3, #39880	; 0x9bc8
   1225e:	f2c0 0302 	movt	r3, #2
   12262:	711a      	strb	r2, [r3, #4]
        while(1) {
            retx++;
   12264:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   12268:	3301      	adds	r3, #1
   1226a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
            init_packet[5] = 1;
   1226e:	f649 33c8 	movw	r3, #39880	; 0x9bc8
   12272:	f2c0 0302 	movt	r3, #2
   12276:	2201      	movs	r2, #1
   12278:	715a      	strb	r2, [r3, #5]
            TransmitPkt(fd, init_packet, sizeof(init_packet));
   1227a:	6878      	ldr	r0, [r7, #4]
   1227c:	f649 31c8 	movw	r1, #39880	; 0x9bc8
   12280:	f2c0 0102 	movt	r1, #2
   12284:	2206      	movs	r2, #6
   12286:	f7ff fdbd 	bl	11e04 <TransmitPkt>
            nanosleep(&ack_timeout, NULL);
   1228a:	f107 0314 	add.w	r3, r7, #20
   1228e:	4618      	mov	r0, r3
   12290:	2100      	movs	r1, #0
   12292:	f7fe eb84 	blx	1099c <nanosleep@plt>
            if((len = GetPacket(fd, RxPktBuf)))
   12296:	6878      	ldr	r0, [r7, #4]
   12298:	f649 5160 	movw	r1, #40288	; 0x9d60
   1229c:	f2c0 0102 	movt	r1, #2
   122a0:	f7ff fe3a 	bl	11f18 <GetPacket>
   122a4:	4603      	mov	r3, r0
   122a6:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
   122aa:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
   122ae:	2b00      	cmp	r3, #0
   122b0:	d012      	beq.n	122d8 <start_update+0x100>
            {
               printf("Success Init Packet\n");
   122b2:	f642 1064 	movw	r0, #10596	; 0x2964
   122b6:	f2c0 0001 	movt	r0, #1
   122ba:	f7fe eb6a 	blx	10990 <puts@plt>
               retx = 0;
   122be:	2300      	movs	r3, #0
   122c0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
               break;
   122c4:	bf00      	nop
            }
        }

        nanosleep(&ack_timeout, NULL);
   122c6:	f107 0314 	add.w	r3, r7, #20
   122ca:	4618      	mov	r0, r3
   122cc:	2100      	movs	r1, #0
   122ce:	f7fe eb66 	blx	1099c <nanosleep@plt>

        for(j = 0; j < npkts[i]; j++)
   122d2:	2300      	movs	r3, #0
   122d4:	62bb      	str	r3, [r7, #40]	; 0x28
   122d6:	e0ec      	b.n	124b2 <start_update+0x2da>
            {
               printf("Success Init Packet\n");
               retx = 0;
               break;
            }
        }
   122d8:	e7c4      	b.n	12264 <start_update+0x8c>

        nanosleep(&ack_timeout, NULL);

        for(j = 0; j < npkts[i]; j++)
        {
            TransmitPkt(fd, packets[i][j], packets[i][j][0]+1);
   122da:	f648 1264 	movw	r2, #35172	; 0x8964
   122de:	f2c0 0202 	movt	r2, #2
   122e2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   122e4:	460b      	mov	r3, r1
   122e6:	00db      	lsls	r3, r3, #3
   122e8:	440b      	add	r3, r1
   122ea:	005b      	lsls	r3, r3, #1
   122ec:	440b      	add	r3, r1
   122ee:	0119      	lsls	r1, r3, #4
   122f0:	440b      	add	r3, r1
   122f2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   122f4:	440b      	add	r3, r1
   122f6:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   122fa:	f648 1264 	movw	r2, #35172	; 0x8964
   122fe:	f2c0 0202 	movt	r2, #2
   12302:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   12304:	460b      	mov	r3, r1
   12306:	00db      	lsls	r3, r3, #3
   12308:	440b      	add	r3, r1
   1230a:	005b      	lsls	r3, r3, #1
   1230c:	440b      	add	r3, r1
   1230e:	0119      	lsls	r1, r3, #4
   12310:	440b      	add	r3, r1
   12312:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   12314:	440b      	add	r3, r1
   12316:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
   1231a:	2c00      	cmp	r4, #0
   1231c:	d106      	bne.n	1232c <start_update+0x154>
   1231e:	f649 4004 	movw	r0, #39940	; 0x9c04
   12322:	f2c0 0002 	movt	r0, #2
   12326:	2100      	movs	r1, #0
   12328:	f7fe eb2c 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1232c:	7823      	ldrb	r3, [r4, #0]
   1232e:	3301      	adds	r3, #1
   12330:	b2db      	uxtb	r3, r3
   12332:	6878      	ldr	r0, [r7, #4]
   12334:	4629      	mov	r1, r5
   12336:	461a      	mov	r2, r3
   12338:	f7ff fd64 	bl	11e04 <TransmitPkt>
            if((len = GetPacket(fd, RxPktBuf)))
   1233c:	6878      	ldr	r0, [r7, #4]
   1233e:	f649 5160 	movw	r1, #40288	; 0x9d60
   12342:	f2c0 0102 	movt	r1, #2
   12346:	f7ff fde7 	bl	11f18 <GetPacket>
   1234a:	4603      	mov	r3, r0
   1234c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
   12350:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
   12354:	2b00      	cmp	r3, #0
   12356:	f000 8097 	beq.w	12488 <start_update+0x2b0>
            {
                wbsl_data_ack_t *da = RxPktBuf;
   1235a:	f649 5360 	movw	r3, #40288	; 0x9d60
   1235e:	f2c0 0302 	movt	r3, #2
   12362:	623b      	str	r3, [r7, #32]
                printf("Packet %x", (da->packethi << 8) + da->packetlo);
   12364:	6a3b      	ldr	r3, [r7, #32]
   12366:	2b00      	cmp	r3, #0
   12368:	d106      	bne.n	12378 <start_update+0x1a0>
   1236a:	f649 403c 	movw	r0, #39996	; 0x9c3c
   1236e:	f2c0 0002 	movt	r0, #2
   12372:	2100      	movs	r1, #0
   12374:	f7fe eb06 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   12378:	6a3b      	ldr	r3, [r7, #32]
   1237a:	791b      	ldrb	r3, [r3, #4]
   1237c:	461c      	mov	r4, r3
   1237e:	4623      	mov	r3, r4
   12380:	0ddb      	lsrs	r3, r3, #23
   12382:	2b00      	cmp	r3, #0
   12384:	bf14      	ite	ne
   12386:	2301      	movne	r3, #1
   12388:	2300      	moveq	r3, #0
   1238a:	b2db      	uxtb	r3, r3
   1238c:	2b00      	cmp	r3, #0
   1238e:	d008      	beq.n	123a2 <start_update+0x1ca>
   12390:	4623      	mov	r3, r4
   12392:	f649 30dc 	movw	r0, #39900	; 0x9bdc
   12396:	f2c0 0002 	movt	r0, #2
   1239a:	4619      	mov	r1, r3
   1239c:	2208      	movs	r2, #8
   1239e:	f7fe eae0 	blx	10960 <__ubsan_handle_shift_out_of_bounds@plt>
   123a2:	0224      	lsls	r4, r4, #8
   123a4:	6a3b      	ldr	r3, [r7, #32]
   123a6:	2b00      	cmp	r3, #0
   123a8:	d106      	bne.n	123b8 <start_update+0x1e0>
   123aa:	f649 4054 	movw	r0, #40020	; 0x9c54
   123ae:	f2c0 0002 	movt	r0, #2
   123b2:	2100      	movs	r1, #0
   123b4:	f7fe eae6 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   123b8:	6a3b      	ldr	r3, [r7, #32]
   123ba:	795b      	ldrb	r3, [r3, #5]
   123bc:	18e5      	adds	r5, r4, r3
   123be:	2b00      	cmp	r3, #0
   123c0:	db02      	blt.n	123c8 <start_update+0x1f0>
   123c2:	42a5      	cmp	r5, r4
   123c4:	da0a      	bge.n	123dc <start_update+0x204>
   123c6:	e001      	b.n	123cc <start_update+0x1f4>
   123c8:	42a5      	cmp	r5, r4
   123ca:	dd07      	ble.n	123dc <start_update+0x204>
   123cc:	f649 40b4 	movw	r0, #40116	; 0x9cb4
   123d0:	f2c0 0002 	movt	r0, #2
   123d4:	4621      	mov	r1, r4
   123d6:	461a      	mov	r2, r3
   123d8:	f7fe eab6 	blx	10948 <__ubsan_handle_add_overflow@plt>
   123dc:	462b      	mov	r3, r5
   123de:	f642 1078 	movw	r0, #10616	; 0x2978
   123e2:	f2c0 0001 	movt	r0, #1
   123e6:	4619      	mov	r1, r3
   123e8:	f7fe eab4 	blx	10954 <printf@plt>
                if (da->status == WBSL_ACK_STATUS_SUCCESS)
   123ec:	6a3b      	ldr	r3, [r7, #32]
   123ee:	2b00      	cmp	r3, #0
   123f0:	d106      	bne.n	12400 <start_update+0x228>
   123f2:	f649 406c 	movw	r0, #40044	; 0x9c6c
   123f6:	f2c0 0002 	movt	r0, #2
   123fa:	2100      	movs	r1, #0
   123fc:	f7fe eac2 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   12400:	6a3b      	ldr	r3, [r7, #32]
   12402:	78db      	ldrb	r3, [r3, #3]
   12404:	2b01      	cmp	r3, #1
   12406:	d106      	bne.n	12416 <start_update+0x23e>
                {
                    printf("*Succeeded\n");
   12408:	f642 1084 	movw	r0, #10628	; 0x2984
   1240c:	f2c0 0001 	movt	r0, #1
   12410:	f7fe eabe 	blx	10990 <puts@plt>
                    continue;
   12414:	e038      	b.n	12488 <start_update+0x2b0>
                }
                else
                {
                    printf("* Failed\n");
   12416:	f642 1090 	movw	r0, #10640	; 0x2990
   1241a:	f2c0 0001 	movt	r0, #1
   1241e:	f7fe eab8 	blx	10990 <puts@plt>
                    uint16_t nack_nr  = (da->packethi << 8) + da->packetlo;
   12422:	6a3b      	ldr	r3, [r7, #32]
   12424:	2b00      	cmp	r3, #0
   12426:	d106      	bne.n	12436 <start_update+0x25e>
   12428:	f649 4084 	movw	r0, #40068	; 0x9c84
   1242c:	f2c0 0002 	movt	r0, #2
   12430:	2100      	movs	r1, #0
   12432:	f7fe eaa8 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   12436:	6a3b      	ldr	r3, [r7, #32]
   12438:	791b      	ldrb	r3, [r3, #4]
   1243a:	461c      	mov	r4, r3
   1243c:	4623      	mov	r3, r4
   1243e:	0ddb      	lsrs	r3, r3, #23
   12440:	2b00      	cmp	r3, #0
   12442:	bf14      	ite	ne
   12444:	2301      	movne	r3, #1
   12446:	2300      	moveq	r3, #0
   12448:	b2db      	uxtb	r3, r3
   1244a:	2b00      	cmp	r3, #0
   1244c:	d008      	beq.n	12460 <start_update+0x288>
   1244e:	4623      	mov	r3, r4
   12450:	f649 30f0 	movw	r0, #39920	; 0x9bf0
   12454:	f2c0 0002 	movt	r0, #2
   12458:	4619      	mov	r1, r3
   1245a:	2208      	movs	r2, #8
   1245c:	f7fe ea80 	blx	10960 <__ubsan_handle_shift_out_of_bounds@plt>
   12460:	b2a3      	uxth	r3, r4
   12462:	021b      	lsls	r3, r3, #8
   12464:	b29c      	uxth	r4, r3
   12466:	6a3b      	ldr	r3, [r7, #32]
   12468:	2b00      	cmp	r3, #0
   1246a:	d106      	bne.n	1247a <start_update+0x2a2>
   1246c:	f649 409c 	movw	r0, #40092	; 0x9c9c
   12470:	f2c0 0002 	movt	r0, #2
   12474:	2100      	movs	r1, #0
   12476:	f7fe ea86 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1247a:	6a3b      	ldr	r3, [r7, #32]
   1247c:	795b      	ldrb	r3, [r3, #5]
   1247e:	b29b      	uxth	r3, r3
   12480:	4423      	add	r3, r4
   12482:	83fb      	strh	r3, [r7, #30]
                    j = nack_nr;
   12484:	8bfb      	ldrh	r3, [r7, #30]
   12486:	62bb      	str	r3, [r7, #40]	; 0x28
            }
        }

        nanosleep(&ack_timeout, NULL);

        for(j = 0; j < npkts[i]; j++)
   12488:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1248a:	1c5c      	adds	r4, r3, #1
   1248c:	2301      	movs	r3, #1
   1248e:	2b00      	cmp	r3, #0
   12490:	db03      	blt.n	1249a <start_update+0x2c2>
   12492:	6abb      	ldr	r3, [r7, #40]	; 0x28
   12494:	429c      	cmp	r4, r3
   12496:	da0b      	bge.n	124b0 <start_update+0x2d8>
   12498:	e002      	b.n	124a0 <start_update+0x2c8>
   1249a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1249c:	429c      	cmp	r4, r3
   1249e:	dd07      	ble.n	124b0 <start_update+0x2d8>
   124a0:	f649 40c4 	movw	r0, #40132	; 0x9cc4
   124a4:	f2c0 0002 	movt	r0, #2
   124a8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   124aa:	2201      	movs	r2, #1
   124ac:	f7fe ea4c 	blx	10948 <__ubsan_handle_add_overflow@plt>
   124b0:	62bc      	str	r4, [r7, #40]	; 0x28
   124b2:	f642 33bc 	movw	r3, #11196	; 0x2bbc
   124b6:	f2c0 0302 	movt	r3, #2
   124ba:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   124bc:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   124c0:	461a      	mov	r2, r3
   124c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   124c4:	429a      	cmp	r2, r3
   124c6:	f73f af08 	bgt.w	122da <start_update+0x102>
                    j = nack_nr;
                }
            }
        }

        GetPacket(fd, RxPktBuf);
   124ca:	6878      	ldr	r0, [r7, #4]
   124cc:	f649 5160 	movw	r1, #40288	; 0x9d60
   124d0:	f2c0 0102 	movt	r1, #2
   124d4:	f7ff fd20 	bl	11f18 <GetPacket>
        nanosleep(&wait_restart, NULL);
   124d8:	f107 030c 	add.w	r3, r7, #12
   124dc:	4618      	mov	r0, r3
   124de:	2100      	movs	r1, #0
   124e0:	f7fe ea5c 	blx	1099c <nanosleep@plt>
    int j;
    uint8_t retx = 0;
    uint8_t len = 0;
    struct timespec ack_timeout = { .tv_nsec = 20000};
    struct timespec wait_restart = { .tv_nsec = 200000};
    for ( i = 0; i <  sizeof(npkts)/sizeof(npkts[0]); i++)
   124e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   124e6:	1c5c      	adds	r4, r3, #1
   124e8:	2301      	movs	r3, #1
   124ea:	2b00      	cmp	r3, #0
   124ec:	db03      	blt.n	124f6 <start_update+0x31e>
   124ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   124f0:	429c      	cmp	r4, r3
   124f2:	da0b      	bge.n	1250c <start_update+0x334>
   124f4:	e002      	b.n	124fc <start_update+0x324>
   124f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   124f8:	429c      	cmp	r4, r3
   124fa:	dd07      	ble.n	1250c <start_update+0x334>
   124fc:	f649 40d4 	movw	r0, #40148	; 0x9cd4
   12500:	f2c0 0002 	movt	r0, #2
   12504:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   12506:	2201      	movs	r2, #1
   12508:	f7fe ea1e 	blx	10948 <__ubsan_handle_add_overflow@plt>
   1250c:	62fc      	str	r4, [r7, #44]	; 0x2c
   1250e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   12510:	2b01      	cmp	r3, #1
   12512:	f67f ae7e 	bls.w	12212 <start_update+0x3a>
        }

        GetPacket(fd, RxPktBuf);
        nanosleep(&wait_restart, NULL);
    }
    return 0;
   12516:	2300      	movs	r3, #0
}
   12518:	4618      	mov	r0, r3
   1251a:	3730      	adds	r7, #48	; 0x30
   1251c:	46bd      	mov	sp, r7
   1251e:	bdb0      	pop	{r4, r5, r7, pc}

00012520 <main>:

int main(int argc, char **argv)
{
   12520:	b590      	push	{r4, r7, lr}
   12522:	b087      	sub	sp, #28
   12524:	af00      	add	r7, sp, #0
   12526:	6078      	str	r0, [r7, #4]
   12528:	6039      	str	r1, [r7, #0]
    int fd;
    fset_t fset = ISM_US;
   1252a:	2301      	movs	r3, #1
   1252c:	617b      	str	r3, [r7, #20]
    uint8_t status;

    if (argc == 2)
   1252e:	687b      	ldr	r3, [r7, #4]
   12530:	2b02      	cmp	r3, #2
   12532:	d152      	bne.n	125da <main+0xba>
    {
        if (!strcmp(argv[1], "US"))
   12534:	683b      	ldr	r3, [r7, #0]
   12536:	1d1c      	adds	r4, r3, #4
   12538:	2c00      	cmp	r4, #0
   1253a:	d106      	bne.n	1254a <main+0x2a>
   1253c:	f649 40f4 	movw	r0, #40180	; 0x9cf4
   12540:	f2c0 0002 	movt	r0, #2
   12544:	2100      	movs	r1, #0
   12546:	f7fe ea1e 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1254a:	6823      	ldr	r3, [r4, #0]
   1254c:	4618      	mov	r0, r3
   1254e:	f642 119c 	movw	r1, #10652	; 0x299c
   12552:	f2c0 0101 	movt	r1, #1
   12556:	f7fe ea28 	blx	109a8 <strcmp@plt>
   1255a:	4603      	mov	r3, r0
   1255c:	2b00      	cmp	r3, #0
   1255e:	d102      	bne.n	12566 <main+0x46>
            fset = ISM_US;
   12560:	2301      	movs	r3, #1
   12562:	617b      	str	r3, [r7, #20]
   12564:	e039      	b.n	125da <main+0xba>
        else if (!strcmp(argv[1], "EU"))
   12566:	683b      	ldr	r3, [r7, #0]
   12568:	1d1c      	adds	r4, r3, #4
   1256a:	2c00      	cmp	r4, #0
   1256c:	d106      	bne.n	1257c <main+0x5c>
   1256e:	f649 500c 	movw	r0, #40204	; 0x9d0c
   12572:	f2c0 0002 	movt	r0, #2
   12576:	2100      	movs	r1, #0
   12578:	f7fe ea04 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   1257c:	6823      	ldr	r3, [r4, #0]
   1257e:	4618      	mov	r0, r3
   12580:	f642 11a0 	movw	r1, #10656	; 0x29a0
   12584:	f2c0 0101 	movt	r1, #1
   12588:	f7fe ea0e 	blx	109a8 <strcmp@plt>
   1258c:	4603      	mov	r3, r0
   1258e:	2b00      	cmp	r3, #0
   12590:	d102      	bne.n	12598 <main+0x78>
            fset = ISM_EU;
   12592:	2300      	movs	r3, #0
   12594:	617b      	str	r3, [r7, #20]
   12596:	e020      	b.n	125da <main+0xba>
        else if (!strcmp(argv[1], "LF"))
   12598:	683b      	ldr	r3, [r7, #0]
   1259a:	1d1c      	adds	r4, r3, #4
   1259c:	2c00      	cmp	r4, #0
   1259e:	d106      	bne.n	125ae <main+0x8e>
   125a0:	f649 5024 	movw	r0, #40228	; 0x9d24
   125a4:	f2c0 0002 	movt	r0, #2
   125a8:	2100      	movs	r1, #0
   125aa:	f7fe e9ec 	blx	10984 <__ubsan_handle_type_mismatch@plt>
   125ae:	6823      	ldr	r3, [r4, #0]
   125b0:	4618      	mov	r0, r3
   125b2:	f642 11a4 	movw	r1, #10660	; 0x29a4
   125b6:	f2c0 0101 	movt	r1, #1
   125ba:	f7fe e9f6 	blx	109a8 <strcmp@plt>
   125be:	4603      	mov	r3, r0
   125c0:	2b00      	cmp	r3, #0
   125c2:	d102      	bne.n	125ca <main+0xaa>
            fset = ISM_LF;
   125c4:	2302      	movs	r3, #2
   125c6:	617b      	str	r3, [r7, #20]
   125c8:	e007      	b.n	125da <main+0xba>
        else 
        {
            printf("Unspecified Band, defaulting to 902MHz/US band\n");
   125ca:	f642 10a8 	movw	r0, #10664	; 0x29a8
   125ce:	f2c0 0001 	movt	r0, #1
   125d2:	f7fe e9de 	blx	10990 <puts@plt>
            fset = ISM_US;
   125d6:	2301      	movs	r3, #1
   125d8:	617b      	str	r3, [r7, #20]
        }
    }

    setup_io();
   125da:	f7fe fa61 	bl	10aa0 <setup_io>
    cfg_gpio();
   125de:	f7fe ffff 	bl	115e0 <cfg_gpio>
    fd = open_spi(SPI_DEVNAME);
   125e2:	f242 7040 	movw	r0, #10048	; 0x2740
   125e6:	f2c0 0001 	movt	r0, #1
   125ea:	f7fe fac1 	bl	10b70 <open_spi>
   125ee:	60f8      	str	r0, [r7, #12]
    default_spi_config(fd);
   125f0:	68f8      	ldr	r0, [r7, #12]
   125f2:	f7fe faf3 	bl	10bdc <default_spi_config>
    cc1101_initialize(fd, fset);
   125f6:	68f8      	ldr	r0, [r7, #12]
   125f8:	6979      	ldr	r1, [r7, #20]
   125fa:	f7ff fae5 	bl	11bc8 <cc1101_initialize>
    for( int i = 0; i < 0x3e; i++)
   125fe:	2300      	movs	r3, #0
   12600:	613b      	str	r3, [r7, #16]
   12602:	e027      	b.n	12654 <main+0x134>
    printf("Reg %02x, Val %02x Status %02x\n", i, read_reg(fd, i, &status), status);
   12604:	693b      	ldr	r3, [r7, #16]
   12606:	b2da      	uxtb	r2, r3
   12608:	f107 030b 	add.w	r3, r7, #11
   1260c:	68f8      	ldr	r0, [r7, #12]
   1260e:	4611      	mov	r1, r2
   12610:	461a      	mov	r2, r3
   12612:	f7fe feaf 	bl	11374 <read_reg>
   12616:	4603      	mov	r3, r0
   12618:	461a      	mov	r2, r3
   1261a:	7afb      	ldrb	r3, [r7, #11]
   1261c:	f642 10d8 	movw	r0, #10712	; 0x29d8
   12620:	f2c0 0001 	movt	r0, #1
   12624:	6939      	ldr	r1, [r7, #16]
   12626:	f7fe e996 	blx	10954 <printf@plt>
    setup_io();
    cfg_gpio();
    fd = open_spi(SPI_DEVNAME);
    default_spi_config(fd);
    cc1101_initialize(fd, fset);
    for( int i = 0; i < 0x3e; i++)
   1262a:	693b      	ldr	r3, [r7, #16]
   1262c:	1c5c      	adds	r4, r3, #1
   1262e:	2301      	movs	r3, #1
   12630:	2b00      	cmp	r3, #0
   12632:	db03      	blt.n	1263c <main+0x11c>
   12634:	693b      	ldr	r3, [r7, #16]
   12636:	429c      	cmp	r4, r3
   12638:	da0b      	bge.n	12652 <main+0x132>
   1263a:	e002      	b.n	12642 <main+0x122>
   1263c:	693b      	ldr	r3, [r7, #16]
   1263e:	429c      	cmp	r4, r3
   12640:	dd07      	ble.n	12652 <main+0x132>
   12642:	f649 503c 	movw	r0, #40252	; 0x9d3c
   12646:	f2c0 0002 	movt	r0, #2
   1264a:	6939      	ldr	r1, [r7, #16]
   1264c:	2201      	movs	r2, #1
   1264e:	f7fe e97c 	blx	10948 <__ubsan_handle_add_overflow@plt>
   12652:	613c      	str	r4, [r7, #16]
   12654:	693b      	ldr	r3, [r7, #16]
   12656:	2b3d      	cmp	r3, #61	; 0x3d
   12658:	ddd4      	ble.n	12604 <main+0xe4>
    printf("Reg %02x, Val %02x Status %02x\n", i, read_reg(fd, i, &status), status);
    start_update(fd);
   1265a:	68f8      	ldr	r0, [r7, #12]
   1265c:	f7ff fdbc 	bl	121d8 <start_update>
            fflush(stdout);
            //nanosleep(&sleepval, NULL);
        }
    }
#endif
    close_spi(fd);
   12660:	68f8      	ldr	r0, [r7, #12]
   12662:	f7fe faa1 	bl	10ba8 <close_spi>

    return 0;
   12666:	2300      	movs	r3, #0
}
   12668:	4618      	mov	r0, r3
   1266a:	371c      	adds	r7, #28
   1266c:	46bd      	mov	sp, r7
   1266e:	bd90      	pop	{r4, r7, pc}

00012670 <__libc_csu_init>:
   12670:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12674:	4607      	mov	r7, r0
   12676:	4e0c      	ldr	r6, [pc, #48]	; (126a8 <__libc_csu_init+0x38>)
   12678:	4688      	mov	r8, r1
   1267a:	4d0c      	ldr	r5, [pc, #48]	; (126ac <__libc_csu_init+0x3c>)
   1267c:	4691      	mov	r9, r2
   1267e:	447e      	add	r6, pc
   12680:	f7fe e8f8 	blx	10874 <_init>
   12684:	447d      	add	r5, pc
   12686:	1b76      	subs	r6, r6, r5
   12688:	10b6      	asrs	r6, r6, #2
   1268a:	d00a      	beq.n	126a2 <__libc_csu_init+0x32>
   1268c:	3d04      	subs	r5, #4
   1268e:	2400      	movs	r4, #0
   12690:	3401      	adds	r4, #1
   12692:	f855 3f04 	ldr.w	r3, [r5, #4]!
   12696:	4638      	mov	r0, r7
   12698:	4641      	mov	r1, r8
   1269a:	464a      	mov	r2, r9
   1269c:	4798      	blx	r3
   1269e:	42b4      	cmp	r4, r6
   126a0:	d1f6      	bne.n	12690 <__libc_csu_init+0x20>
   126a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   126a6:	bf00      	nop
   126a8:	000103ae 	.word	0x000103ae
   126ac:	000103a4 	.word	0x000103a4

000126b0 <__libc_csu_fini>:
   126b0:	4770      	bx	lr
   126b2:	bf00      	nop

Disassembly of section .fini:

000126b4 <_fini>:
   126b4:	e92d4008 	push	{r3, lr}
   126b8:	e8bd8008 	pop	{r3, pc}
